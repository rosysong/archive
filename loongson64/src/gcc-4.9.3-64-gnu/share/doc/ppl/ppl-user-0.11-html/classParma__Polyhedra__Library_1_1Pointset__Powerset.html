<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Pointset_Powerset&lt; PSET &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Pointset_Powerset&lt; PSET &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Pointset_Powerset" --><!-- doxytag: inherits="Powerset&lt; Parma_Polyhedra_Library::Determinate&lt; PSET &gt; &gt;" -->
<p>The powerset construction instantiated on PPL pointset domains.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p>Inherits <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset&lt; Parma_Polyhedra_Library::Determinate&lt; PSET &gt; &gt;</a>.</p>

<p><a href="classParma__Polyhedra__Library_1_1Pointset__Powerset-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88358b265bd62da2cd81c56fcd645ff4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::ascii_dump" ref="a88358b265bd62da2cd81c56fcd645ff4" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a88358b265bd62da2cd81c56fcd645ff4">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2abdfa9b2796151d2d8940d14129568"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::ascii_dump" ref="ae2abdfa9b2796151d2d8940d14129568" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae2abdfa9b2796151d2d8940d14129568">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1574856ed0bd50691f53d457f7050a3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::print" ref="ad1574856ed0bd50691f53d457f7050a3" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ad1574856ed0bd50691f53d457f7050a3">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2620151d844d477b43ae04337c554e99"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::ascii_load" ref="a2620151d844d477b43ae04337c554e99" args="(std::istream &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a2620151d844d477b43ae04337c554e99">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae2abdfa9b2796151d2d8940d14129568" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9639bd96c993f44bae8ec9185cf00d45">Pointset_Powerset</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a universe (top) or empty (bottom) <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a>.  <a href="#a9639bd96c993f44bae8ec9185cf00d45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aee7b076885815e52c4678cfc0fb9e5a4">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy constructor.  <a href="#aee7b076885815e52c4678cfc0fb9e5a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename QH &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ab9f1d84ccf75cdd4871b4a4b1ff28325">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; QH &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor: the type <code>QH</code> of the disjuncts in the source powerset is different from <code>PSET</code>.  <a href="#ab9f1d84ccf75cdd4871b4a4b1ff28325"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c28caf6c53b59565d9fe51ad448cbd1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a3c28caf6c53b59565d9fe51ad448cbd1" args="(const Partially_Reduced_Product&lt; QH1, QH2, R &gt; &amp;prp, Complexity_Class complexity=ANY_COMPLEXITY)" -->
template&lt;typename QH1 , typename QH2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a3c28caf6c53b59565d9fe51ad448cbd1">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; QH1, QH2, R &gt; &amp;prp, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a> from a product This will be created as a single disjunct of type PSET that approximates the product. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98db63b080d0117099060e3faa4f0278"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a98db63b080d0117099060e3faa4f0278" args="(const Constraint_System &amp;cs)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a98db63b080d0117099060e3faa4f0278">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a> with a single disjunct approximating the system of constraints <code>cs</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0bf2a85994114dfd0e8574b94c0843e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="aa0bf2a85994114dfd0e8574b94c0843e" args="(const Congruence_System &amp;cgs)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aa0bf2a85994114dfd0e8574b94c0843e">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a> with a single disjunct approximating the system of congruences <code>cgs</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a410bfbb102ec5ec854351c383685ca91">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a pointset_powerset out of a closed polyhedron.  <a href="#a410bfbb102ec5ec854351c383685ca91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a8b27f6597e651407b433a5098a47a76f">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a pointset_powerset out of an nnc polyhedron.  <a href="#a8b27f6597e651407b433a5098a47a76f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a7347d9123ff2c5b816d45a40d74717a9">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;gr, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a pointset_powerset out of a grid.  <a href="#a7347d9123ff2c5b816d45a40d74717a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#afe0167a0ee971c067b50d643ae6c7189">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a pointset_powerset out of an octagonal shape.  <a href="#afe0167a0ee971c067b50d643ae6c7189"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#af9a9dc6ee0a1a214d8d7bbf4ef0d9c67">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;bds, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a pointset_powerset out of a bd shape.  <a href="#af9a9dc6ee0a1a214d8d7bbf4ef0d9c67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a6e44f3d4115b10d2b7365390182c4714">Pointset_Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a pointset_powerset out of a box.  <a href="#a6e44f3d4115b10d2b7365390182c4714"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Pointset_Powerset</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69b8be312d167dfebfba35b91c7c9f95"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::space_dimension" ref="a69b8be312d167dfebfba35b91c7c9f95" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a69b8be312d167dfebfba35b91c7c9f95">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3118b07bb55902e522ddf0375eac899"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::affine_dimension" ref="ab3118b07bb55902e522ddf0375eac899" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ab3118b07bb55902e522ddf0375eac899">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1e68150be7e04e59627d8ee19c76d10"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::is_empty" ref="ad1e68150be7e04e59627d8ee19c76d10" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ad1e68150be7e04e59627d8ee19c76d10">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty powerset. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e6ce9a6495c9482980e3d2f76d948a9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::is_universe" ref="a7e6ce9a6495c9482980e3d2f76d948a9" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a7e6ce9a6495c9482980e3d2f76d948a9">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is the top element of the powerser lattice. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43d9dc891079233f9ec0618bd5d4b46c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::is_topologically_closed" ref="a43d9dc891079233f9ec0618bd5d4b46c" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a43d9dc891079233f9ec0618bd5d4b46c">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if all the disjuncts in <code>*this</code> are topologically closed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade90870acddf26103903da3d9e270088"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::is_bounded" ref="ade90870acddf26103903da3d9e270088" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ade90870acddf26103903da3d9e270088">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if all elements in <code>*this</code> are bounded. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aa1b0f7ebce9dd3f01d55861ea1698fdc">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#aa1b0f7ebce9dd3f01d55861ea1698fdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fddb040df547f46e9581e9ff7f80107"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::is_discrete" ref="a9fddb040df547f46e9581e9ff7f80107" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9fddb040df547f46e9581e9ff7f80107">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a741a79dbeefc27764532e2be63120ff8">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#a741a79dbeefc27764532e2be63120ff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae4d04c972b69315f7f82ef303f1b31e7">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#ae4d04c972b69315f7f82ef303f1b31e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#afbae47064f15bcfd238fbb8e778e4ea1">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#afbae47064f15bcfd238fbb8e778e4ea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#acfb675b82bc6829361d1647880a2e00d">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#acfb675b82bc6829361d1647880a2e00d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae54a4b74cd6e303628d06baa3014a4a9">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#ae54a4b74cd6e303628d06baa3014a4a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a14552a788e6f0f23a513ba57c1ed9129">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#a14552a788e6f0f23a513ba57c1ed9129"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a34d86332404f9819605dbce5ab19f684">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a34d86332404f9819605dbce5ab19f684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a92c73441367e1d9c77bc360a009820b8">geometrically_covers</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> geometrically covers <code>y</code>, i.e., if any point (in some element) of <code>y</code> is also a point (of some element) of <code>*this</code>.  <a href="#a92c73441367e1d9c77bc360a009820b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a65234fd4b0ac6aa8765dc960489104c2">geometrically_equals</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is geometrically equal to <code>y</code>, i.e., if (the elements of) <code>*this</code> and <code>y</code> contain the same set of points.  <a href="#a65234fd4b0ac6aa8765dc960489104c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aa1a9bfc80ee005c6dcf60ad60fbcedfd">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if each disjunct of <code>y</code> is contained in a disjunct of <code>*this</code>.  <a href="#aa1a9bfc80ee005c6dcf60ad60fbcedfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a37fa37c5d3937c14095868add547dac7">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if each disjunct of <code>y</code> is strictly contained in a disjunct of <code>*this</code>.  <a href="#a37fa37c5d3937c14095868add547dac7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afffb0b03585f4317ffa46aff429b2c6c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::contains_integer_point" ref="afffb0b03585f4317ffa46aff429b2c6c" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#afffb0b03585f4317ffa46aff429b2c6c">contains_integer_point</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a0e607a3a4f75933f5770af4a1c435a2f">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between the powerset <code>*this</code> and the constraint <code>c</code>.  <a href="#a0e607a3a4f75933f5770af4a1c435a2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a754588d1a8135cb2944e9cc0fd6ec486">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between the powerset <code>*this</code> and the generator <code>g</code>.  <a href="#a754588d1a8135cb2944e9cc0fd6ec486"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9df4749e0d54f9bb1ba38e2392697fa6">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between the powerset <code>*this</code> and the congruence <code>c</code>.  <a href="#a9df4749e0d54f9bb1ba38e2392697fa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b71c85c9201eabfb945527532eaebb4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::total_memory_in_bytes" ref="a7b71c85c9201eabfb945527532eaebb4" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a7b71c85c9201eabfb945527532eaebb4">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58ee2abcd4b191f32ff78c0e768b18b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::external_memory_in_bytes" ref="a58ee2abcd4b191f32ff78c0e768b18b5" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a58ee2abcd4b191f32ff78c0e768b18b5">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ad5999a9b4d00e7c079fb27a26b640188">hash_code</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#ad5999a9b4d00e7c079fb27a26b640188"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6633280f8aef2c30ed25d9c59544c11"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::OK" ref="aa6633280f8aef2c30ed25d9c59544c11" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aa6633280f8aef2c30ed25d9c59544c11">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space Dimension Preserving Member Functions that May Modify the Pointset_Powerset</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a6ef292d9fbb334ba7994b8d2b3a5e94f">add_disjunct</a> (const PSET &amp;ph)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>ph</code>.  <a href="#a6ef292d9fbb334ba7994b8d2b3a5e94f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a05b872f147220805d2c4ee943a76ef13">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects <code>*this</code> with constraint <code>c</code>.  <a href="#a05b872f147220805d2c4ee943a76ef13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a60f11695efd1e26251b6f2463b989974">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the constraint <code>c</code> to refine <code>*this</code>.  <a href="#a60f11695efd1e26251b6f2463b989974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae816bf5283bdc18773e7b188ef95df81">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects <code>*this</code> with the constraints in <code>cs</code>.  <a href="#ae816bf5283bdc18773e7b188ef95df81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9a99b2b76d216a907dcb515f5ef61cfd">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#a9a99b2b76d216a907dcb515f5ef61cfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9d108150f1f059e76bb60deba0612e92">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects <code>*this</code> with congruence <code>c</code>.  <a href="#a9d108150f1f059e76bb60deba0612e92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#af32491e07197b3d96e0068b353e82211">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the congruence <code>cg</code> to refine <code>*this</code>.  <a href="#af32491e07197b3d96e0068b353e82211"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aec6ff4fd4b372a6635251b3129cadd42">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects <code>*this</code> with the congruences in <code>cgs</code>.  <a href="#aec6ff4fd4b372a6635251b3129cadd42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a0c5d4cd9684f22f35f76212e54b6293a">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#a0c5d4cd9684f22f35f76212e54b6293a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a0ed96a7329312281236730beb476e4b1">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#a0ed96a7329312281236730beb476e4b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a12691e00b643410a6f401c55a2266adc">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#a12691e00b643410a6f401c55a2266adc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ab0a22c4feede666e4f5c3602d21b31ad">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates.  <a href="#ab0a22c4feede666e4f5c3602d21b31ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aae1e3a3bf181638f33c685688c86e816">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#aae1e3a3bf181638f33c685688c86e816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9531e96c825c3a3ec880db64d5886bb9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::topological_closure_assign" ref="a9531e96c825c3a3ec880db64d5886bb9" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9531e96c825c3a3ec880db64d5886bb9">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a778189ac90f9d76fcbf966965b27c791">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#a778189ac90f9d76fcbf966965b27c791"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae21cdaa1460a54fb14ecb34f3ea30cb9">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> an (a smallest) over-approximation as a powerset of the disjunct domain of the set-theoretical difference of <code>*this</code> and <code>y</code>.  <a href="#ae21cdaa1460a54fb14ecb34f3ea30cb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ae86262d281c712780a1fd78570080d6f">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Powerset_Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#ae86262d281c712780a1fd78570080d6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#af98f757db804a7f7c7f0ca1b36198f9b">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#af98f757db804a7f7c7f0ca1b36198f9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#acf126b6efb5eac0ac1b9228cfca539f4">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#acf126b6efb5eac0ac1b9228cfca539f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a1958a70ab97d5ef79b472c38cea304cb">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a1958a70ab97d5ef79b472c38cea304cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a7378d4cf77114743152ad5396a1b7db9">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a7378d4cf77114743152ad5396a1b7db9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a385074bda19450e4b4aba954520ae28b">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a385074bda19450e4b4aba954520ae28b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#adfb4df5b07b3587b3d723514dede020c">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#adfb4df5b07b3587b3d723514dede020c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#abe381af245a3eb59deda1dd8d0743c44">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#abe381af245a3eb59deda1dd8d0743c44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a76fee04931b37e764744156fdc08d84a">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a76fee04931b37e764744156fdc08d84a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aa6540753b860549e4d4be346d7cd0229">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#aa6540753b860549e4d4be346d7cd0229"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a0b8990ac561387e44e8c81debd1c3336">wrap_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> w, <a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> r, <a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> o, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space.  <a href="#a0b8990ac561387e44e8c81debd1c3336"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a99f8aab5b33871c9652a9f70407b30ca">pairwise_reduce</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to <code>*this</code> the result of (recursively) merging together the pairs of disjuncts whose upper-bound is the same as their set-theoretical union.  <a href="#a99f8aab5b33871c9652a9f70407b30ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Widening &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ab8f4c68d176d4a8300a87af39ebe621b">BGP99_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y, Widening wf, unsigned max_disjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of applying the <a class="el" href="main.html#pps_bgp99_extrapolation">BGP99 extrapolation operator</a> to <code>*this</code> and <code>y</code>, using the widening function <code>wf</code> and the cardinality threshold <code>max_disjuncts</code>.  <a href="#ab8f4c68d176d4a8300a87af39ebe621b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Cert , typename Widening &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a6390d5b6fde026f0067da39fd1278809">BHZ03_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y, Widening wf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#pps_certificate_widening">BHZ03-widening</a> between <code>*this</code> and <code>y</code>, using the widening function <code>wf</code> certified by the convergence certificate <code>Cert</code>.  <a href="#a6390d5b6fde026f0067da39fd1278809"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad44e727022551209ba94ec652b950b8e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::operator=" ref="ad44e727022551209ba94ec652b950b8e" args="(const Pointset_Powerset &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ad44e727022551209ba94ec652b950b8e">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a931d9a960753fc8314d50a6dbb9f5885"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::operator=" ref="a931d9a960753fc8314d50a6dbb9f5885" args="(const Pointset_Powerset&lt; QH &gt; &amp;y)" -->
template&lt;typename QH &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a931d9a960753fc8314d50a6dbb9f5885">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; QH &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion assignment: the type <code>QH</code> of the disjuncts in the source powerset is different from <code>PSET</code> (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f25c8e732cbe55784504ff6d4f4c49d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::swap" ref="a5f25c8e732cbe55784504ff6d4f4c49d" args="(Pointset_Powerset &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a5f25c8e732cbe55784504ff6d4f4c49d">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c7ca1b6cc1f391be10cd4ab3396de1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_space_dimensions_and_embed" ref="a41c7ca1b6cc1f391be10cd4ab3396de1" args="(dimension_type m)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a41c7ca1b6cc1f391be10cd4ab3396de1">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the vector space containing <code>*this</code> and embeds each disjunct in <code>*this</code> in the new space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab363ed895c854b9e8cb40960a2fc87ce"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_space_dimensions_and_project" ref="ab363ed895c854b9e8cb40960a2fc87ce" args="(dimension_type m)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ab363ed895c854b9e8cb40960a2fc87ce">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the vector space containing <code>*this</code> without embedding the disjuncts in <code>*this</code> in the new space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a3ecaca69acbfe46c80b475d99757138a">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the concatenation of <code>*this</code> and <code>y</code>.  <a href="#a3ecaca69acbfe46c80b475d99757138a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a3ac791813ad39c9adfb99a365636d1f7">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the specified space dimensions.  <a href="#a3ac791813ad39c9adfb99a365636d1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a8d79ac97835780e6ca5e2022abf5ab0b">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the higher space dimensions so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#a8d79ac97835780e6ca5e2022abf5ab0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a9739127a6b925714e0e6cf8d86141938">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a partial function.  <a href="#a9739127a6b925714e0e6cf8d86141938"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a87bccf995617f2884fa2fe2f99479e5e">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#a87bccf995617f2884fa2fe2f99479e5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#affd60938da7b4567564d56fc29d5cedb">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#affd60938da7b4567564d56fc29d5cedb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afed62d6b4c6cd06a08a49942907135bb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::max_space_dimension" ref="afed62d6b4c6cd06a08a49942907135bb" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#afed62d6b4c6cd06a08a49942907135bb">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension a Pointset_Powerset&lt;PSET&gt; can handle. <br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Widening_Function&lt; PSET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a4ff18a1555828c7264a09d6215013279">widen_fun_ref</a> (void(PSET::*wm)(const PSET &amp;, unsigned *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a widening method into a function object.  <a href="#a4ff18a1555828c7264a09d6215013279"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET , typename CSYS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Limited_Widening_Function<br class="typebreak"/>
&lt; PSET, CSYS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ab441eefb3b97b983de4d29baff5a4122">widen_fun_ref</a> (void(PSET::*lwm)(const PSET &amp;, const CSYS &amp;, unsigned *), const CSYS &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a limited widening method into a function object.  <a href="#ab441eefb3b97b983de4d29baff5a4122"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; PSET, <br class="typebreak"/>
<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a><br class="typebreak"/>
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aec119fe2d10b776a4fd9460fd5de4455">linear_partition</a> (const PSET &amp;p, const PSET &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions <code>q</code> with respect to <code>p</code>.  <a href="#aec119fe2d10b776a4fd9460fd5de4455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e1698be31b1b95dc7e28d13ec162d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::check_containment" ref="ad7e1698be31b1b95dc7e28d13ec162d5" args="(const NNC_Polyhedron &amp;ph, const Pointset_Powerset&lt; NNC_Polyhedron &gt; &amp;ps)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#ad7e1698be31b1b95dc7e28d13ec162d5">check_containment</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;ph, const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &gt; &amp;ps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the union of the NNC polyhedra in <code>ps</code> contains the NNC polyhedron <code>ph</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a>, <br class="typebreak"/>
<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a17e25309469009012f40ed891a2c3f01">approximate_partition</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;p, const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;q, bool &amp;finite_partition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the grid <code>q</code> with respect to grid <code>p</code> if and only if such a partition is finite.  <a href="#a17e25309469009012f40ed891a2c3f01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4e612db0eea52c329f5a6be95197b9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::check_containment" ref="a3f4e612db0eea52c329f5a6be95197b9" args="(const Grid &amp;ph, const Pointset_Powerset&lt; Grid &gt; &amp;ps)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a3f4e612db0eea52c329f5a6be95197b9">check_containment</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;ph, const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &gt; &amp;ps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the union of the grids <code>ps</code> contains the grid <code>g</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#aada5fa9557c7ce77d8bfacb622a113cd">check_containment</a> (const PSET &amp;ph, const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;ps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the union of the objects in <code>ps</code> contains <code>ph</code>.  <a href="#aada5fa9557c7ce77d8bfacb622a113cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PSET &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a6b7fdfa5a1979cf3d8e24265225b986e">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a6b7fdfa5a1979cf3d8e24265225b986e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#a69571f990b874f16d0f62235088427ca">check_containment</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;ph, const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &gt; &amp;ps)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename PSET&gt;<br/>
 class Parma_Polyhedra_Library::Pointset_Powerset&lt; PSET &gt;</h3>

<p>The powerset construction instantiated on PPL pointset domains. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>At present, the supported instantiations for the disjunct domain template <code>PSET</code> are the simple pointset domains: <code><a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a></code>, <code><a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a></code>, <code><a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a></code>, <code>Octagonal_Shape&lt;T&gt;</code>, <code>BD_Shape&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9639bd96c993f44bae8ec9185cf00d45"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a9639bd96c993f44bae8ec9185cf00d45" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&#160;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a universe (top) or empty (bottom) <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&#160;</td><td>The number of dimensions of the vector space enclosing the powerset;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&#160;</td><td>Specifies whether the universe or the empty powerset has to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee7b076885815e52c4678cfc0fb9e5a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="aee7b076885815e52c4678cfc0fb9e5a4" args="(const Pointset_Powerset &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordinary copy constructor. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="ab9f1d84ccf75cdd4871b4a4b1ff28325"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="ab9f1d84ccf75cdd4871b4a4b1ff28325" args="(const Pointset_Powerset&lt; QH &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename QH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; QH &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversion constructor: the type <code>QH</code> of the disjuncts in the source powerset is different from <code>PSET</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>The powerset to be used to build the new powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a410bfbb102ec5ec854351c383685ca91"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a410bfbb102ec5ec854351c383685ca91" args="(const C_Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pointset_powerset out of a closed polyhedron. </p>
<p>Builds a powerset that is either empty (if the polyhedron is found to be empty) or contains a single disjunct approximating the polyhedron; this must only use algorithms that do not exceed the specified complexity. The powerset inherits the space dimension of the polyhedron.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&#160;</td><td>The closed polyhedron to be used to build the powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>ph</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b27f6597e651407b433a5098a47a76f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a8b27f6597e651407b433a5098a47a76f" args="(const NNC_Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pointset_powerset out of an nnc polyhedron. </p>
<p>Builds a powerset that is either empty (if the polyhedron is found to be empty) or contains a single disjunct approximating the polyhedron; this must only use algorithms that do not exceed the specified complexity. The powerset inherits the space dimension of the polyhedron.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ph</em>&#160;</td><td>The closed polyhedron to be used to build the powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>ph</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7347d9123ff2c5b816d45a40d74717a9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a7347d9123ff2c5b816d45a40d74717a9" args="(const Grid &amp;gr, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"> <em>gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pointset_powerset out of a grid. </p>
<p>If the grid is nonempty, builds a powerset containing a single disjunct approximating the grid. Builds the empty powerset otherwise. The powerset inherits the space dimension of the grid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gr</em>&#160;</td><td>The grid to be used to build the powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>gr</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe0167a0ee971c067b50d643ae6c7189"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="afe0167a0ee971c067b50d643ae6c7189" args="(const Octagonal_Shape&lt; T &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pointset_powerset out of an octagonal shape. </p>
<p>If the octagonal shape is nonempty, builds a powerset containing a single disjunct approximating the octagonal shape. Builds the empty powerset otherwise. The powerset inherits the space dimension of the octagonal shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&#160;</td><td>The octagonal shape to be used to build the powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9a9dc6ee0a1a214d8d7bbf4ef0d9c67"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="af9a9dc6ee0a1a214d8d7bbf4ef0d9c67" args="(const BD_Shape&lt; T &gt; &amp;bds, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>bds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pointset_powerset out of a bd shape. </p>
<p>If the bd shape is nonempty, builds a powerset containing a single disjunct approximating the bd shape. Builds the empty powerset otherwise. The powerset inherits the space dimension of the bd shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bds</em>&#160;</td><td>The bd shape to be used to build the powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>bdss</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e44f3d4115b10d2b7365390182c4714"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::Pointset_Powerset" ref="a6e44f3d4115b10d2b7365390182c4714" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a pointset_powerset out of a box. </p>
<p>If the box is nonempty, builds a powerset containing a single disjunct approximating the box. Builds the empty powerset otherwise. The powerset inherits the space dimension of the box.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&#160;</td><td>The box to be used to build the powerset.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa1b0f7ebce9dd3f01d55861ea1698fdc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::is_disjoint_from" ref="aa1b0f7ebce9dd3f01d55861ea1698fdc" args="(const Pointset_Powerset &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a741a79dbeefc27764532e2be63120ff8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::constrains" ref="a741a79dbeefc27764532e2be63120ff8" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A variable is constrained if there exists a non-redundant disjunct that is constraining the variable: this definition relies on the powerset lattice structure and may be somewhat different from the geometric intuition. For instance, variable <img class="formulaInl" alt="$x$" src="form_21.png"/> is constrained in the powerset <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathit{ps} = \bigl\{ \{ x \geq 0 \}, \{ x \leq 0 \} \bigr\}, \]" src="form_743.png"/>
</p>
 even though <img class="formulaInl" alt="$\mathit{ps}$" src="form_744.png"/> is geometrically equal to the whole vector space. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4d04c972b69315f7f82ef303f1b31e7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::bounds_from_above" ref="ae4d04c972b69315f7f82ef303f1b31e7" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbae47064f15bcfd238fbb8e778e4ea1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::bounds_from_below" ref="afbae47064f15bcfd238fbb8e778e4ea1" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfb675b82bc6829361d1647880a2e00d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::maximize" ref="acfb675b82bc6829361d1647880a2e00d" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>maximum</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&#160;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&#160;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&#160;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="ae54a4b74cd6e303628d06baa3014a4a9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::maximize" ref="ae54a4b74cd6e303628d06baa3014a4a9" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&#160;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&#160;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&#160;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&#160;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a14552a788e6f0f23a513ba57c1ed9129"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::minimize" ref="a14552a788e6f0f23a513ba57c1ed9129" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>minimum</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&#160;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&#160;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&#160;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a34d86332404f9819605dbce5ab19f684"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::minimize" ref="a34d86332404f9819605dbce5ab19f684" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&#160;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&#160;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&#160;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&#160;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a92c73441367e1d9c77bc360a009820b8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::geometrically_covers" ref="a92c73441367e1d9c77bc360a009820b8" args="(const Pointset_Powerset &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::geometrically_covers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> geometrically covers <code>y</code>, i.e., if any point (in some element) of <code>y</code> is also a point (of some element) of <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This may be <em>really</em> expensive! </dd></dl>

</div>
</div>
<a class="anchor" id="a65234fd4b0ac6aa8765dc960489104c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::geometrically_equals" ref="a65234fd4b0ac6aa8765dc960489104c2" args="(const Pointset_Powerset &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::geometrically_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is geometrically equal to <code>y</code>, i.e., if (the elements of) <code>*this</code> and <code>y</code> contain the same set of points. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This may be <em>really</em> expensive! </dd></dl>

</div>
</div>
<a class="anchor" id="aa1a9bfc80ee005c6dcf60ad60fbcedfd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::contains" ref="aa1a9bfc80ee005c6dcf60ad60fbcedfd" args="(const Pointset_Powerset &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if each disjunct of <code>y</code> is contained in a disjunct of <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37fa37c5d3937c14095868add547dac7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::strictly_contains" ref="a37fa37c5d3937c14095868add547dac7" args="(const Pointset_Powerset &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if each disjunct of <code>y</code> is strictly contained in a disjunct of <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e607a3a4f75933f5770af4a1c435a2f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::relation_with" ref="a0e607a3a4f75933f5770af4a1c435a2f" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between the powerset <code>*this</code> and the constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a754588d1a8135cb2944e9cc0fd6ec486"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::relation_with" ref="a754588d1a8135cb2944e9cc0fd6ec486" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between the powerset <code>*this</code> and the generator <code>g</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9df4749e0d54f9bb1ba38e2392697fa6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::relation_with" ref="a9df4749e0d54f9bb1ba38e2392697fa6" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between the powerset <code>*this</code> and the congruence <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and congruence <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5999a9b4d00e7c079fb27a26b640188"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::hash_code" ref="ad5999a9b4d00e7c079fb27a26b640188" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::hash_code </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a 32-bit hash code for <code>*this</code>. </p>
<p>If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. </p>

</div>
</div>
<a class="anchor" id="a6ef292d9fbb334ba7994b8d2b3a5e94f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_disjunct" ref="a6ef292d9fbb334ba7994b8d2b3a5e94f" args="(const PSET &amp;ph)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::add_disjunct </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&#160;</td>
          <td class="paramname"> <em>ph</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> the disjunct <code>ph</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>ph</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05b872f147220805d2c4ee943a76ef13"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_constraint" ref="a05b872f147220805d2c4ee943a76ef13" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects <code>*this</code> with constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60f11695efd1e26251b6f2463b989974"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::refine_with_constraint" ref="a60f11695efd1e26251b6f2463b989974" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraint <code>c</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&#160;</td><td>The constraint to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae816bf5283bdc18773e7b188ef95df81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_constraints" ref="ae816bf5283bdc18773e7b188ef95df81" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects <code>*this</code> with the constraints in <code>cs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints to intersect with.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a99b2b76d216a907dcb515f5ef61cfd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::refine_with_constraints" ref="a9a99b2b76d216a907dcb515f5ef61cfd" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraints in <code>cs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d108150f1f059e76bb60deba0612e92"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_congruence" ref="a9d108150f1f059e76bb60deba0612e92" args="(const Congruence &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects <code>*this</code> with congruence <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and congruence <code>c</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af32491e07197b3d96e0068b353e82211"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::refine_with_congruence" ref="af32491e07197b3d96e0068b353e82211" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the congruence <code>cg</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&#160;</td><td>The congruence to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec6ff4fd4b372a6635251b3129cadd42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::add_congruences" ref="aec6ff4fd4b372a6635251b3129cadd42" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects <code>*this</code> with the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>The congruences to intersect with.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c5d4cd9684f22f35f76212e54b6293a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::refine_with_congruences" ref="a0c5d4cd9684f22f35f76212e54b6293a" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the congruences in <code>cgs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>The congruences to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ed96a7329312281236730beb476e4b1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::unconstrain" ref="a0ed96a7329312281236730beb476e4b1" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12691e00b643410a6f401c55a2266adc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::unconstrain" ref="a12691e00b643410a6f401c55a2266adc" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0a22c4feede666e4f5c3602d21b31ad"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::drop_some_non_integer_points" ref="ab0a22c4feede666e4f5c3602d21b31ad" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aae1e3a3bf181638f33c685688c86e816"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::drop_some_non_integer_points" ref="aae1e3a3bf181638f33c685688c86e816" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a778189ac90f9d76fcbf966965b27c791"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::intersection_assign" ref="a778189ac90f9d76fcbf966965b27c791" args="(const Pointset_Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. </p>
<p>The result is obtained by intersecting each disjunct in <code>*this</code> with each disjunct in <code>y</code> and collecting all these intersections. </p>

</div>
</div>
<a class="anchor" id="ae21cdaa1460a54fb14ecb34f3ea30cb9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::difference_assign" ref="ae21cdaa1460a54fb14ecb34f3ea30cb9" args="(const Pointset_Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> an (a smallest) over-approximation as a powerset of the disjunct domain of the set-theoretical difference of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae86262d281c712780a1fd78570080d6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::simplify_using_context_assign" ref="ae86262d281c712780a1fd78570080d6f" args="(const Pointset_Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Powerset_Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af98f757db804a7f7c7f0ca1b36198f9b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::affine_image" ref="af98f757db804a7f7c7f0ca1b36198f9b" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf126b6efb5eac0ac1b9228cfca539f4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::affine_preimage" ref="acf126b6efb5eac0ac1b9228cfca539f4" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1958a70ab97d5ef79b472c38cea304cb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::generalized_affine_image" ref="a1958a70ab97d5ef79b472c38cea304cb" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7378d4cf77114743152ad5396a1b7db9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::generalized_affine_preimage" ref="a7378d4cf77114743152ad5396a1b7db9" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a385074bda19450e4b4aba954520ae28b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::generalized_affine_image" ref="a385074bda19450e4b4aba954520ae28b" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&#160;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&#160;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfb4df5b07b3587b3d723514dede020c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::generalized_affine_preimage" ref="adfb4df5b07b3587b3d723514dede020c" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&#160;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&#160;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>*this</code> is a <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a> and <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe381af245a3eb59deda1dd8d0743c44"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::bounded_affine_image" ref="abe381af245a3eb59deda1dd8d0743c44" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&#160;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&#160;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76fee04931b37e764744156fdc08d84a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::bounded_affine_preimage" ref="a76fee04931b37e764744156fdc08d84a" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&#160;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&#160;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6540753b860549e4d4be346d7cd0229"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::time_elapse_assign" ref="aa6540753b860549e4d4be346d7cd0229" args="(const Pointset_Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. </p>
<p>The result is obtained by computing the pairwise <a class="el" href="main.html#Time_Elapse_Operator">time elapse</a> of each disjunct in <code>*this</code> with each disjunct in <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="a0b8990ac561387e44e8c81debd1c3336"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::wrap_assign" ref="a0b8990ac561387e44e8c81debd1c3336" args="(const Variables_Set &amp;vars, Bounded_Integer_Type_Width w, Bounded_Integer_Type_Representation r, Bounded_Integer_Type_Overflow o, const Constraint_System *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::wrap_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a>&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a>&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a>&#160;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *&#160;</td>
          <td class="paramname"> <em>pcs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"> <em>complexity_threshold</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wrap_individually</em> = <code>true</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&#160;</td><td>The width of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&#160;</td><td>The representation of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&#160;</td><td>The overflow behavior of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcs</em>&#160;</td><td>Possibly null pointer to a constraint system whose variables are contained in <code>vars</code>. If <code>*pcs</code> depends on variables not in <code>vars</code>, the behavior is undefined. When non-null, the pointed-to constraint system is assumed to represent the conditional or looping construct guard with respect to which wrapping is performed. Since wrapping requires the computation of upper bounds and due to non-distributivity of constraint refinement over upper bounds, passing a constraint system in this way can be more precise than refining the result of the wrapping operation with the constraints in <code>*pcs</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity_threshold</em>&#160;</td><td>A precision parameter of the <a class="el" href="main.html#Wrapping_Operator">wrapping operator</a>: higher values result in possibly improved precision.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrap_individually</em>&#160;</td><td><code>true</code> if the dimensions should be wrapped individually (something that results in much greater efficiency to the detriment of precision).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*pcs</code> is dimension-incompatible with <code>vars</code>, or if <code>*this</code> is dimension-incompatible <code>vars</code> or with <code>*pcs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99f8aab5b33871c9652a9f70407b30ca"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::pairwise_reduce" ref="a99f8aab5b33871c9652a9f70407b30ca" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::pairwise_reduce </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign to <code>*this</code> the result of (recursively) merging together the pairs of disjuncts whose upper-bound is the same as their set-theoretical union. </p>
<p>On exit, for all the pairs <img class="formulaInl" alt="$\cP$" src="form_58.png"/>, <img class="formulaInl" alt="$\cQ$" src="form_146.png"/> of different disjuncts in <code>*this</code>, we have <img class="formulaInl" alt="$\cP \uplus \cQ \neq \cP \union \cQ$" src="form_745.png"/>. </p>

</div>
</div>
<a class="anchor" id="ab8f4c68d176d4a8300a87af39ebe621b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::BGP99_extrapolation_assign" ref="ab8f4c68d176d4a8300a87af39ebe621b" args="(const Pointset_Powerset &amp;y, Widening wf, unsigned max_disjuncts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename Widening &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::BGP99_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Widening&#160;</td>
          <td class="paramname"> <em>wf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"> <em>max_disjuncts</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of applying the <a class="el" href="main.html#pps_bgp99_extrapolation">BGP99 extrapolation operator</a> to <code>*this</code> and <code>y</code>, using the widening function <code>wf</code> and the cardinality threshold <code>max_disjuncts</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A powerset that <em>must</em> definitely entail <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wf</em>&#160;</td><td>The widening function to be used on polyhedra objects. It is obtained from the corresponding widening method by using the helper function Parma_Polyhedra_Library::widen_fun_ref. Legal values are, e.g., <code>widen_fun_ref(&amp;Polyhedron::H79_widening_assign)</code> and <code>widen_fun_ref(&amp;Polyhedron::limited_H79_extrapolation_assign, cs)</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_disjuncts</em>&#160;</td><td>The maximum number of disjuncts occurring in the powerset <code>*this</code> <em>before</em> starting the computation. If this number is exceeded, some of the disjuncts in <code>*this</code> are collapsed (i.e., joined together).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>For a description of the extrapolation operator, see <a class="el" href="main.html#BGP99">[BGP99]</a> and <a class="el" href="main.html#BHZ03b">[BHZ03b]</a>. </p>

</div>
</div>
<a class="anchor" id="a6390d5b6fde026f0067da39fd1278809"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::BHZ03_widening_assign" ref="a6390d5b6fde026f0067da39fd1278809" args="(const Pointset_Powerset &amp;y, Widening wf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename Cert , typename Widening &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::BHZ03_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Widening&#160;</td>
          <td class="paramname"> <em>wf</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#pps_certificate_widening">BHZ03-widening</a> between <code>*this</code> and <code>y</code>, using the widening function <code>wf</code> certified by the convergence certificate <code>Cert</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>The finite powerset computed in the previous iteration step. It <em>must</em> definitely entail <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wf</em>&#160;</td><td>The widening function to be used on disjuncts. It is obtained from the corresponding widening method by using the helper function widen_fun_ref. Legal values are, e.g., <code>widen_fun_ref(&amp;Polyhedron::H79_widening_assign)</code> and <code>widen_fun_ref(&amp;Polyhedron::limited_H79_extrapolation_assign, cs)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>In order to obtain a proper widening operator, the template parameter <code>Cert</code> should be a finite convergence certificate for the base-level widening function <code>wf</code>; otherwise, an extrapolation operator is obtained. For a description of the methods that should be provided by <code>Cert</code>, see <a class="el" href="classParma__Polyhedra__Library_1_1BHRZ03__Certificate.html" title="The convergence certificate for the BHRZ03 widening operator.">BHRZ03_Certificate</a> or <a class="el" href="classParma__Polyhedra__Library_1_1H79__Certificate.html" title="A convergence certificate for the H79 widening operator.">H79_Certificate</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ecaca69acbfe46c80b475d99757138a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::concatenate_assign" ref="a3ecaca69acbfe46c80b475d99757138a" args="(const Pointset_Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the concatenation of <code>*this</code> and <code>y</code>. </p>
<p>The result is obtained by computing the pairwise <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of each disjunct in <code>*this</code> with each disjunct in <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="a3ac791813ad39c9adfb99a365636d1f7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::remove_space_dimensions" ref="a3ac791813ad39c9adfb99a365636d1f7" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified space dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d79ac97835780e6ca5e2022abf5ab0b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::remove_higher_space_dimensions" ref="a8d79ac97835780e6ca5e2022abf5ab0b" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher space dimensions so that the resulting space will have dimension <code>new_dimension</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>new_dimensions</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9739127a6b925714e0e6cf8d86141938"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::map_space_dimensions" ref="a9739127a6b925714e0e6cf8d86141938" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&#160;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a partial function. </p>
<p>See also <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html#a787615432c9f1d6aac5a6394aea8cfa9" title="Remaps the dimensions of the vector space according to a partial function.">Polyhedron::map_space_dimensions</a>. </p>

</div>
</div>
<a class="anchor" id="a87bccf995617f2884fa2fe2f99479e5e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::expand_space_dimension" ref="a87bccf995617f2884fa2fe2f99479e5e" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html#afed62d6b4c6cd06a08a49942907135bb" title="Returns the maximum space dimension a Pointset_Powerset&lt;PSET&gt; can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#Expanding_One_Dimension_of_the_Vector_Space_to_Multiple_Dimensions">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="affd60938da7b4567564d56fc29d5cedb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::fold_space_dimensions" ref="affd60938da7b4567564d56fc29d5cedb" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt;::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>dest</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&#160;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#Folding_Multiple_Dimensions_of_the_Vector_Space_into_One_Dimension">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a4ff18a1555828c7264a09d6215013279"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::widen_fun_ref" ref="a4ff18a1555828c7264a09d6215013279" args="(void(PSET::*wm)(const PSET &amp;, unsigned *))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Widening_Function&lt; PSET &gt; widen_fun_ref </td>
          <td>(</td>
          <td class="paramtype">void(PSET::*)(const PSET &amp;, unsigned *)&#160;</td>
          <td class="paramname"> <em>wm</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps a widening method into a function object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wm</em>&#160;</td><td>The widening method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab441eefb3b97b983de4d29baff5a4122"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::widen_fun_ref" ref="ab441eefb3b97b983de4d29baff5a4122" args="(void(PSET::*lwm)(const PSET &amp;, const CSYS &amp;, unsigned *), const CSYS &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET , typename CSYS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Limited_Widening_Function&lt; PSET, CSYS &gt; widen_fun_ref </td>
          <td>(</td>
          <td class="paramtype">void(PSET::*)(const PSET &amp;, const CSYS &amp;, unsigned *)&#160;</td>
          <td class="paramname"> <em>lwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CSYS &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps a limited widening method into a function object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lwm</em>&#160;</td><td>The limited widening method.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraint system limiting the widening.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec119fe2d10b776a4fd9460fd5de4455"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::linear_partition" ref="aec119fe2d10b776a4fd9460fd5de4455" args="(const PSET &amp;p, const PSET &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; PSET, <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html">NNC_Polyhedron</a> &gt; &gt; linear_partition </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PSET &amp;&#160;</td>
          <td class="paramname"> <em>q</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Partitions <code>q</code> with respect to <code>p</code>. </p>
<p>Let <code>p</code> and <code>q</code> be two polyhedra. The function returns an object <code>r</code> of type <code>std::pair&lt;PSET, <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a>&lt;<a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a>&gt; &gt;</code> such that</p>
<ul>
<li><code>r.first</code> is the intersection of <code>p</code> and <code>q</code>;</li>
<li><code>r.second</code> has the property that all its elements are pairwise disjoint and disjoint from <code>p</code>;</li>
<li>the set-theoretical union of <code>r.first</code> with all the elements of <code>r.second</code> gives <code>q</code> (i.e., <code>r</code> is the representation of a partition of <code>q</code>).</li>
</ul>

</div>
</div>
<a class="anchor" id="a17e25309469009012f40ed891a2c3f01"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::approximate_partition" ref="a17e25309469009012f40ed891a2c3f01" args="(const Grid &amp;p, const Grid &amp;q, bool &amp;finite_partition)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a>, <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &gt; &gt; approximate_partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>finite_partition</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Partitions the grid <code>q</code> with respect to grid <code>p</code> if and only if such a partition is finite. </p>
<p>Let <code>p</code> and <code>q</code> be two grids. The function returns an object <code>r</code> of type <code>std::pair&lt;PSET, <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html" title="The powerset construction instantiated on PPL pointset domains.">Pointset_Powerset</a>&lt;<a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a>&gt; &gt;</code> such that</p>
<ul>
<li><code>r.first</code> is the intersection of <code>p</code> and <code>q</code>;</li>
<li>If there is a finite partition of <code>q</code> wrt <code>p</code> the Boolean <code>finite_partition</code> is set to true and <code>r.second</code> has the property that all its elements are pairwise disjoint and disjoint from <code>p</code> and the set-theoretical union of <code>r.first</code> with all the elements of <code>r.second</code> gives <code>q</code> (i.e., <code>r</code> is the representation of a partition of <code>q</code>).</li>
<li>Otherwise the Boolean <code>finite_partition</code> is set to false and the singleton set that contains <code>q</code> is stored in <code>r.second</code>r. </li>
</ul>

</div>
</div>
<a class="anchor" id="aada5fa9557c7ce77d8bfacb622a113cd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::check_containment" ref="aada5fa9557c7ce77d8bfacb622a113cd" args="(const PSET &amp;ph, const Pointset_Powerset&lt; PSET &gt; &amp;ps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool check_containment </td>
          <td>(</td>
          <td class="paramtype">const PSET &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>ps</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if the union of the objects in <code>ps</code> contains <code>ph</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is assumed that the template parameter PSET can be converted without precision loss into an <a class="el" href="classParma__Polyhedra__Library_1_1NNC__Polyhedron.html" title="A not necessarily closed convex polyhedron.">NNC_Polyhedron</a>; otherwise, an incorrect result might be obtained.</dd></dl>

</div>
</div>
<a class="anchor" id="a6b7fdfa5a1979cf3d8e24265225b986e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::swap" ref="a6b7fdfa5a1979cf3d8e24265225b986e" args="(Parma_Polyhedra_Library::Pointset_Powerset&lt; PSET &gt; &amp;x, Parma_Polyhedra_Library::Pointset_Powerset&lt; PSET &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PSET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Parma_Polyhedra_Library::Pointset_Powerset</a>&lt; PSET &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<a class="anchor" id="a69571f990b874f16d0f62235088427ca"></a><!-- doxytag: member="Parma_Polyhedra_Library::Pointset_Powerset::check_containment" ref="a69571f990b874f16d0f62235088427ca" args="(const C_Polyhedron &amp;ph, const Pointset_Powerset&lt; C_Polyhedron &gt; &amp;ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_containment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Pointset__Powerset.html">Pointset_Powerset</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html">C_Polyhedron</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>ps</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
