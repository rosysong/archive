<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Box&lt; ITV &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Box&lt; ITV &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Box" -->
<p>A not necessarily closed, iso-oriented hyperrectangle.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1Box-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbf26ad2a67dbfbd24eb9c89448a793b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::interval_type" ref="acbf26ad2a67dbfbd24eb9c89448a793b" args="" -->
typedef ITV&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#acbf26ad2a67dbfbd24eb9c89448a793b">interval_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of intervals used to implement the box. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const ITV &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a9e6044d3d1b8cd66b7e150763a0cce2a">get_interval</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference the interval that bounds <code>var</code>.  <a href="#a9e6044d3d1b8cd66b7e150763a0cce2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ad02ce2da26b1d9dcd0d45042b9f5c3e5">set_interval</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const ITV &amp;i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets to <code>i</code> the interval that bounds <code>var</code>.  <a href="#ad02ce2da26b1d9dcd0d45042b9f5c3e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a1d8eb71bd67ae50436968e7323bbeb7e">get_lower_bound</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> k, bool &amp;closed, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;d) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code>k</code>-th space dimension is unbounded below, returns <code>false</code>. Otherwise returns <code>true</code> and set <code>closed</code>, <code>n</code> and <code>d</code> accordingly.  <a href="#a1d8eb71bd67ae50436968e7323bbeb7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#aa7961325727c376428ef2f9431e0c204">get_upper_bound</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> k, bool &amp;closed, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;d) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code>k</code>-th space dimension is unbounded above, returns <code>false</code>. Otherwise returns <code>true</code> and set <code>closed</code>, <code>n</code> and <code>d</code> accordingly.  <a href="#aa7961325727c376428ef2f9431e0c204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab76731fc33f60619d339fd146af90e7f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::constraints" ref="ab76731fc33f60619d339fd146af90e7f" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ab76731fc33f60619d339fd146af90e7f">constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a system of constraints defining <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac61a0c0f3a687ef1d79d9014238554c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::minimized_constraints" ref="aac61a0c0f3a687ef1d79d9014238554c" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#aac61a0c0f3a687ef1d79d9014238554c">minimized_constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimized system of constraints defining <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a319084c6ac93db482a8742a58e2e01f3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::congruences" ref="a319084c6ac93db482a8742a58e2e01f3" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a319084c6ac93db482a8742a58e2e01f3">congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a system of congruences approximating <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f1ce9b2af5f6ba550cd9080ff83077c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::minimized_congruences" ref="a5f1ce9b2af5f6ba550cd9080ff83077c" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a5f1ce9b2af5f6ba550cd9080ff83077c">minimized_congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimized system of congruences approximating <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae627d4ce07125a5bf6dbe4c4464bfacf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::total_memory_in_bytes" ref="ae627d4ce07125a5bf6dbe4c4464bfacf" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ae627d4ce07125a5bf6dbe4c4464bfacf">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcd50fc4fa1b8e5533d7af0513d1a833"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::external_memory_in_bytes" ref="adcd50fc4fa1b8e5533d7af0513d1a833" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#adcd50fc4fa1b8e5533d7af0513d1a833">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a818b1050a44c6fb4d635a6fc088eeeca"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::ascii_dump" ref="a818b1050a44c6fb4d635a6fc088eeeca" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a818b1050a44c6fb4d635a6fc088eeeca">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84d340c4e2a8a35e81d0fb91ff2c466e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::ascii_dump" ref="a84d340c4e2a8a35e81d0fb91ff2c466e" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a84d340c4e2a8a35e81d0fb91ff2c466e">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac72c231542712976d1f9223d0537f5d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::print" ref="ac72c231542712976d1f9223d0537f5d5" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ac72c231542712976d1f9223d0537f5d5">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeb3e0b3cafb96de2ab53e985c574bb7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::set_empty" ref="abeb3e0b3cafb96de2ab53e985c574bb7" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#abeb3e0b3cafb96de2ab53e985c574bb7">set_empty</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the box to become empty, i.e., to represent the empty set. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Assignment, Swap and Destructor</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ab4b097033191e38bbb59add2ebba3e70">Box</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a universe or empty box of the specified space dimension.  <a href="#ab4b097033191e38bbb59add2ebba3e70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#acddbfcdd0e7dd70c2258493ef67d0911">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy constructor.  <a href="#acddbfcdd0e7dd70c2258493ef67d0911"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Other_ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a91546e88fe3474f55bc6f0eceffa7251">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; Other_ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#a91546e88fe3474f55bc6f0eceffa7251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a3f2210364b954a8d532905d09bcb7149">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box from the system of constraints <code>cs</code>.  <a href="#a3f2210364b954a8d532905d09bcb7149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a7fff251a8cd2ecd8b928175af94d7069">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box recycling a system of constraints <code>cs</code>.  <a href="#a7fff251a8cd2ecd8b928175af94d7069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a7ded037fa4c26b2e12565d3aa2c6b70b">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box from the system of generators <code>gs</code>.  <a href="#a7ded037fa4c26b2e12565d3aa2c6b70b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a9de293fc5ed59d0122ccd78839b1a668">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box recycling the system of generators <code>gs</code>.  <a href="#a9de293fc5ed59d0122ccd78839b1a668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a04732c1c89db2f6d76b3b9479ec2fb99">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#addca3baab772ce17fb5133b0c4e60c33">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs, <a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a> dummy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a7e3ffa1dd9894e6418bd153a4cd2de12">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;bds, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=POLYNOMIAL_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box containing the BDS <code>bds</code>.  <a href="#a7e3ffa1dd9894e6418bd153a4cd2de12"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#adb355a57fc1949b2ef9627d45be5f9bc">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;oct, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=POLYNOMIAL_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box containing the octagonal shape <code>oct</code>.  <a href="#adb355a57fc1949b2ef9627d45be5f9bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#af623edfed6d4816ac5573f42a6a1e801">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box containing the polyhedron <code>ph</code>.  <a href="#af623edfed6d4816ac5573f42a6a1e801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a5c02cdac1cee4eda75e568ef9f550da9">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=POLYNOMIAL_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box containing the grid <code>gr</code>.  <a href="#a5c02cdac1cee4eda75e568ef9f550da9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D1 , typename D2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a2f516cd923f94296daf57c8ace328af9">Box</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;dp, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a box containing the partially reduced product <code>dp</code>.  <a href="#a2f516cd923f94296daf57c8ace328af9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8a2f81fc1c5b99600d406300792119f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::operator=" ref="ac8a2f81fc1c5b99600d406300792119f" args="(const Box &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ac8a2f81fc1c5b99600d406300792119f">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf00a3a6522cd0b27a52ba3e2ab5c8ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::swap" ref="adf00a3a6522cd0b27a52ba3e2ab5c8ab" args="(Box &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#adf00a3a6522cd0b27a52ba3e2ab5c8ab">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code> (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Box</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a286412c3f05e82abdf69c5e5562ff949"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::space_dimension" ref="a286412c3f05e82abdf69c5e5562ff949" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a286412c3f05e82abdf69c5e5562ff949">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1a00f36570e89ee95817d898587743"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::affine_dimension" ref="a7e1a00f36570e89ee95817d898587743" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a7e1a00f36570e89ee95817d898587743">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_400.png"/>, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac86971c152fbb8d2d486d7396ad6b142"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::is_empty" ref="ac86971c152fbb8d2d486d7396ad6b142" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ac86971c152fbb8d2d486d7396ad6b142">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty box. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a901382835b88fb9969d88eea101ae7cf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::is_universe" ref="a901382835b88fb9969d88eea101ae7cf" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a901382835b88fb9969d88eea101ae7cf">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe box. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a339a341a2f7d60de83e4feb3e8986558"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::is_topologically_closed" ref="a339a341a2f7d60de83e4feb3e8986558" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a339a341a2f7d60de83e4feb3e8986558">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70638e55ff0529f6f481db703645be05"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::is_discrete" ref="a70638e55ff0529f6f481db703645be05" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a70638e55ff0529f6f481db703645be05">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd6b88d6fd6e0259faa544106b08aeaa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::is_bounded" ref="abd6b88d6fd6e0259faa544106b08aeaa" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#abd6b88d6fd6e0259faa544106b08aeaa">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded box. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a055f3030915a1b7de0cc50761d9a3245"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::contains_integer_point" ref="a055f3030915a1b7de0cc50761d9a3245" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a055f3030915a1b7de0cc50761d9a3245">contains_integer_point</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a573ac186b0da77408bcb80531ca0090c">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#a573ac186b0da77408bcb80531ca0090c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a8e45baf04a16a09cfa25bac864515832">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the constraint <code>c</code>.  <a href="#a8e45baf04a16a09cfa25bac864515832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a3c8e578089e8420dc286b27411fde2fd">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>.  <a href="#a3c8e578089e8420dc286b27411fde2fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a36e39f75a5b973533a044d606444db4f">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the generator <code>g</code>.  <a href="#a36e39f75a5b973533a044d606444db4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ace7b6bb6c1aabdf57f1643e88a834aac">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#ace7b6bb6c1aabdf57f1643e88a834aac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#abb6e0e38bda55fc988819da21f2689eb">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#abb6e0e38bda55fc988819da21f2689eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a40ab06947d065a171792da1ce6ed2505">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#a40ab06947d065a171792da1ce6ed2505"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a90cc17398be6745eb507339397381d7a">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#a90cc17398be6745eb507339397381d7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a1039be5680ea8eceb903367e1e7aa13f">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#a1039be5680ea8eceb903367e1e7aa13f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a9ffb692c7f3bd8af9b81135e38b38dd7">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a9ffb692c7f3bd8af9b81135e38b38dd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a4cd79f95aeca1043d5e56dcc194bf096">frequency</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_d, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_d) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>.  <a href="#a4cd79f95aeca1043d5e56dcc194bf096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a5307e5cfaad0770ede6799ad31962d71">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#a5307e5cfaad0770ede6799ad31962d71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#afe3a91955f4b6b81c8572e60b3e263dc">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#afe3a91955f4b6b81c8572e60b3e263dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a2ebf93b52454102cd99eaa211ad6ff71">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#a2ebf93b52454102cd99eaa211ad6ff71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f964d43c2798bde1924e82d88971ea2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::OK" ref="a2f964d43c2798bde1924e82d88971ea2" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a2f964d43c2798bde1924e82d88971ea2">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> satisfies all its invariants. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space-Dimension Preserving Member Functions that May Modify the Box</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ac5eb33b72a86a33d7ae4685d376b50a6">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of constraints defining <code>*this</code>.  <a href="#ac5eb33b72a86a33d7ae4685d376b50a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#aacf7b2a7e0bb5007ce8cd9506d06137d">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>.  <a href="#aacf7b2a7e0bb5007ce8cd9506d06137d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#aa366a38561684a64bc0a042702534a07">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>.  <a href="#aa366a38561684a64bc0a042702534a07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ab85f80c281c840eedb4f228757b8515a">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> a constraint equivalent to the congruence <code>cg</code>.  <a href="#ab85f80c281c840eedb4f228757b8515a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a92ef9a99d160f55e3fc44a4bd1ae78f2">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#a92ef9a99d160f55e3fc44a4bd1ae78f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a736577ec65f40b0637f13486e64f051a">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#a736577ec65f40b0637f13486e64f051a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ae862a635387c2458da51889c20465f0c">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the constraint <code>c</code> to refine <code>*this</code>.  <a href="#ae862a635387c2458da51889c20465f0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a6d2f7819b7359865679b24e683231303">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the constraints in <code>cs</code> to refine <code>*this</code>.  <a href="#a6d2f7819b7359865679b24e683231303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a944e2c41213d3ea40e74930a90de97bf">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the congruence <code>cg</code> to refine <code>*this</code>.  <a href="#a944e2c41213d3ea40e74930a90de97bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a22f9ceb879f1c8d892f60fb3d9577d81">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the congruences in <code>cgs</code> to refine <code>*this</code>.  <a href="#a22f9ceb879f1c8d892f60fb3d9577d81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a685232ed211cce61f5d27727d979df94">propagate_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the constraint <code>c</code> for constraint propagation on <code>*this</code>.  <a href="#a685232ed211cce61f5d27727d979df94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#abd0fb1fa2293b2ca367d1ba5eba12106">propagate_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> max_iterations=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the constraints in <code>cs</code> for constraint propagagion on <code>*this</code>.  <a href="#abd0fb1fa2293b2ca367d1ba5eba12106"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a87e906459b095e23114ee8f0025086cb">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#a87e906459b095e23114ee8f0025086cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a9ff61047ef1f0f33fe206ab471aa4025">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#a9ff61047ef1f0f33fe206ab471aa4025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a3daaa36a6bf749e0b4d66ce57878e2d0">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#a3daaa36a6bf749e0b4d66ce57878e2d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ae70fafb10013762e436a434564d7e931">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest box containing the union of <code>*this</code> and <code>y</code>.  <a href="#ae70fafb10013762e436a434564d7e931"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ad9dba7a094763a47be44e246c1120fa7">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#ad9dba7a094763a47be44e246c1120fa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a161c87c94b78fd1111365e185d0a3ae7">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the difference of <code>*this</code> and <code>y</code>.  <a href="#a161c87c94b78fd1111365e185d0a3ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#afb683aefdda7a1c5dcf92ee2a03daf81">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#afb683aefdda7a1c5dcf92ee2a03daf81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a06c2ce3f0789aba0294da43628b50226">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#a06c2ce3f0789aba0294da43628b50226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ae1509738a054a1ffeb070a35c41db257">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#ae1509738a054a1ffeb070a35c41db257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#abd266a7d827fb77e09de63dfea2f9d58">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#abd266a7d827fb77e09de63dfea2f9d58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a17182f3f0d9242d5821ba59b2773ae55">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a17182f3f0d9242d5821ba59b2773ae55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#aace7b1f85601837554656295b9c90dce">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#aace7b1f85601837554656295b9c90dce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ae8b96392adb007f1c59758cba8cbc886">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#ae8b96392adb007f1c59758cba8cbc886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#afd20bc6142cb1206b51b0b449ebf4273">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#afd20bc6142cb1206b51b0b449ebf4273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a3d107d8f8a78a3925031545c8e1d1a73">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a3d107d8f8a78a3925031545c8e1d1a73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a6d5097ef9a821f98cb97571eb52a49aa">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#a6d5097ef9a821f98cb97571eb52a49aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96038eb89649898faa9a4355206b72d3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::topological_closure_assign" ref="a96038eb89649898faa9a4355206b72d3" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a96038eb89649898faa9a4355206b72d3">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#af03e6aabc70746d795e2fd524e15f283">wrap_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> w, <a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> r, <a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> o, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space.  <a href="#af03e6aabc70746d795e2fd524e15f283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a2e233c23c81273bd776c73cff35ec60e">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates.  <a href="#a2e233c23c81273bd776c73cff35ec60e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#abe59d09769e8f4ee38d79b45a6295756">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#abe59d09769e8f4ee38d79b45a6295756"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Same&lt; T, <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &gt;<br class="typebreak"/>
::value &amp;&amp;Is_Same_Or_Derived<br class="typebreak"/>
&lt; Interval_Base, ITV &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a00f095adfc747a3b56312f5beb93b621">CC76_widening_assign</a> (const T &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#a00f095adfc747a3b56312f5beb93b621"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Same&lt; T, <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &gt;<br class="typebreak"/>
::value &amp;&amp;Is_Same_Or_Derived<br class="typebreak"/>
&lt; Interval_Base, ITV &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a6df86d90bff51a8827ba3011506639e2">CC76_widening_assign</a> (const T &amp;y, Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#a6df86d90bff51a8827ba3011506639e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6919ec5aef8459ad9c65bc36e8100d58"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::widening_assign" ref="a6919ec5aef8459ad9c65bc36e8100d58" args="(const Box &amp;y, unsigned *tp=0)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a6919ec5aef8459ad9c65bc36e8100d58">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as CC76_widening_assign(y, tp). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#af5edabe0fbfa14196208041ded356c65">limited_CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#af5edabe0fbfa14196208041ded356c65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Same&lt; T, <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &gt;<br class="typebreak"/>
::value &amp;&amp;Is_Same_Or_Derived<br class="typebreak"/>
&lt; Interval_Base, ITV &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a3a5a6288b0ad32439b465341c6c1c528">CC76_narrowing_assign</a> (const T &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of restoring in <code>y</code> the constraints of <code>*this</code> that were lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications.  <a href="#a3a5a6288b0ad32439b465341c6c1c528"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#aba476c1ff2b0f1cd58f6e76b981cafac">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m</code> new dimensions and embeds the old box into the new space.  <a href="#aba476c1ff2b0f1cd58f6e76b981cafac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a4aa52c6b939cf0076740afb33dd454e5">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the box and does not embed it in the new vector space.  <a href="#a4aa52c6b939cf0076740afb33dd454e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a070e05c80af78d7c91bee958b9848080">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeing a box as a set of tuples (its points), assigns to <code>*this</code> all the tuples that can be obtained by concatenating, in the order given, a tuple of <code>*this</code> with a tuple of <code>y</code>.  <a href="#a070e05c80af78d7c91bee958b9848080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a21711374269e4bc42c158e233fd8d384">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the specified dimensions.  <a href="#a21711374269e4bc42c158e233fd8d384"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a929caef76be87459ac964105f4c75cf4">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#a929caef76be87459ac964105f4c75cf4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a597f9740fbc8534391d2c8cb6381660c">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#a597f9740fbc8534391d2c8cb6381660c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a0cb0abcc152d2d7c95a116efd3ea989a">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#a0cb0abcc152d2d7c95a116efd3ea989a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#af0b5a67b4316f5fabc76dddc85e01f95">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#af0b5a67b4316f5fabc76dddc85e01f95"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e6787c98290a49ce80b90c008aac5a8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::max_space_dimension" ref="a4e6787c98290a49ce80b90c008aac5a8" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a4e6787c98290a49ce80b90c008aac5a8">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension that a <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5659d55fb93c1fe31b82a674e2630c13"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::can_recycle_constraint_systems" ref="a5659d55fb93c1fe31b82a674e2630c13" args="()" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a5659d55fb93c1fe31b82a674e2630c13">can_recycle_constraint_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false indicating that this domain does not recycle constraints. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d20ad17015746b2d9e0290631fc175b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::can_recycle_congruence_systems" ref="a1d20ad17015746b2d9e0290631fc175b" args="()" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a1d20ad17015746b2d9e0290631fc175b">can_recycle_congruence_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false indicating that this domain does not recycle congruences. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a5b6323dfa423ea57b8d845237d9b576d">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same box.  <a href="#a5b6323dfa423ea57b8d845237d9b576d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a025c54a0d06e882346b74c0624ee6e71">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> aren't the same box.  <a href="#a025c54a0d06e882346b74c0624ee6e71"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a1915597423b1aa0dbed55312b2308efd">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;box)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a1915597423b1aa0dbed55312b2308efd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a8653fd3779f7a28930872b1f885f25ee">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#a8653fd3779f7a28930872b1f885f25ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a6592baa6045a08fe1eb0ba33e8ed2942">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#a6592baa6045a08fe1eb0ba33e8ed2942"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a2d20e2dc8d4d0fbbdf87bd01a51dc01e">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#a2d20e2dc8d4d0fbbdf87bd01a51dc01e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a438eaa92ba7d9f7d8ec085fe9b00ec0b">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#a438eaa92ba7d9f7d8ec085fe9b00ec0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a852ebcee0de832c12a87ad15d37570a2">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#a852ebcee0de832c12a87ad15d37570a2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename ITV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a4b5e1306956d46f1ee477428b451b44b">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#a4b5e1306956d46f1ee477428b451b44b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename ITV&gt;<br/>
 class Parma_Polyhedra_Library::Box&lt; ITV &gt;</h3>

<p>A not necessarily closed, iso-oriented hyperrectangle. </p>
<p>A <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> object represents the smash product of <img class="formulaInl" alt="$n$" src="form_0.png"/> not necessarily closed and possibly unbounded intervals represented by objects of class <code>ITV</code>, where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the space dimension of the box.</p>
<p>An <em>interval constraint</em> (resp., <em>interval congruence</em>) is a syntactic constraint (resp., congruence) that only mentions a single space dimension.</p>
<p>The <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> domain <em>optimally supports</em>:</p>
<ul>
<li>tautological and inconsistent constraints and congruences;</li>
<li>the interval constraints that are optimally supported by the template argument class <code>ITV</code>;</li>
<li>the interval congruences that are optimally supported by the template argument class <code>ITV</code>.</li>
</ul>
<p>Depending on the method, using a constraint or congruence that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.</p>
<p>The user interface for the <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> domain is meant to be as similar as possible to the one developed for the polyhedron class <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab4b097033191e38bbb59add2ebba3e70"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="ab4b097033191e38bbb59add2ebba3e70" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&#160;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a universe or empty box of the specified space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&#160;</td><td>The number of dimensions of the vector space enclosing the box;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&#160;</td><td>Specifies whether the universe or the empty box has to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acddbfcdd0e7dd70c2258493ef67d0911"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="acddbfcdd0e7dd70c2258493ef67d0911" args="(const Box &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordinary copy constructor. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="a91546e88fe3474f55bc6f0eceffa7251"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a91546e88fe3474f55bc6f0eceffa7251" args="(const Box&lt; Other_ITV &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename Other_ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; Other_ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a conservative, upward approximation of <code>y</code>. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="a3f2210364b954a8d532905d09bcb7149"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a3f2210364b954a8d532905d09bcb7149" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box from the system of constraints <code>cs</code>. </p>
<p>The box inherits the space dimension of <code>cs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>A system of constraints: constraints that are not <a class="el" href="main.html#intervals">interval constraints</a> are ignored (even though they may have contributed to the space dimension). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fff251a8cd2ecd8b928175af94d7069"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a7fff251a8cd2ecd8b928175af94d7069" args="(const Constraint_System &amp;cs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&#160;</td>
          <td class="paramname"> <em>dummy</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box recycling a system of constraints <code>cs</code>. </p>
<p>The box inherits the space dimension of <code>cs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>A system of constraints: constraints that are not <a class="el" href="main.html#intervals">interval constraints</a> are ignored (even though they may have contributed to the space dimension).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&#160;</td><td>A dummy tag to syntactically differentiate this one from the other constructors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ded037fa4c26b2e12565d3aa2c6b70b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a7ded037fa4c26b2e12565d3aa2c6b70b" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box from the system of generators <code>gs</code>. </p>
<p>Builds the smallest box containing the polyhedron defined by <code>gs</code>. The box inherits the space dimension of <code>gs</code>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the system of generators is not empty but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9de293fc5ed59d0122ccd78839b1a668"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a9de293fc5ed59d0122ccd78839b1a668" args="(const Generator_System &amp;gs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&#160;</td>
          <td class="paramname"> <em>dummy</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box recycling the system of generators <code>gs</code>. </p>
<p>Builds the smallest box containing the polyhedron defined by <code>gs</code>. The box inherits the space dimension of <code>gs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gs</em>&#160;</td><td>The generator system describing the polyhedron to be approximated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&#160;</td><td>A dummy tag to syntactically differentiate this one from the other constructors.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the system of generators is not empty but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04732c1c89db2f6d76b3b9479ec2fb99"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a04732c1c89db2f6d76b3b9479ec2fb99" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Builds the smallest box containing the grid defined by a system of congruences <code>cgs</code>. The box inherits the space dimension of <code>cgs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>A system of congruences: congruences that are not non-relational equality constraints are ignored (though they may have contributed to the space dimension). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addca3baab772ce17fb5133b0c4e60c33"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="addca3baab772ce17fb5133b0c4e60c33" args="(const Congruence_System &amp;cgs, Recycle_Input dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__Polyhedra__Library_1_1Recycle__Input.html">Recycle_Input</a>&#160;</td>
          <td class="paramname"> <em>dummy</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Builds the smallest box containing the grid defined by a system of congruences <code>cgs</code>, recycling <code>cgs</code>. The box inherits the space dimension of <code>cgs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>A system of congruences: congruences that are not non-relational equality constraints are ignored (though they will contribute to the space dimension).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dummy</em>&#160;</td><td>A dummy tag to syntactically differentiate this one from the other constructors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e3ffa1dd9894e6418bd153a4cd2de12"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a7e3ffa1dd9894e6418bd153a4cd2de12" args="(const BD_Shape&lt; T &gt; &amp;bds, Complexity_Class complexity=POLYNOMIAL_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>bds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>POLYNOMIAL_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box containing the BDS <code>bds</code>. </p>
<p>Builds the smallest box containing <code>bds</code> using a polynomial algorithm. The <code>complexity</code> argument is ignored. </p>

</div>
</div>
<a class="anchor" id="adb355a57fc1949b2ef9627d45be5f9bc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="adb355a57fc1949b2ef9627d45be5f9bc" args="(const Octagonal_Shape&lt; T &gt; &amp;oct, Complexity_Class complexity=POLYNOMIAL_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>oct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>POLYNOMIAL_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box containing the octagonal shape <code>oct</code>. </p>
<p>Builds the smallest box containing <code>oct</code> using a polynomial algorithm. The <code>complexity</code> argument is ignored. </p>

</div>
</div>
<a class="anchor" id="af623edfed6d4816ac5573f42a6a1e801"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="af623edfed6d4816ac5573f42a6a1e801" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box containing the polyhedron <code>ph</code>. </p>
<p>Builds a box containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the built box is the smallest one containing <code>ph</code>. </p>

</div>
</div>
<a class="anchor" id="a5c02cdac1cee4eda75e568ef9f550da9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a5c02cdac1cee4eda75e568ef9f550da9" args="(const Grid &amp;ph, Complexity_Class complexity=POLYNOMIAL_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>POLYNOMIAL_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box containing the grid <code>gr</code>. </p>
<p>Builds the smallest box containing <code>gr</code> using a polynomial algorithm. The <code>complexity</code> argument is ignored. </p>

</div>
</div>
<a class="anchor" id="a2f516cd923f94296daf57c8ace328af9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::Box" ref="a2f516cd923f94296daf57c8ace328af9" args="(const Partially_Reduced_Product&lt; D1, D2, R &gt; &amp;dp, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename D1 , typename D2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Partially__Reduced__Product.html">Partially_Reduced_Product</a>&lt; D1, D2, R &gt; &amp;&#160;</td>
          <td class="paramname"> <em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a box containing the partially reduced product <code>dp</code>. </p>
<p>Builds a box containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a573ac186b0da77408bcb80531ca0090c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::constrains" ref="a573ac186b0da77408bcb80531ca0090c" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e45baf04a16a09cfa25bac864515832"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::relation_with" ref="a8e45baf04a16a09cfa25bac864515832" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c8e578089e8420dc286b27411fde2fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::relation_with" ref="a3c8e578089e8420dc286b27411fde2fd" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36e39f75a5b973533a044d606444db4f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::relation_with" ref="a36e39f75a5b973533a044d606444db4f" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the generator <code>g</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace7b6bb6c1aabdf57f1643e88a834aac"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::bounds_from_above" ref="ace7b6bb6c1aabdf57f1643e88a834aac" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb6e0e38bda55fc988819da21f2689eb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::bounds_from_below" ref="abb6e0e38bda55fc988819da21f2689eb" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40ab06947d065a171792da1ce6ed2505"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::maximize" ref="a40ab06947d065a171792da1ce6ed2505" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>maximum</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&#160;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&#160;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&#160;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a90cc17398be6745eb507339397381d7a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::maximize" ref="a90cc17398be6745eb507339397381d7a" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&#160;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&#160;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&#160;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&#160;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a1039be5680ea8eceb903367e1e7aa13f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::minimize" ref="a1039be5680ea8eceb903367e1e7aa13f" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>minimum</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&#160;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&#160;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&#160;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a9ffb692c7f3bd8af9b81135e38b38dd7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::minimize" ref="a9ffb692c7f3bd8af9b81135e38b38dd7" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&#160;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&#160;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&#160;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&#160;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a4cd79f95aeca1043d5e56dcc194bf096"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::frequency" ref="a4cd79f95aeca1043d5e56dcc194bf096" args="(const Linear_Expression &amp;expr, Coefficient &amp;freq_n, Coefficient &amp;freq_d, Coefficient &amp;val_n, Coefficient &amp;val_d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>freq_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>freq_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>val_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>val_d</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression for which the frequency is needed;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_n</em>&#160;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$0$" src="form_400.png"/>; Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a>, where the <a class="el" href="main.html#Grid_Frequency">frequency</a> can have a non-zero value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_d</em>&#160;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$1$" src="form_488.png"/>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_n</em>&#160;</td><td>The numerator of <code>val</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_d</em>&#160;</td><td>The denominator of <code>val</code>;</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>false</code> is returned, then <code>freq_n</code>, <code>freq_d</code>, <code>val_n</code> and <code>val_d</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a5307e5cfaad0770ede6799ad31962d71"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::contains" ref="a5307e5cfaad0770ede6799ad31962d71" args="(const Box &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe3a91955f4b6b81c8572e60b3e263dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::strictly_contains" ref="afe3a91955f4b6b81c8572e60b3e263dc" args="(const Box &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ebf93b52454102cd99eaa211ad6ff71"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::is_disjoint_from" ref="a2ebf93b52454102cd99eaa211ad6ff71" args="(const Box &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>x</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5eb33b72a86a33d7ae4685d376b50a6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_constraint" ref="ac5eb33b72a86a33d7ae4685d376b50a6" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of constraint <code>c</code> to the system of constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&#160;</td><td>The constraint to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible, or <code>c</code> is not optimally supported by the <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacf7b2a7e0bb5007ce8cd9506d06137d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_constraints" ref="aacf7b2a7e0bb5007ce8cd9506d06137d" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the box domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa366a38561684a64bc0a042702534a07"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_recycled_constraints" ref="aa366a38561684a64bc0a042702534a07" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; T &gt;::add_recycled_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of constraints defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints to be added. They may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the box domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab85f80c281c840eedb4f228757b8515a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_congruence" ref="ab85f80c281c840eedb4f228757b8515a" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> a constraint equivalent to the congruence <code>cg</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&#160;</td><td>The congruence to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, or <code>cg</code> is not optimally supported by the box domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92ef9a99d160f55e3fc44a4bd1ae78f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_congruences" ref="a92ef9a99d160f55e3fc44a4bd1ae78f2" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>The congruences to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the box domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a736577ec65f40b0637f13486e64f051a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_recycled_congruences" ref="a736577ec65f40b0637f13486e64f051a" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; T &gt;::add_recycled_congruences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>The congruence system to be added to <code>*this</code>. The congruences in <code>cgs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the box domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae862a635387c2458da51889c20465f0c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::refine_with_constraint" ref="ae862a635387c2458da51889c20465f0c" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraint <code>c</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&#160;</td><td>The constraint to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d2f7819b7359865679b24e683231303"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::refine_with_constraints" ref="a6d2f7819b7359865679b24e683231303" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraints in <code>cs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints to be used for refinement. To avoid termination problems, each constraint in <code>cs</code> will be used for a single refinement step.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The user is warned that the accuracy of this refinement operator depends on the order of evaluation of the constraints in <code>cs</code>, which is in general unpredictable. If a fine control on such an order is needed, the user should consider calling the method <code><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#ae862a635387c2458da51889c20465f0c" title="Use the constraint c to refine *this.">refine_with_constraint(const Constraint&amp; c)</a></code> inside an appropriate looping construct. </dd></dl>

</div>
</div>
<a class="anchor" id="a944e2c41213d3ea40e74930a90de97bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::refine_with_congruence" ref="a944e2c41213d3ea40e74930a90de97bf" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the congruence <code>cg</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&#160;</td><td>The congruence to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22f9ceb879f1c8d892f60fb3d9577d81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::refine_with_congruences" ref="a22f9ceb879f1c8d892f60fb3d9577d81" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the congruences in <code>cgs</code> to refine <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>The congruences to be used for refinement.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a685232ed211cce61f5d27727d979df94"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::propagate_constraint" ref="a685232ed211cce61f5d27727d979df94" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::propagate_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraint <code>c</code> for constraint propagation on <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&#160;</td><td>The constraint to be used for constraint propagation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd0fb1fa2293b2ca367d1ba5eba12106"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::propagate_constraints" ref="abd0fb1fa2293b2ca367d1ba5eba12106" args="(const Constraint_System &amp;cs, dimension_type max_iterations=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::propagate_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>max_iterations</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the constraints in <code>cs</code> for constraint propagagion on <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints to be used for constraint propagation.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_iterations</em>&#160;</td><td>The maximum number of propagation steps for each constraint in <code>cs</code>. If zero (the default), the number of propagations will be unbounded, possibly resulting in an infinite loop.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This method may lead to non-termination if <code>max_iterations</code> is 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a87e906459b095e23114ee8f0025086cb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::unconstrain" ref="a87e906459b095e23114ee8f0025086cb" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ff61047ef1f0f33fe206ab471aa4025"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::unconstrain" ref="a9ff61047ef1f0f33fe206ab471aa4025" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3daaa36a6bf749e0b4d66ce57878e2d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::intersection_assign" ref="a3daaa36a6bf749e0b4d66ce57878e2d0" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae70fafb10013762e436a434564d7e931"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::upper_bound_assign" ref="ae70fafb10013762e436a434564d7e931" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::upper_bound_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the smallest box containing the union of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9dba7a094763a47be44e246c1120fa7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::upper_bound_assign_if_exact" ref="ad9dba7a094763a47be44e246c1120fa7" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a161c87c94b78fd1111365e185d0a3ae7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::difference_assign" ref="a161c87c94b78fd1111365e185d0a3ae7" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the difference of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb683aefdda7a1c5dcf92ee2a03daf81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::simplify_using_context_assign" ref="afb683aefdda7a1c5dcf92ee2a03daf81" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06c2ce3f0789aba0294da43628b50226"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::affine_image" ref="a06c2ce3f0789aba0294da43628b50226" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable to which the affine expression is assigned;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1509738a054a1ffeb070a35c41db257"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::affine_preimage" ref="ae1509738a054a1ffeb070a35c41db257" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> to the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable to which the affine expression is substituted;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd266a7d827fb77e09de63dfea2f9d58"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::generalized_affine_image" ref="abd266a7d827fb77e09de63dfea2f9d58" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17182f3f0d9242d5821ba59b2773ae55"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::generalized_affine_preimage" ref="a17182f3f0d9242d5821ba59b2773ae55" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The left hand side variable of the generalized affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the right hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the right hand side affine expression (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aace7b1f85601837554656295b9c90dce"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::generalized_affine_image" ref="aace7b1f85601837554656295b9c90dce" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&#160;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&#160;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8b96392adb007f1c59758cba8cbc886"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::generalized_affine_preimage" ref="ae8b96392adb007f1c59758cba8cbc886" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">generalized affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&#160;</td><td>The left hand side affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&#160;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd20bc6142cb1206b51b0b449ebf4273"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::bounded_affine_image" ref="afd20bc6142cb1206b51b0b449ebf4273" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&#160;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&#160;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d107d8f8a78a3925031545c8e1d1a73"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::bounded_affine_preimage" ref="a3d107d8f8a78a3925031545c8e1d1a73" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&#160;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&#160;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d5097ef9a821f98cb97571eb52a49aa"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::time_elapse_assign" ref="a6d5097ef9a821f98cb97571eb52a49aa" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af03e6aabc70746d795e2fd524e15f283"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::wrap_assign" ref="af03e6aabc70746d795e2fd524e15f283" args="(const Variables_Set &amp;vars, Bounded_Integer_Type_Width w, Bounded_Integer_Type_Representation r, Bounded_Integer_Type_Overflow o, const Constraint_System *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::wrap_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a>&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a>&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a>&#160;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *&#160;</td>
          <td class="paramname"> <em>pcs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"> <em>complexity_threshold</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wrap_individually</em> = <code>true</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&#160;</td><td>The width of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&#160;</td><td>The representation of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&#160;</td><td>The overflow behavior of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcs</em>&#160;</td><td>Possibly null pointer to a constraint system. When non-null, the pointed-to constraint system is assumed to represent the conditional or looping construct guard with respect to which wrapping is performed. Since wrapping requires the computation of upper bounds and due to non-distributivity of constraint refinement over upper bounds, passing a constraint system in this way can be more precise than refining the result of the wrapping operation with the constraints in <code>*pcs</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity_threshold</em>&#160;</td><td>A precision parameter which is ignored for the <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> domain.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrap_individually</em>&#160;</td><td>A precision parameter which is ignored for the <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> domain.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code> or with <code>*pcs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e233c23c81273bd776c73cff35ec60e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::drop_some_non_integer_points" ref="a2e233c23c81273bd776c73cff35ec60e" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abe59d09769e8f4ee38d79b45a6295756"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::drop_some_non_integer_points" ref="abe59d09769e8f4ee38d79b45a6295756" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a00f095adfc747a3b56312f5beb93b621"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::CC76_widening_assign" ref="a00f095adfc747a3b56312f5beb93b621" args="(const T &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Same&lt; T, <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &gt;::value &amp;&amp;Is_Same_Or_Derived&lt; Interval_Base, ITV &gt;::value, void &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::CC76_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-widening</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A box that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6df86d90bff51a8827ba3011506639e2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::CC76_widening_assign" ref="a6df86d90bff51a8827ba3011506639e2" args="(const T &amp;y, Iterator first, Iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Same&lt; T, <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &gt;::value &amp;&amp;Is_Same_Or_Derived&lt; Interval_Base, ITV &gt;::value, void &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::CC76_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>last</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-widening</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A box that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&#160;</td><td>An iterator that points to the first stop-point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&#160;</td><td>An iterator that points one past the last stop-point.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5edabe0fbfa14196208041ded356c65"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::limited_CC76_extrapolation_assign" ref="af5edabe0fbfa14196208041ded356c65" args="(const Box &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::limited_CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A box that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The system of constraints used to improve the widened box.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a5a6288b0ad32439b465341c6c1c528"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::CC76_narrowing_assign" ref="a3a5a6288b0ad32439b465341c6c1c528" args="(const T &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Same&lt; T, <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &gt;::value &amp;&amp;Is_Same_Or_Derived&lt; Interval_Base, ITV &gt;::value, void &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::CC76_narrowing_assign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of restoring in <code>y</code> the constraints of <code>*this</code> that were lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A <a class="el" href="classParma__Polyhedra__Library_1_1Box.html" title="A not necessarily closed, iso-oriented hyperrectangle.">Box</a> that <em>must</em> contain <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>As was the case for widening operators, the argument <code>y</code> is meant to denote the value computed in the previous iteration step, whereas <code>*this</code> denotes the value computed in the current iteration step (in the <em>decreasing</em> iteration sequence). Hence, the call <code>x.CC76_narrowing_assign(y)</code> will assign to <code>x</code> the result of the computation <img class="formulaInl" alt="$\mathtt{y} \Delta \mathtt{x}$" src="form_726.png"/>. </dd></dl>

</div>
</div>
<a class="anchor" id="aba476c1ff2b0f1cd58f6e76b981cafac"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_space_dimensions_and_embed" ref="aba476c1ff2b0f1cd58f6e76b981cafac" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new dimensions and embeds the old box into the new space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The new dimensions will be those having the highest indexes in the new box, which is defined by a system of interval constraints in which the variables running through the new dimensions are unconstrained. For instance, when starting from the box <img class="formulaInl" alt="$\cB \sseq \Rset^2$" src="form_727.png"/> and adding a third dimension, the result will be the box </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cB \,\bigr\}. \]" src="form_728.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a4aa52c6b939cf0076740afb33dd454e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::add_space_dimensions_and_project" ref="a4aa52c6b939cf0076740afb33dd454e5" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::add_space_dimensions_and_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new dimensions to the box and does not embed it in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The new dimensions will be those having the highest indexes in the new box, which is defined by a system of bounded differences in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the box <img class="formulaInl" alt="$\cB \sseq \Rset^2$" src="form_727.png"/> and adding a third dimension, the result will be the box </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cB \,\bigr\}. \]" src="form_729.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a070e05c80af78d7c91bee958b9848080"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::concatenate_assign" ref="a070e05c80af78d7c91bee958b9848080" args="(const Box &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seeing a box as a set of tuples (its points), assigns to <code>*this</code> all the tuples that can be obtained by concatenating, in the order given, a tuple of <code>*this</code> with a tuple of <code>y</code>. </p>
<p>Let <img class="formulaInl" alt="$B \sseq \Rset^n$" src="form_730.png"/> and <img class="formulaInl" alt="$D \sseq \Rset^m$" src="form_731.png"/> be the boxes corresponding, on entry, to <code>*this</code> and <code>y</code>, respectively. Upon successful completion, <code>*this</code> will represent the box <img class="formulaInl" alt="$R \sseq \Rset^{n+m}$" src="form_732.png"/> such that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R \defeq \Bigl\{\, (x_1, \ldots, x_n, y_1, \ldots, y_m)^\transpose \Bigm| (x_1, \ldots, x_n)^\transpose \in B, (y_1, \ldots, y_m)^\transpose \in D \,\Bigl\}. \]" src="form_733.png"/>
</p>
<p> Another way of seeing it is as follows: first increases the space dimension of <code>*this</code> by adding <code>y.space_dimension()</code> new dimensions; then adds to the system of constraints of <code>*this</code> a renamed-apart version of the constraints of <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="a21711374269e4bc42c158e233fd8d384"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::remove_space_dimensions" ref="a21711374269e4bc42c158e233fd8d384" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929caef76be87459ac964105f4c75cf4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::remove_higher_space_dimensions" ref="a929caef76be87459ac964105f4c75cf4" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>new_dimension</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a597f9740fbc8534391d2c8cb6381660c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::map_space_dimensions" ref="a597f9740fbc8534391d2c8cb6381660c" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&#160;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&#160;</td><td>The partial function specifying the destiny of each dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>The template type parameter Partial_Function must provide the following methods. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div><p> returns <code>true</code> if and only if the represented partial function has an empty co-domain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div><p> returns the maximum value that belongs to the co-domain of the partial function. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div><p> Let <img class="formulaInl" alt="$f$" src="form_333.png"/> be the represented function and <img class="formulaInl" alt="$k$" src="form_296.png"/> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is defined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <img class="formulaInl" alt="$f(k)$" src="form_708.png"/> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is undefined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <code>false</code> is returned.</p>
<p>The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. </p>

</div>
</div>
<a class="anchor" id="a0cb0abcc152d2d7c95a116efd3ea989a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::expand_space_dimension" ref="a0cb0abcc152d2d7c95a116efd3ea989a" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1Box.html#a4e6787c98290a49ce80b90c008aac5a8" title="Returns the maximum space dimension that a Box can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="af0b5a67b4316f5fabc76dddc85e01f95"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::fold_space_dimensions" ref="af0b5a67b4316f5fabc76dddc85e01f95" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>dest</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&#160;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<a class="anchor" id="a9e6044d3d1b8cd66b7e150763a0cce2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::get_interval" ref="a9e6044d3d1b8cd66b7e150763a0cce2a" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ITV &amp; <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::get_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference the interval that bounds <code>var</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad02ce2da26b1d9dcd0d45042b9f5c3e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::set_interval" ref="ad02ce2da26b1d9dcd0d45042b9f5c3e5" args="(Variable var, const ITV &amp;i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::set_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITV &amp;&#160;</td>
          <td class="paramname"> <em>i</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets to <code>i</code> the interval that bounds <code>var</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d8eb71bd67ae50436968e7323bbeb7e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::get_lower_bound" ref="a1d8eb71bd67ae50436968e7323bbeb7e" args="(dimension_type k, bool &amp;closed, Coefficient &amp;n, Coefficient &amp;d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::get_lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>d</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the <code>k</code>-th space dimension is unbounded below, returns <code>false</code>. Otherwise returns <code>true</code> and set <code>closed</code>, <code>n</code> and <code>d</code> accordingly. </p>
<p>Let <img class="formulaInl" alt="$I$" src="form_734.png"/> the interval corresponding to the <code>k</code>-th space dimension. If <img class="formulaInl" alt="$I$" src="form_734.png"/> is not bounded from below, simply return <code>false</code>. Otherwise, set <code>closed</code>, <code>n</code> and <code>d</code> as follows: <code>closed</code> is set to <code>true</code> if the the lower boundary of <img class="formulaInl" alt="$I$" src="form_734.png"/> is closed and is set to <code>false</code> otherwise; <code>n</code> and <code>d</code> are assigned the integers <img class="formulaInl" alt="$n$" src="form_0.png"/> and <img class="formulaInl" alt="$d$" src="form_735.png"/> such that the canonical fraction <img class="formulaInl" alt="$n/d$" src="form_736.png"/> corresponds to the greatest lower bound of <img class="formulaInl" alt="$I$" src="form_734.png"/>. The fraction <img class="formulaInl" alt="$n/d$" src="form_736.png"/> is in canonical form if and only if <img class="formulaInl" alt="$n$" src="form_0.png"/> and <img class="formulaInl" alt="$d$" src="form_735.png"/> have no common factors and <img class="formulaInl" alt="$d$" src="form_735.png"/> is positive, <img class="formulaInl" alt="$0/1$" src="form_737.png"/> being the unique representation for zero.</p>
<p>An undefined behavior is obtained if <code>k</code> is greater than or equal to the space dimension of <code>*this</code>. </p>

</div>
</div>
<a class="anchor" id="aa7961325727c376428ef2f9431e0c204"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::get_upper_bound" ref="aa7961325727c376428ef2f9431e0c204" args="(dimension_type k, bool &amp;closed, Coefficient &amp;n, Coefficient &amp;d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Parma_Polyhedra_Library::Box</a>&lt; ITV &gt;::get_upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>d</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the <code>k</code>-th space dimension is unbounded above, returns <code>false</code>. Otherwise returns <code>true</code> and set <code>closed</code>, <code>n</code> and <code>d</code> accordingly. </p>
<p>Let <img class="formulaInl" alt="$I$" src="form_734.png"/> the interval corresponding to the <code>k</code>-th space dimension. If <img class="formulaInl" alt="$I$" src="form_734.png"/> is not bounded from above, simply return <code>false</code>. Otherwise, set <code>closed</code>, <code>n</code> and <code>d</code> as follows: <code>closed</code> is set to <code>true</code> if the the upper boundary of <img class="formulaInl" alt="$I$" src="form_734.png"/> is closed and is set to <code>false</code> otherwise; <code>n</code> and <code>d</code> are assigned the integers <img class="formulaInl" alt="$n$" src="form_0.png"/> and <img class="formulaInl" alt="$d$" src="form_735.png"/> such that the canonical fraction <img class="formulaInl" alt="$n/d$" src="form_736.png"/> corresponds to the least upper bound of <img class="formulaInl" alt="$I$" src="form_734.png"/>.</p>
<p>An undefined behavior is obtained if <code>k</code> is greater than or equal to the space dimension of <code>*this</code>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5b6323dfa423ea57b8d845237d9b576d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::operator==" ref="a5b6323dfa423ea57b8d845237d9b576d" args="(const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same box. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible boxes: in this case, the value <code>false</code> is returned. </p>

</div>
</div>
<a class="anchor" id="a025c54a0d06e882346b74c0624ee6e71"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::operator!=" ref="a025c54a0d06e882346b74c0624ee6e71" args="(const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> aren't the same box. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible boxes: in this case, the value <code>true</code> is returned. </p>

</div>
</div>
<a class="anchor" id="a1915597423b1aa0dbed55312b2308efd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::operator&lt;&lt;" ref="a1915597423b1aa0dbed55312b2308efd" args="(std::ostream &amp;s, const Box&lt; ITV &gt; &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>box</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<a class="anchor" id="a8653fd3779f7a28930872b1f885f25ee"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::rectilinear_distance_assign" ref="a8653fd3779f7a28930872b1f885f25ee" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a6592baa6045a08fe1eb0ba33e8ed2942"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::rectilinear_distance_assign" ref="a6592baa6045a08fe1eb0ba33e8ed2942" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="a2d20e2dc8d4d0fbbdf87bd01a51dc01e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::euclidean_distance_assign" ref="a2d20e2dc8d4d0fbbdf87bd01a51dc01e" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a438eaa92ba7d9f7d8ec085fe9b00ec0b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::euclidean_distance_assign" ref="a438eaa92ba7d9f7d8ec085fe9b00ec0b" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="a852ebcee0de832c12a87ad15d37570a2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::l_infinity_distance_assign" ref="a852ebcee0de832c12a87ad15d37570a2" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a4b5e1306956d46f1ee477428b451b44b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Box::l_infinity_distance_assign" ref="a4b5e1306956d46f1ee477428b451b44b" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Box&lt; ITV &gt; &amp;x, const Box&lt; ITV &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename ITV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; ITV &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
