<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::PIP_Problem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::PIP_Problem Class Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::PIP_Problem" -->
<p>A Parametric Integer (linear) Programming problem.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1PIP__Problem-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a0683916154cde6bb308ccdd9c22e1ece">Control_Parameter_Name</a> { <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a0683916154cde6bb308ccdd9c22e1eceaed708535b4103023ee1a5d24ea5ff7b3">CUTTING_STRATEGY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a0683916154cde6bb308ccdd9c22e1ecea3581e26c004ac37575fd4449822d09c5">PIVOT_ROW_STRATEGY</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Possible names for <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> control parameters. </p>
 <a href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a0683916154cde6bb308ccdd9c22e1ece">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2">Control_Parameter_Value</a> { <br/>
&#160;&#160;<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2a2b86312f1e0350f49b28c23bd3815e9c">CUTTING_STRATEGY_FIRST</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2a31110533316a56c835287f82cba44ab6">CUTTING_STRATEGY_DEEPEST</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2a624c8a3766d76f8eabbb18e9270b32c1">CUTTING_STRATEGY_ALL</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2a9fbd7fce64abd6f1a6459300d77884f4">PIVOT_ROW_STRATEGY_FIRST</a>, 
<br/>
&#160;&#160;<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2adf2b5f608f0f0f055f58d9bedb694855">PIVOT_ROW_STRATEGY_MAX_COLUMN</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Possible values for <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> control parameters. </p>
 <a href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe6c178703fd2e036909f2cbd6cee470"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::const_iterator" ref="abe6c178703fd2e036909f2cbd6cee470" args="" -->
typedef <br class="typebreak"/>
Constraint_Sequence::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abe6c178703fd2e036909f2cbd6cee470">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for the read-only iterator on the constraints defining the feasible region. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a06368fdf7c40ae26305476c42e412172">PIP_Problem</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> dim=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a trivial PIP problem.  <a href="#a06368fdf7c40ae26305476c42e412172"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#aa0b6112961e31a5f3439ce53351d3c20">PIP_Problem</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> dim, In first, In last, const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;p_vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a PIP problem having space dimension <code>dim</code> from the sequence of constraints in the range <img class="formulaInl" alt="$[\mathrm{first}, \mathrm{last})$" src="form_687.png"/>; those dimensions whose indices occur in <code>p_vars</code> are interpreted as parameters.  <a href="#aa0b6112961e31a5f3439ce53351d3c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62d38f242bfeb5c6d1a4ccdb28518538"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::PIP_Problem" ref="a62d38f242bfeb5c6d1a4ccdb28518538" args="(const PIP_Problem &amp;y)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a62d38f242bfeb5c6d1a4ccdb28518538">PIP_Problem</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy-constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38cc9e4158abcf9fa6fb719d079108d1"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::~PIP_Problem" ref="a38cc9e4158abcf9fa6fb719d079108d1" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a38cc9e4158abcf9fa6fb719d079108d1">~PIP_Problem</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af353ca460687792eb573428e18467f44"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::operator=" ref="af353ca460687792eb573428e18467f44" args="(const PIP_Problem &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#af353ca460687792eb573428e18467f44">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25cc092f9c3d26be5b6dac41eb54186c"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::space_dimension" ref="a25cc092f9c3d26be5b6dac41eb54186c" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a25cc092f9c3d26be5b6dac41eb54186c">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the space dimension of the PIP problem. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fe157210b8df0457fa5578d9fa466f0"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::parameter_space_dimensions" ref="a1fe157210b8df0457fa5578d9fa466f0" args="() const " -->
const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a1fe157210b8df0457fa5578d9fa466f0">parameter_space_dimensions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set containing all the variables' indexes representing the parameters of the PIP problem. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56ce97c41ec068deda3ccfd81766ff83"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::constraints_begin" ref="a56ce97c41ec068deda3ccfd81766ff83" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abe6c178703fd2e036909f2cbd6cee470">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a56ce97c41ec068deda3ccfd81766ff83">constraints_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator to the first constraint defining the feasible region. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785a8dddb80c0cf25b4b02f3f38b0631"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::constraints_end" ref="a785a8dddb80c0cf25b4b02f3f38b0631" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abe6c178703fd2e036909f2cbd6cee470">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a785a8dddb80c0cf25b4b02f3f38b0631">constraints_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a past-the-end read-only iterator to the sequence of constraints defining the feasible region. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a04f2cd33bf24eddaa306c392810004ef">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <code>*this</code> to be equal to the trivial PIP problem.  <a href="#a04f2cd33bf24eddaa306c392810004ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a6ffb7a29c69bf20f56f8ba9f16dc74b8">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m_vars, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m_params)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m_vars + m_params</code> new space dimensions and embeds the old PIP problem in the new vector space.  <a href="#a6ffb7a29c69bf20f56f8ba9f16dc74b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#aa221ca31e0aa489ae726efef9234c6d7">add_to_parameter_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;p_vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the space dimensions whose indexes which are in set <code>p_vars</code> to be parameter space dimensions.  <a href="#aa221ca31e0aa489ae726efef9234c6d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a934053580363fb6c281a614d593231f2">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the PIP problem.  <a href="#a934053580363fb6c281a614d593231f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a1c6db3c7a9e8bcc79574dfbb087cf996">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the constraints in <code>cs</code> to the PIP problem.  <a href="#a1c6db3c7a9e8bcc79574dfbb087cf996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a6dd86308a6aa3b0a99e7464fa6d64534">is_satisfiable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks satisfiability of <code>*this</code>.  <a href="#a6dd86308a6aa3b0a99e7464fa6d64534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PPL__CXX__interface.html#gaa7159523299c8f193184a1bda20d6044">PIP_Problem_Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abac8b241f6c2a61248fa768b9157203d">solve</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the PIP problem.  <a href="#abac8b241f6c2a61248fa768b9157203d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html">PIP_Tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#aa7ceb834deaff6303def1cbe95373edc">solution</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a feasible solution for <code>*this</code>, if it exists.  <a href="#aa7ceb834deaff6303def1cbe95373edc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html">PIP_Tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a08ee3b2a32e3b7b8088a84a8beaca0f4">optimizing_solution</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optimizing solution for <code>*this</code>, if it exists.  <a href="#a08ee3b2a32e3b7b8088a84a8beaca0f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37362cbad36fd84d0896ab2f30679f3"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::OK" ref="ae37362cbad36fd84d0896ab2f30679f3" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#ae37362cbad36fd84d0896ab2f30679f3">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8f465629efafec94694b1397a27469b4">print_solution</a> (std::ostream &amp;s, unsigned indent=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints on <code>s</code> the solution computed for <code>*this</code>.  <a href="#a8f465629efafec94694b1397a27469b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a39c345913dd490ff33b698d45b7e2"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::ascii_dump" ref="a77a39c345913dd490ff33b698d45b7e2" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a77a39c345913dd490ff33b698d45b7e2">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a3ca0eb57793c00b0517a6856b8c10"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::ascii_dump" ref="a26a3ca0eb57793c00b0517a6856b8c10" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a26a3ca0eb57793c00b0517a6856b8c10">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9d3cb337b4a4a0fc296d2b5b742b7f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::print" ref="ae9d3cb337b4a4a0fc296d2b5b742b7f2" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#ae9d3cb337b4a4a0fc296d2b5b742b7f2">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f2683794347b7bceb41d88e1b1412d8"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::ascii_load" ref="a2f2683794347b7bceb41d88e1b1412d8" args="(std::istream &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a2f2683794347b7bceb41d88e1b1412d8">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a26a3ca0eb57793c00b0517a6856b8c10" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad750455647786b5cb28c5422930f0ec0"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::total_memory_in_bytes" ref="ad750455647786b5cb28c5422930f0ec0" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#ad750455647786b5cb28c5422930f0ec0">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a7a0b9f3dc8cd6d55e839e20fa28f12"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::external_memory_in_bytes" ref="a2a7a0b9f3dc8cd6d55e839e20fa28f12" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a2a7a0b9f3dc8cd6d55e839e20fa28f12">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a450dfb042f6d81fb394227bdbcb6fb5a"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::swap" ref="a450dfb042f6d81fb394227bdbcb6fb5a" args="(PIP_Problem &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a450dfb042f6d81fb394227bdbcb6fb5a">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfb5615fad7429cb2c340d763df8a43b"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::get_control_parameter" ref="abfb5615fad7429cb2c340d763df8a43b" args="(Control_Parameter_Name name) const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2">Control_Parameter_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abfb5615fad7429cb2c340d763df8a43b">get_control_parameter</a> (<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a0683916154cde6bb308ccdd9c22e1ece">Control_Parameter_Name</a> name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of control parameter <code>name</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a4663bfee916adb9330010328493d6"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::set_control_parameter" ref="ae6a4663bfee916adb9330010328493d6" args="(Control_Parameter_Value value)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#ae6a4663bfee916adb9330010328493d6">set_control_parameter</a> (<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2">Control_Parameter_Value</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets control parameter <code>value</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86401a66d7add563a9fec4a610ca33b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::set_big_parameter_dimension" ref="a86401a66d7add563a9fec4a610ca33b3" args="(dimension_type big_dim)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a86401a66d7add563a9fec4a610ca33b3">set_big_parameter_dimension</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> big_dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dimension for the big parameter to <code>big_dim</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a1fefbce40046822771b243b1d2f1277e">get_big_parameter_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the space dimension for the big parameter.  <a href="#a1fefbce40046822771b243b1d2f1277e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaa2167b4f8ff4184a73ebe46aef2720"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::max_space_dimension" ref="abaa2167b4f8ff4184a73ebe46aef2720" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abaa2167b4f8ff4184a73ebe46aef2720">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> can handle. <br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a77abbac6ae63133e96588f4b57b5c861">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a77abbac6ae63133e96588f4b57b5c861"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#ab31e5714def3177833661bb27f9aff79">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">Parma_Polyhedra_Library::PIP_Problem</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">Parma_Polyhedra_Library::PIP_Problem</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#ab31e5714def3177833661bb27f9aff79"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A Parametric Integer (linear) Programming problem. </p>
<p>An object of this class encodes a parametric integer (linear) programming problem. The PIP problem is specified by providing:</p>
<ul>
<li>the dimension of the vector space;</li>
<li>the subset of those dimensions of the vector space that are interpreted as integer parameters (the other space dimensions are interpreted as non-parameter integer variables);</li>
<li>a finite set of linear equality and (strict or non-strict) inequality constraints involving variables and/or parameters; these constraints are used to define:<ul>
<li>the <em>feasible region</em>, if they involve one or more problem variable (and maybe some parameters);</li>
<li>the <em>initial context</em>, if they only involve the parameters;</li>
</ul>
</li>
<li>optionally, the so-called <em>big parameter</em>, i.e., a problem parameter to be considered arbitrarily big.</li>
</ul>
<p>Note that all problem variables and problem parameters are assumed to take non-negative integer values, so that there is no need to specify non-negativity constraints.</p>
<p>The class provides support for the (incremental) solution of the PIP problem based on variations of the revised simplex method and on Gomory cut generation techniques.</p>
<p>The solution for a PIP problem is the lexicographic minimum of the integer points of the feasible region, expressed in terms of the parameters. As the problem to be solved only involves non-negative variables and parameters, the problem will always be either unfeasible or optimizable.</p>
<p>As the feasibility and the solution value of a PIP problem depend on the values of the parameters, the solution is a binary decision tree, dividing the context parameter set into subsets. The tree nodes are of two kinds:</p>
<ul>
<li><em>Decision</em> nodes. These are internal tree nodes encoding one or more linear tests on the parameters; if all the tests are satisfied, then the solution is the node's <em>true</em> child; otherwise, the solution is the node's <em>false</em> child;</li>
<li><em>Solution</em> nodes. These are leaf nodes in the tree, encoding the solution of the problem in the current context subset, where each variable is defined in terms of a linear expression of the parameters. Solution nodes also optionally embed a set of parameter constraints: if all these constraints are satisfied, the solution is described by the node, otherwise the problem has no solution.</li>
</ul>
<p>It may happen that a decision node has no <em>false</em> child. This means that there is no solution if at least one of the corresponding constraints is not satisfied. Decision nodes having two or more linear tests on the parameters cannot have a <em>false</em> child. Decision nodes always have a <em>true</em> child.</p>
<p>Both kinds of tree nodes may also contain the definition of extra parameters which are artificially introduced by the solver to enforce an integral solution. Such artificial parameters are defined by the integer division of a linear expression on the parameters by an integer coefficient.</p>
<p>By exploiting the incremental nature of the solver, it is possible to reuse part of the computational work already done when solving variants of a given <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a>: currently, incremental resolution supports the addition of space dimensions, the addition of parameters and the addition of constraints.</p>
<dl class="user"><dt><b>Example problem</b></dt><dd>An example PIP problem can be defined the following: <div class="fragment"><pre class="fragment">  3*j &gt;= -2*i+8
  j &lt;= 4*i - 4
  i &lt;= n
  j &lt;= m
</pre></div> where <code>i</code> and <code>j</code> are the problem variables and <code>n</code> and <code>m</code> are the problem parameters. This problem can be optimized; the resulting solution tree may be represented as follows: <div class="fragment"><pre class="fragment">
  if 7*n &gt;= 10 then
    if 7*m &gt;= 12 then
      {i = 2 ; j = 2}
    else
      Parameter P = (m) div 2
      if 2*n + 3*m &gt;= 8 then
        {i = -m - P + 4 ; j = m}
      else
        _|_
  else
    _|_
  </pre></div> The solution tree starts with a decision node depending on the context constraint <code>7*n &gt;= 10</code>. If this constraint is satisfied by the values assigned to the problem parameters, then the (textually first) <code>then</code> branch is taken, reaching the <em>true</em> child of the root node (which in this case is another decision node); otherwise, the (textually last) <code>else</code> branch is taken, for which there is no corresponding <em>false</em> child. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <img class="formulaInl" alt="$\perp$" src="form_531.png"/> notation, also called <em>bottom</em>, denotes the lexicographic minimum of an empty set of solutions, here meaning the corresponding subproblem is unfeasible. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Notice that a tree node may introduce new (non-problem) parameters, as is the case for parameter <code>P</code> in the (textually first) <code>else</code> branch above. These <em>artificial</em> parameters are only meaningful inside the subtree where they are defined and are used to define the parametric values of the problem variables in solution nodes (e.g., the <code>{i,j}</code> vector in the textually third <code>then</code> branch).</dd></dl>
<dl class="user"><dt><b>Context restriction</b></dt><dd>The above solution is correct in an unrestricted initial context, meaning all possible values are allowed for the parameters. If we restrict the context with the following parameter inequalities: <div class="fragment"><pre class="fragment">  m &gt;= n
  n &gt;= 5
</pre></div> then the resulting optimizing tree will be a simple solution node: <div class="fragment"><pre class="fragment">
  {i = 2 ; j = 2}
  </pre></div></dd></dl>
<dl class="user"><dt><b>Creating the PIP_Problem object</b></dt><dd>The <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> object corresponding to the above example can be created as follows: <div class="fragment"><pre class="fragment">  Variable i(0);
  Variable j(1);
  Variable n(2);
  Variable m(3);
  Variables_Set params(n, m);
  Constraint_System cs;
  cs.insert(3*j &gt;= -2*i+8);
  cs.insert(j &lt;= 4*i - 4);
  cs.insert(j &lt;= m);
  cs.insert(i &lt;= n);
  <a class="code" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a06368fdf7c40ae26305476c42e412172" title="Builds a trivial PIP problem.">PIP_Problem</a> pip(cs.space_dimension(), cs.begin(), cs.end(), params);
</pre></div> If you want to restrict the initial context, simply add the parameter constraints the same way as for normal constraints. <div class="fragment"><pre class="fragment">  cs.insert(m &gt;= n);
  cs.insert(n &gt;= 5);
</pre></div></dd></dl>
<dl class="user"><dt><b>Solving the problem</b></dt><dd>Once the <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> object has been created, you can start the resolution of the problem by calling the <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abac8b241f6c2a61248fa768b9157203d" title="Optimizes the PIP problem.">solve()</a> method: <div class="fragment"><pre class="fragment">  <a class="code" href="group__PPL__CXX__interface.html#gaa7159523299c8f193184a1bda20d6044" title="Possible outcomes of the PIP_Problem solver.">PIP_Problem_Status</a> status = pip.solve();
</pre></div> where the returned <code>status</code> indicates if the problem has been optimized or if it is unfeasible for any possible configuration of the parameter values. The resolution process is also started if an attempt is made to get its solution, as follows: <div class="fragment"><pre class="fragment">  <span class="keyword">const</span> PIP_Tree_Node* node = pip.solution();
</pre></div> In this case, an unfeasible problem will result in an empty solution tree, i.e., assigning a null pointer to <code>node</code>.</dd></dl>
<dl class="user"><dt><b>Printing the solution tree</b></dt><dd>A previously computed solution tree may be printed as follows: <div class="fragment"><pre class="fragment">  pip.print_solution(std::cout);
</pre></div> This will produce the following output (note: variables and parameters are printed according to the default output function; see <code><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html#a5012c55d8fdb1420b80a3bfbe5a5b843" title="Sets the output function to be used for printing Variable objects.">Variable::set_output_function</a></code>): <div class="fragment"><pre class="fragment">
  if 7*C &gt;= 10 then
    if 7*D &gt;= 12 then
      {2 ; 2}
    else
      Parameter E = (D) div 2
      if 2*C + 3*D &gt;= 8 then
        {-D - E + 4 ; D}
      else
        _|_
  else
    _|_
  </pre></div></dd></dl>
<dl class="user"><dt><b>Spanning the solution tree</b></dt><dd>A parameter assignment for a PIP problem binds each of the problem parameters to a non-negative integer value. After fixing a parameter assignment, the ``spanning'' of the PIP problem solution tree refers to the process whereby the solution tree is navigated, starting from the root node: the value of artificial parameters is computed according to the parameter assignment and the node's contraints are evaluated, thereby descending in either the true or the false subtree of decision nodes and eventually reaching a solution node or a bottom node. If a solution node is found, each of the problem variables is provided with a parametric expression, which can be evaluated to a fixed value using the given parameter assignment and the computed values for artificial parameters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The coding of the spanning process can be done as follows. First, the root of the PIP solution tree is retrieved: <div class="fragment"><pre class="fragment">  <span class="keyword">const</span> PIP_Tree_Node* node = pip.solution();
</pre></div> If <code>node</code> represents an unfeasible solution (i.e., <img class="formulaInl" alt="$\perp$" src="form_531.png"/>), its value will be <code>0</code>. For a non-null tree node, the virtual methods <code><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html#a41a2c12dc16089ad91de449b4bc72bca" title="Returns this if *this is a decision node, 0 otherwise.">PIP_Tree_Node::as_decision()</a></code> and <code><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html#ace96e068dfc0f943f7d0c8da778648cc" title="Returns this if *this is a solution node, 0 otherwise.">PIP_Tree_Node::as_solution()</a></code> can be used to check whether the node is a decision or a solution node: <div class="fragment"><pre class="fragment">  <span class="keyword">const</span> PIP_Solution_Node* sol = node-&gt;as_solution();
  <span class="keywordflow">if</span> (sol != 0) {
    <span class="comment">// The node is a solution node</span>
    ...
  }
  <span class="keywordflow">else</span> {
    <span class="comment">// The node is a decision node</span>
    <span class="keyword">const</span> PIP_Decision_Node* dec = node-&gt;as_decision();
    ...
  }
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The true (resp., false) child node of a Decision Node may be accessed by using method <code><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Decision__Node.html#a27ccfe6ce15264f53bda385c5d93d0c3" title="Returns a pointer to the b (true or false) branch of *this.">PIP_Decision_Node::child_node(bool)</a></code>, passing <code>true</code> (resp., <code>false</code>) as the input argument.</dd></dl>
<dl class="user"><dt><b>Artificial parameters</b></dt><dd>A <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node_1_1Artificial__Parameter.html" title="Artificial parameters in PIP solution trees.">PIP_Tree_Node::Artificial_Parameter</a> object represents the result of the integer division of a <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html" title="A linear expression.">Linear_Expression</a> (on the other parameters, including the previously-defined artificials) by an integer denominator (a Coefficient object). The dimensions of the artificial parameters (if any) in a tree node have consecutive indices starting from <code>dim+1</code>, where the value of <code>dim</code> is computed as follows:<ul>
<li>for the tree root node, <code>dim</code> is the space dimension of the <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a>;</li>
<li>for any other node of the tree, it is recusrively obtained by adding the value of <code>dim</code> computed for the parent node to the number of artificial parameters defined in the parent node. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since the numbering of dimensions for artificial parameters follows the rule above, the addition of new problem variables and/or new problem parameters to an already solved <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> object (as done when incrementally solving a problem) will result in the systematic renumbering of all the existing artificial parameters.</dd></dl>
<dl class="user"><dt><b>Node constraints</b></dt><dd>All kind of tree nodes can contain context constraints. Decision nodes always contain at least one of them. The node's local constraint system can be obtained using method <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html#a97ccf10304ef9ba8b58549f7570b8cea" title="Returns the system of parameter constraints controlling *this.">PIP_Tree_Node::constraints</a>. These constraints only involve parameters, including both the problem parameters and the artificial parameters that have been defined in nodes occurring on the path from the root node to the current node. The meaning of these constraints is as follows:<ul>
<li>On a decision node, if all tests in the constraints are true, then the solution is the <em>true</em> child; otherwise it is the <em>false</em> child.</li>
<li>On a solution node, if the (possibly empty) system of constraints evaluates to true for a given parameter assignment, then the solution is described by the node; otherwise the solution is <img class="formulaInl" alt="$\perp$" src="form_531.png"/> (i.e., the problem is unfeasible for that parameter assignment).</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Getting the optimal values for the variables</b></dt><dd>After spanning the solution tree using the given parameter assignment, if a solution node has been reached, then it is possible to retrieve the parametric expression for each of the problem variables using method <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Solution__Node.html#a4ec7c4c8093efb70675c35a17d6a7e28" title="Returns a parametric expression for the values of problem variable var.">PIP_Solution_Node::parametric_values</a>. The retrieved expression will be defined in terms of all the parameters (problem parameters and artificial parameters defined along the path).</dd></dl>
<dl class="user"><dt><b>Solving maximization problems</b></dt><dd>You can solve a lexicographic maximization problem by reformulating its constraints using variable substitution. Proceed the following steps:<ul>
<li>Create a big parameter (see <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a86401a66d7add563a9fec4a610ca33b3" title="Sets the dimension for the big parameter to big_dim.">PIP_Problem::set_big_parameter_dimension</a>), which we will call <img class="formulaInl" alt="$M$" src="form_532.png"/>.</li>
<li>Reformulate each of the maximization problem constraints by substituting each <img class="formulaInl" alt="$x_i$" src="form_485.png"/> variable with an expression of the form <img class="formulaInl" alt="$M-x'_i$" src="form_533.png"/>, where the <img class="formulaInl" alt="$x'_i$" src="form_222.png"/> variables are positive variables to be minimized.</li>
<li>Solve the lexicographic minimum for the <img class="formulaInl" alt="$x'$" src="form_534.png"/> variable vector.</li>
<li>In the solution expressions, the values of the <img class="formulaInl" alt="$x'$" src="form_534.png"/> variables will be expressed in the form: <img class="formulaInl" alt="$x'_i = M-x_i$" src="form_535.png"/>. To get back the value of the expression of each <img class="formulaInl" alt="$x_i$" src="form_485.png"/> variable, just apply the formula: <img class="formulaInl" alt="$x_i = M-x'_i$" src="form_536.png"/>. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that if the resulting expression of one of the <img class="formulaInl" alt="$x'_i$" src="form_222.png"/> variables is not in the <img class="formulaInl" alt="$x'_i = M-x_i$" src="form_535.png"/> form, this means that the sign-unrestricted problem is unbounded. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>You can choose to maximize only a subset of the variables while minimizing the other variables. In that case, just apply the variable substitution method on the variables you want to be maximized. The variable optimization priority will still be in lexicographic order.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Example:</b> consider you want to find the lexicographic maximum of the <img class="formulaInl" alt="$(x,y)$" src="form_537.png"/> vector, under the constraints: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\left\{\begin{array}{l} y \geq 2x - 4\\ y \leq -x + p \end{array}\right.\]" src="form_538.png"/>
</p>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>where <img class="formulaInl" alt="$p$" src="form_281.png"/> is a parameter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>After variable substitution, the constraints become: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\left\{\begin{array}{l} M - y \geq 2M - 2x - 4\\ M - y \leq -M + x + p \end{array}\right.\]" src="form_539.png"/>
</p>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The code for creating the corresponding problem object is the following: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable p(2);
  Variable M(3);
  Variables_Set params(p, M);
  Constraint_System cs;
  cs.insert(M - y &gt;= 2*M - 2*x - 4);
  cs.insert(M - y &lt;= -M + x + p);
  <a class="code" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a06368fdf7c40ae26305476c42e412172" title="Builds a trivial PIP problem.">PIP_Problem</a> pip(cs.space_dimension(), cs.begin(), cs.end(), params);
  pip.set_big_parameter_dimension(3);     <span class="comment">// M is the big parameter</span>
</pre></div> Solving the problem provides the following solution: <div class="fragment"><pre class="fragment">
  Parameter E = (C + 1) div 3
  {D - E - 1 ; -C + D + E + 1}
  </pre></div> Under the notations above, the solution is: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\{\begin{array}{l} x'=M-\left\lfloor\frac{p+1}{3}\right\rfloor-1\\ y'=M-p+\left\lfloor\frac{p+1}{3}\right\rfloor+1 \end{array}\right. \]" src="form_540.png"/>
</p>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Performing substitution again provides us with the values of the original variables: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\{\begin{array}{l} x=\left\lfloor\frac{p+1}{3}\right\rfloor+1\\ y=p-\left\lfloor\frac{p+1}{3}\right\rfloor-1 \end{array}\right. \]" src="form_541.png"/>
</p>
</dd></dl>
<dl class="user"><dt><b>Allowing variables to be arbitrarily signed</b></dt><dd>You can deal with arbitrarily signed variables by reformulating the constraints using variable substitution. Proceed the following steps:<ul>
<li>Create a big parameter (see <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a86401a66d7add563a9fec4a610ca33b3" title="Sets the dimension for the big parameter to big_dim.">PIP_Problem::set_big_parameter_dimension</a>), which we will call <img class="formulaInl" alt="$M$" src="form_532.png"/>.</li>
<li>Reformulate each of the maximization problem constraints by substituting each <img class="formulaInl" alt="$x_i$" src="form_485.png"/> variable with an expression of the form <img class="formulaInl" alt="$x'_i-M$" src="form_542.png"/>, where the <img class="formulaInl" alt="$x'_i$" src="form_222.png"/> variables are positive.</li>
<li>Solve the lexicographic minimum for the <img class="formulaInl" alt="$x'$" src="form_534.png"/> variable vector.</li>
<li>The solution expression can be read in the form:</li>
<li>In the solution expressions, the values of the <img class="formulaInl" alt="$x'$" src="form_534.png"/> variables will be expressed in the form: <img class="formulaInl" alt="$x'_i = x_i+M$" src="form_543.png"/>. To get back the value of the expression of each signed <img class="formulaInl" alt="$x_i$" src="form_485.png"/> variable, just apply the formula: <img class="formulaInl" alt="$x_i = x'_i-M$" src="form_544.png"/>. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that if the resulting expression of one of the <img class="formulaInl" alt="$x'_i$" src="form_222.png"/> variables is not in the <img class="formulaInl" alt="$x'_i = x_i+M$" src="form_543.png"/> form, this means that the sign-unrestricted problem is unbounded. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>You can choose to define only a subset of the variables to be sign-unrestricted. In that case, just apply the variable substitution method on the variables you want to be sign-unrestricted.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>Example:</b> consider you want to find the lexicographic minimum of the <img class="formulaInl" alt="$(x,y)$" src="form_537.png"/> vector, where the <img class="formulaInl" alt="$x$" src="form_21.png"/> and <img class="formulaInl" alt="$y$" src="form_388.png"/> variables are sign-unrestricted, under the constraints: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\left\{\begin{array}{l} y \geq -2x - 4\\ 2y \leq x + 2p \end{array}\right.\]" src="form_545.png"/>
</p>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>where <img class="formulaInl" alt="$p$" src="form_281.png"/> is a parameter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>After variable substitution, the constraints become: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\left\{\begin{array}{l} y' - M \geq -2x' + 2M - 4\\ 2y' - 2M \leq x' - M + 2p \end{array}\right.\]" src="form_546.png"/>
</p>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The code for creating the corresponding problem object is the following: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable p(2);
  Variable M(3);
  Variables_Set params(p, M);
  Constraint_System cs;
  cs.insert(y - M &gt;= -2*x + 2*M - 4);
  cs.insert(2*y - 2*M &lt;= x - M + 2*p);
  <a class="code" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a06368fdf7c40ae26305476c42e412172" title="Builds a trivial PIP problem.">PIP_Problem</a> pip(cs.space_dimension(), cs.begin(), cs.end(), params);
  pip.set_big_parameter_dimension(3);     <span class="comment">// M is the big parameter</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Solving the problem provides the following solution: <div class="fragment"><pre class="fragment">
  Parameter E = (2*C + 3) div 5
  {D - E - 1 ; D + 2*E - 2}
  </pre></div> Under the notations above, the solution is: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\{\begin{array}{l} x'=M-\left\lfloor\frac{2p+3}{5}\right\rfloor-1\\ y'=M+2\left\lfloor\frac{2p+3}{5}\right\rfloor-2 \end{array}\right. \]" src="form_547.png"/>
</p>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Performing substitution again provides us with the values of the original variables: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\{\begin{array}{l} x=-\left\lfloor\frac{2p+3}{5}\right\rfloor-1\\ y=2\left\lfloor\frac{2p+3}{5}\right\rfloor-2 \end{array}\right. \]" src="form_548.png"/>
</p>
</dd></dl>
<dl class="user"><dt><b>Allowing parameters to be arbitrarily signed</b></dt><dd>You can consider a parameter <img class="formulaInl" alt="$p$" src="form_281.png"/> arbitrarily signed by replacing <img class="formulaInl" alt="$p$" src="form_281.png"/> with <img class="formulaInl" alt="$p^+-p^-$" src="form_549.png"/>, where both <img class="formulaInl" alt="$p^+$" src="form_550.png"/> and <img class="formulaInl" alt="$p^-$" src="form_551.png"/> are positive parameters. To represent a set of arbitrarily signed parameters, replace each parameter <img class="formulaInl" alt="$p_i$" src="form_552.png"/> with <img class="formulaInl" alt="$p^+_i-p^-$" src="form_553.png"/>, where <img class="formulaInl" alt="$-p^-$" src="form_554.png"/> is the minimum negative value of all parameters.</dd></dl>
<dl class="user"><dt><b>Minimizing a linear cost function</b></dt><dd>Lexicographic solving can be used to find the parametric minimum of a linear cost function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose the variables are named <img class="formulaInl" alt="$x_1, x_2, \dots, x_n$" src="form_555.png"/>, and the parameters <img class="formulaInl" alt="$p_1, p_2, \dots, p_m$" src="form_556.png"/>. You can minimize a linear cost function <img class="formulaInl" alt="$f(x_2, \dots, x_n, p_1, \dots, p_m)$" src="form_557.png"/> by simply adding the constraint <img class="formulaInl" alt="$x_1 \geq f(x_2, \dots, x_n, p_1, \dots, p_m)$" src="form_558.png"/> to the constraint system. As lexicographic minimization ensures <img class="formulaInl" alt="$x_1$" src="form_249.png"/> is minimized in priority, and because <img class="formulaInl" alt="$x_1$" src="form_249.png"/> is forced by a constraint to be superior or equal to the cost function, optimal solutions of the problem necessarily ensure that the solution value of <img class="formulaInl" alt="$x_1$" src="form_249.png"/> is the optimal value of the cost function. </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a0683916154cde6bb308ccdd9c22e1ece"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::Control_Parameter_Name" ref="a0683916154cde6bb308ccdd9c22e1ece" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a0683916154cde6bb308ccdd9c22e1ece">Parma_Polyhedra_Library::PIP_Problem::Control_Parameter_Name</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possible names for <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> control parameters. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0683916154cde6bb308ccdd9c22e1eceaed708535b4103023ee1a5d24ea5ff7b3"></a><!-- doxytag: member="CUTTING_STRATEGY" ref="a0683916154cde6bb308ccdd9c22e1eceaed708535b4103023ee1a5d24ea5ff7b3" args="" -->CUTTING_STRATEGY</em>&nbsp;</td><td>
<p>Cutting strategy. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0683916154cde6bb308ccdd9c22e1ecea3581e26c004ac37575fd4449822d09c5"></a><!-- doxytag: member="PIVOT_ROW_STRATEGY" ref="a0683916154cde6bb308ccdd9c22e1ecea3581e26c004ac37575fd4449822d09c5" args="" -->PIVOT_ROW_STRATEGY</em>&nbsp;</td><td>
<p>Pivot row strategy. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fc1017d7db28f674678a1ccc49ae7b2"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::Control_Parameter_Value" ref="a8fc1017d7db28f674678a1ccc49ae7b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#a8fc1017d7db28f674678a1ccc49ae7b2">Parma_Polyhedra_Library::PIP_Problem::Control_Parameter_Value</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possible values for <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html" title="A Parametric Integer (linear) Programming problem.">PIP_Problem</a> control parameters. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8fc1017d7db28f674678a1ccc49ae7b2a2b86312f1e0350f49b28c23bd3815e9c"></a><!-- doxytag: member="CUTTING_STRATEGY_FIRST" ref="a8fc1017d7db28f674678a1ccc49ae7b2a2b86312f1e0350f49b28c23bd3815e9c" args="" -->CUTTING_STRATEGY_FIRST</em>&nbsp;</td><td>
<p>Choose the first non-integer row. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8fc1017d7db28f674678a1ccc49ae7b2a31110533316a56c835287f82cba44ab6"></a><!-- doxytag: member="CUTTING_STRATEGY_DEEPEST" ref="a8fc1017d7db28f674678a1ccc49ae7b2a31110533316a56c835287f82cba44ab6" args="" -->CUTTING_STRATEGY_DEEPEST</em>&nbsp;</td><td>
<p>Choose row which generates the deepest cut. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8fc1017d7db28f674678a1ccc49ae7b2a624c8a3766d76f8eabbb18e9270b32c1"></a><!-- doxytag: member="CUTTING_STRATEGY_ALL" ref="a8fc1017d7db28f674678a1ccc49ae7b2a624c8a3766d76f8eabbb18e9270b32c1" args="" -->CUTTING_STRATEGY_ALL</em>&nbsp;</td><td>
<p>Always generate all possible cuts. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8fc1017d7db28f674678a1ccc49ae7b2a9fbd7fce64abd6f1a6459300d77884f4"></a><!-- doxytag: member="PIVOT_ROW_STRATEGY_FIRST" ref="a8fc1017d7db28f674678a1ccc49ae7b2a9fbd7fce64abd6f1a6459300d77884f4" args="" -->PIVOT_ROW_STRATEGY_FIRST</em>&nbsp;</td><td>
<p>Choose the first row with negative parameter sign. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8fc1017d7db28f674678a1ccc49ae7b2adf2b5f608f0f0f055f58d9bedb694855"></a><!-- doxytag: member="PIVOT_ROW_STRATEGY_MAX_COLUMN" ref="a8fc1017d7db28f674678a1ccc49ae7b2adf2b5f608f0f0f055f58d9bedb694855" args="" -->PIVOT_ROW_STRATEGY_MAX_COLUMN</em>&nbsp;</td><td>
<p>Choose the row which generates the lexico-maximal pivot column. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a06368fdf7c40ae26305476c42e412172"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::PIP_Problem" ref="a06368fdf7c40ae26305476c42e412172" args="(dimension_type dim=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::PIP_Problem::PIP_Problem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>dim</em> = <code>0</code></td>
          <td>&#160;)&#160;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a trivial PIP problem. </p>
<p>A trivial PIP problem requires to compute the lexicographic minimum on a vector space under no constraints and with no parameters: due to the implicit non-negativity constraints, the origin of the vector space is an optimal solution.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&#160;</td><td>The dimension of the vector space enclosing <code>*this</code> (optional argument with default value <img class="formulaInl" alt="$0$" src="form_400.png"/>).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if <code>dim</code> exceeds <code><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abaa2167b4f8ff4184a73ebe46aef2720" title="Returns the maximum space dimension a PIP_Problem can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0b6112961e31a5f3439ce53351d3c20"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::PIP_Problem" ref="aa0b6112961e31a5f3439ce53351d3c20" args="(dimension_type dim, In first, In last, const Variables_Set &amp;p_vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::PIP_Problem::PIP_Problem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">In&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">In&#160;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>p_vars</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a PIP problem having space dimension <code>dim</code> from the sequence of constraints in the range <img class="formulaInl" alt="$[\mathrm{first}, \mathrm{last})$" src="form_687.png"/>; those dimensions whose indices occur in <code>p_vars</code> are interpreted as parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&#160;</td><td>The dimension of the vector space (variables and parameters) enclosing <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&#160;</td><td>An input iterator to the start of the sequence of constraints.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&#160;</td><td>A past-the-end input iterator to the sequence of constraints.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_vars</em>&#160;</td><td>The set of variables' indexes that are interpreted as parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if <code>dim</code> exceeds <code><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abaa2167b4f8ff4184a73ebe46aef2720" title="Returns the maximum space dimension a PIP_Problem can handle.">max_space_dimension()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the space dimension of a constraint in the sequence (resp., the parameter variables) is strictly greater than <code>dim</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a04f2cd33bf24eddaa306c392810004ef"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::clear" ref="a04f2cd33bf24eddaa306c392810004ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::PIP_Problem::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets <code>*this</code> to be equal to the trivial PIP problem. </p>
<p>The space dimension is reset to <img class="formulaInl" alt="$0$" src="form_400.png"/>. </p>

</div>
</div>
<a class="anchor" id="a6ffb7a29c69bf20f56f8ba9f16dc74b8"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::add_space_dimensions_and_embed" ref="a6ffb7a29c69bf20f56f8ba9f16dc74b8" args="(dimension_type m_vars, dimension_type m_params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::PIP_Problem::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m_params</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m_vars + m_params</code> new space dimensions and embeds the old PIP problem in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m_vars</em>&#160;</td><td>The number of space dimensions to add that are interpreted as PIP problem variables (i.e., non parameters). These are added <em>before</em> adding the <code>m_params</code> parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m_params</em>&#160;</td><td>The number of space dimensions to add that are interpreted as PIP problem parameters. These are added <em>after</em> having added the <code>m_vars</code> problem variables.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if adding <code>m_vars + m_params</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html#abaa2167b4f8ff4184a73ebe46aef2720" title="Returns the maximum space dimension a PIP_Problem can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The new space dimensions will be those having the highest indexes in the new PIP problem; they are initially unconstrained. </p>

</div>
</div>
<a class="anchor" id="aa221ca31e0aa489ae726efef9234c6d7"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::add_to_parameter_space_dimensions" ref="aa221ca31e0aa489ae726efef9234c6d7" args="(const Variables_Set &amp;p_vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::PIP_Problem::add_to_parameter_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>p_vars</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the space dimensions whose indexes which are in set <code>p_vars</code> to be parameter space dimensions. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if some index in <code>p_vars</code> does not correspond to a space dimension in <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a934053580363fb6c281a614d593231f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::add_constraint" ref="a934053580363fb6c281a614d593231f2" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::PIP_Problem::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of constraint <code>c</code> to the PIP problem. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the space dimension of <code>c</code> is strictly greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c6db3c7a9e8bcc79574dfbb087cf996"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::add_constraints" ref="a1c6db3c7a9e8bcc79574dfbb087cf996" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::PIP_Problem::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the constraints in <code>cs</code> to the PIP problem. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the space dimension of constraint system <code>cs</code> is strictly greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dd86308a6aa3b0a99e7464fa6d64534"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::is_satisfiable" ref="a6dd86308a6aa3b0a99e7464fa6d64534" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::PIP_Problem::is_satisfiable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks satisfiability of <code>*this</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if and only if the PIP problem is satisfiable. </dd></dl>

</div>
</div>
<a class="anchor" id="abac8b241f6c2a61248fa768b9157203d"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::solve" ref="abac8b241f6c2a61248fa768b9157203d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PPL__CXX__interface.html#gaa7159523299c8f193184a1bda20d6044">PIP_Problem_Status</a> Parma_Polyhedra_Library::PIP_Problem::solve </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimizes the PIP problem. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PIP_Problem_Status flag indicating the outcome of the optimization attempt (unfeasible or optimized problem). </dd></dl>

</div>
</div>
<a class="anchor" id="aa7ceb834deaff6303def1cbe95373edc"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::solution" ref="aa7ceb834deaff6303def1cbe95373edc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html">PIP_Tree</a> Parma_Polyhedra_Library::PIP_Problem::solution </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a feasible solution for <code>*this</code>, if it exists. </p>
<p>A null pointer is returned for an unfeasible PIP problem. </p>

</div>
</div>
<a class="anchor" id="a08ee3b2a32e3b7b8088a84a8beaca0f4"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::optimizing_solution" ref="a08ee3b2a32e3b7b8088a84a8beaca0f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Tree__Node.html">PIP_Tree</a> Parma_Polyhedra_Library::PIP_Problem::optimizing_solution </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an optimizing solution for <code>*this</code>, if it exists. </p>
<p>A null pointer is returned for an unfeasible PIP problem. </p>

</div>
</div>
<a class="anchor" id="a8f465629efafec94694b1397a27469b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::print_solution" ref="a8f465629efafec94694b1397a27469b4" args="(std::ostream &amp;s, unsigned indent=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::PIP_Problem::print_solution </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"> <em>indent</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints on <code>s</code> the solution computed for <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&#160;</td><td>The output stream.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indent</em>&#160;</td><td>An indentation parameter (default value 0).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::logic_error</em>&#160;</td><td>Thrown if trying to print the solution when the PIP problem still has to be solved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fefbce40046822771b243b1d2f1277e"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::get_big_parameter_dimension" ref="a1fefbce40046822771b243b1d2f1277e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> Parma_Polyhedra_Library::PIP_Problem::get_big_parameter_dimension </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the space dimension for the big parameter. </p>
<p>If a big parameter was not set, returns <code><a class="el" href="namespaceParma__Polyhedra__Library.html#a20874a85120477d5cf11da451870d497" title="Returns a value that does not designate a valid dimension.">not_a_dimension()</a></code>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a77abbac6ae63133e96588f4b57b5c861"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::operator&lt;&lt;" ref="a77abbac6ae63133e96588f4b57b5c861" args="(std::ostream &amp;s, const PIP_Problem &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">PIP_Problem</a> &amp;&#160;</td>
          <td class="paramname"> <em>p</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<a class="anchor" id="ab31e5714def3177833661bb27f9aff79"></a><!-- doxytag: member="Parma_Polyhedra_Library::PIP_Problem::swap" ref="ab31e5714def3177833661bb27f9aff79" args="(Parma_Polyhedra_Library::PIP_Problem &amp;x, Parma_Polyhedra_Library::PIP_Problem &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">Parma_Polyhedra_Library::PIP_Problem</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1PIP__Problem.html">Parma_Polyhedra_Library::PIP_Problem</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
