<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::BD_Shape&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::BD_Shape&lt; T &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::BD_Shape" -->
<p>A bounded difference shape.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1BD__Shape-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfed8bc19e046453778c9d99d84df283"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::coefficient_type_base" ref="acfed8bc19e046453778c9d99d84df283" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#acfed8bc19e046453778c9d99d84df283">coefficient_type_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The numeric base type upon which bounded differences are built. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12dc6df3a06f4c97c6bb2264bbad05ac"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::coefficient_type" ref="a12dc6df3a06f4c97c6bb2264bbad05ac" args="" -->
typedef <a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">N</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a12dc6df3a06f4c97c6bb2264bbad05ac">coefficient_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The (extended) numeric type of the inhomogeneous term of the inequalities defining a BDS. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedabe8ecd0866b972e97709e17f94681"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::ascii_dump" ref="aedabe8ecd0866b972e97709e17f94681" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aedabe8ecd0866b972e97709e17f94681">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b35fc075e1e9542d4cc5cff2e236f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::ascii_dump" ref="a82b35fc075e1e9542d4cc5cff2e236f8" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a82b35fc075e1e9542d4cc5cff2e236f8">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93c1c491c0035f6c38b9ee036184aa7e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::print" ref="a93c1c491c0035f6c38b9ee036184aa7e" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a93c1c491c0035f6c38b9ee036184aa7e">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a6088f536e9340145630576cfd6e6b9"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::ascii_load" ref="a1a6088f536e9340145630576cfd6e6b9" args="(std::istream &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a1a6088f536e9340145630576cfd6e6b9">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a82b35fc075e1e9542d4cc5cff2e236f8" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a033967c42f02b6029fc4d6153eb8072a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::total_memory_in_bytes" ref="a033967c42f02b6029fc4d6153eb8072a" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a033967c42f02b6029fc4d6153eb8072a">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25c5ef784f17646705c76a5be6c724a3"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::external_memory_in_bytes" ref="a25c5ef784f17646705c76a5be6c724a3" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a25c5ef784f17646705c76a5be6c724a3">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae0a1b4b4a344cad01c58e8e006a7ff16">hash_code</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 32-bit hash code for <code>*this</code>.  <a href="#ae0a1b4b4a344cad01c58e8e006a7ff16"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Assignment, Swap and Destructor</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aab3964a5c29992e6476852c9d246fe6f">BD_Shape</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> num_dimensions=0, <a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a> kind=UNIVERSE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a universe or empty BDS of the specified space dimension.  <a href="#aab3964a5c29992e6476852c9d246fe6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a3825b4905d72422089bf28d3c95c2964">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy constructor.  <a href="#a3825b4905d72422089bf28d3c95c2964"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#afad498a5802a7928442fd0d4b8c6183f">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a conservative, upward approximation of <code>y</code>.  <a href="#afad498a5802a7928442fd0d4b8c6183f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a128b2fafec11e096e41f78710ba2ff0a">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS from the system of constraints <code>cs</code>.  <a href="#a128b2fafec11e096e41f78710ba2ff0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a15b3e8152862a6b98ecf1c4f4a142634">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS from a system of congruences.  <a href="#a15b3e8152862a6b98ecf1c4f4a142634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#adbf2609849c95cfb7277df1edc69534f">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;gs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS from the system of generators <code>gs</code>.  <a href="#adbf2609849c95cfb7277df1edc69534f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#afaa5d6b3c1b3b83161b619c28c5f9936">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;ph, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS from the polyhedron <code>ph</code>.  <a href="#afaa5d6b3c1b3b83161b619c28c5f9936"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Interval &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aa07f93a685253eb04edab43b5ebd27b2">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;box, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS out of a box.  <a href="#aa07f93a685253eb04edab43b5ebd27b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a25a2d683973c6c6901e47c4fe90cf2b1">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;grid, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS out of a grid.  <a href="#a25a2d683973c6c6901e47c4fe90cf2b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#adf78023ac662762ffc808902b970597b">BD_Shape</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;os, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a BDS from an octagonal shape.  <a href="#adf78023ac662762ffc808902b970597b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abee6d42dd6f94979bcc7fb3d51102864"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator=" ref="abee6d42dd6f94979bcc7fb3d51102864" args="(const BD_Shape &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#abee6d42dd6f94979bcc7fb3d51102864">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bf45a32e428970068f654258dd7fb0c"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::swap" ref="a9bf45a32e428970068f654258dd7fb0c" args="(BD_Shape &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a9bf45a32e428970068f654258dd7fb0c">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code> (<code>*this</code> and <code>y</code> can be dimension-incompatible). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa78a6abbbb3c425992ca644f732e69e8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::~BD_Shape" ref="aa78a6abbbb3c425992ca644f732e69e8" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aa78a6abbbb3c425992ca644f732e69e8">~BD_Shape</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the BD_Shape</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8101d965bc32e4ab1df6aa445730769b"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::space_dimension" ref="a8101d965bc32e4ab1df6aa445730769b" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8101d965bc32e4ab1df6aa445730769b">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad09a9ccc89ace499a888b6b1a1f4ce44"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::affine_dimension" ref="ad09a9ccc89ace499a888b6b1a1f4ce44" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ad09a9ccc89ace499a888b6b1a1f4ce44">affine_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$0$" src="form_400.png"/>, if <code>*this</code> is empty; otherwise, returns the <a class="el" href="main.html#Affine_Independence_and_Affine_Dimension">affine dimension</a> of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e645f35cbeedf3341428988157f71ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::constraints" ref="a1e645f35cbeedf3341428988157f71ab" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a1e645f35cbeedf3341428988157f71ab">constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a system of constraints defining <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24fbe68af11e373092f23f59b6cfd3e1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimized_constraints" ref="a24fbe68af11e373092f23f59b6cfd3e1" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a24fbe68af11e373092f23f59b6cfd3e1">minimized_constraints</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimized system of constraints defining <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7f89b09f6755cdcd97daa3a92522b00"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::congruences" ref="ac7f89b09f6755cdcd97daa3a92522b00" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ac7f89b09f6755cdcd97daa3a92522b00">congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a system of (equality) congruences satisfied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f0bdfca2a6993bfa08358319d589ab6"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimized_congruences" ref="a8f0bdfca2a6993bfa08358319d589ab6" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8f0bdfca2a6993bfa08358319d589ab6">minimized_congruences</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a minimal system of (equality) congruences satisfied by <code>*this</code> with the same affine dimension as <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a79a586ca093d218e5603380ac0475717">bounds_from_above</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>.  <a href="#a79a586ca093d218e5603380ac0475717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a641b55dd6c26bce06bd8041b38aec873">bounds_from_below</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>.  <a href="#a641b55dd6c26bce06bd8041b38aec873"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aa7b3a5c12ea008b78eed88a621c1fab1">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed.  <a href="#aa7b3a5c12ea008b78eed88a621c1fab1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae61fdcc22d1e0fe43b94194f2eadaa1a">maximize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;sup_d, bool &amp;maximum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed.  <a href="#ae61fdcc22d1e0fe43b94194f2eadaa1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a33daeddebffc6eb847edd92c3ba045dc">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed.  <a href="#a33daeddebffc6eb847edd92c3ba045dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a1d00782cbab77286295552af7dba7ed8">minimize</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;inf_d, bool &amp;minimum, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed.  <a href="#a1d00782cbab77286295552af7dba7ed8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aca71bae643870b4a7aaaabbab838c330">frequency</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;freq_d, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_n, <a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;val_d) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>.  <a href="#aca71bae643870b4a7aaaabbab838c330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a6a3dd351c33d66250d2b4ac639768f07">contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>.  <a href="#a6a3dd351c33d66250d2b4ac639768f07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8a87935278cb7b1290301e96cb82fcb1">strictly_contains</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>.  <a href="#a8a87935278cb7b1290301e96cb82fcb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a5e972fbb672e9b2faec34b949c9a2918">is_disjoint_from</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint.  <a href="#a5e972fbb672e9b2faec34b949c9a2918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a75188bcee0bfc88a4c8571acc04a1826">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the constraint <code>c</code>.  <a href="#a75188bcee0bfc88a4c8571acc04a1826"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a4aef1a4f6e9bed5d473e98320401e0e5">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>.  <a href="#a4aef1a4f6e9bed5d473e98320401e0e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a16f61fdba7e14a67990a84e93be00efb">relation_with</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations holding between <code>*this</code> and the generator <code>g</code>.  <a href="#a16f61fdba7e14a67990a84e93be00efb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa538c9c00b2f69301365d916bb49e8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_empty" ref="acaa538c9c00b2f69301365d916bb49e8" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#acaa538c9c00b2f69301365d916bb49e8">is_empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an empty BDS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a620d5cdb01b8b20848ca01f4e4c05b4f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_universe" ref="a620d5cdb01b8b20848ca01f4e4c05b4f" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a620d5cdb01b8b20848ca01f4e4c05b4f">is_universe</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a universe BDS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a242d9bf0b5b215d4aa771e9f8595baea"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_discrete" ref="a242d9bf0b5b215d4aa771e9f8595baea" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a242d9bf0b5b215d4aa771e9f8595baea">is_discrete</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is discrete. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f33edf5fdf4c6f606136b882be9f1d"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_topologically_closed" ref="a54f33edf5fdf4c6f606136b882be9f1d" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a54f33edf5fdf4c6f606136b882be9f1d">is_topologically_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a topologically closed subset of the vector space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c73e2c464d5e93dc55862d00d5478f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_bounded" ref="a8c73e2c464d5e93dc55862d00d5478f8" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8c73e2c464d5e93dc55862d00d5478f8">is_bounded</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a bounded BDS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a396bd79b5d57d54685d9c1b9d970c00e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::contains_integer_point" ref="a396bd79b5d57d54685d9c1b9d970c00e" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a396bd79b5d57d54685d9c1b9d970c00e">contains_integer_point</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> contains at least one integer point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ad369744c43a49ebac904bc3e17de0478">constrains</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>.  <a href="#ad369744c43a49ebac904bc3e17de0478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29212d49685544d8a3c71993bd30f467"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::OK" ref="a29212d49685544d8a3c71993bd30f467" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a29212d49685544d8a3c71993bd30f467">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> satisfies all its invariants. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Space-Dimension Preserving Member Functions that May Modify the BD_Shape</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a20814dec69b3a6602b70a9ad50db9b2a">add_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of constraint <code>c</code> to the system of bounded differences defining <code>*this</code>.  <a href="#a20814dec69b3a6602b70a9ad50db9b2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#acf4dc2de16f4a54ca03daa6ac1d31ce2">add_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of congruence <code>cg</code> to the system of congruences of <code>*this</code>.  <a href="#acf4dc2de16f4a54ca03daa6ac1d31ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a28b268e37d25a0cfa2b5bf39e85c758d">add_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of bounded differences defining <code>*this</code>.  <a href="#a28b268e37d25a0cfa2b5bf39e85c758d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a535090b407c713681228d6ab2b835e36">add_recycled_constraints</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>.  <a href="#a535090b407c713681228d6ab2b835e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a0cc08ca5d72d5cf465eb7812ffbb156a">add_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#a0cc08ca5d72d5cf465eb7812ffbb156a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aa85819690f928a46e3f437bfe629e976">add_recycled_congruences</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>.  <a href="#aa85819690f928a46e3f437bfe629e976"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8ede75fbd470fa30f11d4c02672883f5">refine_with_constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a copy of constraint <code>c</code> to refine the system of bounded differences defining <code>*this</code>.  <a href="#a8ede75fbd470fa30f11d4c02672883f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ace010a880cb8574335f1be294907de89">refine_with_congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a copy of congruence <code>cg</code> to refine the system of bounded differences of <code>*this</code>.  <a href="#ace010a880cb8574335f1be294907de89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8e13e7d3536de2745bc9e58a25b75b77">refine_with_constraints</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a copy of the constraints in <code>cs</code> to refine the system of bounded differences defining <code>*this</code>.  <a href="#a8e13e7d3536de2745bc9e58a25b75b77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a35f19d0e7190c5a18aebc9ced95d554e">refine_with_congruences</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;cgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a copy of the congruences in <code>cgs</code> to refine the system of bounded differences defining <code>*this</code>.  <a href="#a35f19d0e7190c5a18aebc9ced95d554e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a668cbd7cea86f47c4e2b303468083712">unconstrain</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>.  <a href="#a668cbd7cea86f47c4e2b303468083712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ad2e535d5b20d25d36b4744da392edf02">unconstrain</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>.  <a href="#ad2e535d5b20d25d36b4744da392edf02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a86dd59c40a3c9867c2979ff24ba342c2">intersection_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>.  <a href="#a86dd59c40a3c9867c2979ff24ba342c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a0442c5079b3de8dcac61c224ee7a2e6f">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest BDS containing the union of <code>*this</code> and <code>y</code>.  <a href="#a0442c5079b3de8dcac61c224ee7a2e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a4b7615a8ec5120dc083f368ecfe2d1da">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned.  <a href="#a4b7615a8ec5120dc083f368ecfe2d1da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a6ef0e7043830c5e6b9ffd67697d22c04">integer_upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <em>integer</em> upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned; otherwise <code>false</code> is returned.  <a href="#a6ef0e7043830c5e6b9ffd67697d22c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a894e92407922be006a76577cf47b8589">difference_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest BD shape containing the set difference of <code>*this</code> and <code>y</code>.  <a href="#a894e92407922be006a76577cf47b8589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a84a9c57aa31433a277d9be6b0077065a">simplify_using_context_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty.  <a href="#a84a9c57aa31433a277d9be6b0077065a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a4e04c3a6c835332c31dfbb928b31144e">affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#a4e04c3a6c835332c31dfbb928b31144e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a07cc48290e435dfb739fb565ff1aa3fa">affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>.  <a href="#a07cc48290e435dfb739fb565ff1aa3fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae0ba85e8cab7e4e95ec001bde5bdd99d">generalized_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#ae0ba85e8cab7e4e95ec001bde5bdd99d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a0acf1147e3f81830606dec4cc8faddd4">generalized_affine_image</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a0acf1147e3f81830606dec4cc8faddd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a988ff507806fa8126649f463ef6a1f31">generalized_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a988ff507806fa8126649f463ef6a1f31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a79acafbe4f67eb7e2710287bcd60db96">generalized_affine_preimage</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lhs, <a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> relsym, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>.  <a href="#a79acafbe4f67eb7e2710287bcd60db96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#acda762f8c081fed2862260211618fce0">bounded_affine_image</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#acda762f8c081fed2862260211618fce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a178a6a88143f44b43939d36024af6162">bounded_affine_preimage</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;lb_expr, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>.  <a href="#a178a6a88143f44b43939d36024af6162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a5a66e6f883c7310ddbc312f78bb0970f">time_elapse_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>.  <a href="#a5a66e6f883c7310ddbc312f78bb0970f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a5616d386d85dc734e155a67f12e7752f">wrap_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a> w, <a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a> r, <a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a> o, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space.  <a href="#a5616d386d85dc734e155a67f12e7752f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a3e0339ccaf8da39b9fd21ff8777e99e4">drop_some_non_integer_points</a> (<a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates.  <a href="#a3e0339ccaf8da39b9fd21ff8777e99e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a2204d6d24f9c68fdb6a72062afe9a209">drop_some_non_integer_points</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a> complexity=ANY_COMPLEXITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>.  <a href="#a2204d6d24f9c68fdb6a72062afe9a209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad80989353ea3738abdb6b605d27cc8fa"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::topological_closure_assign" ref="ad80989353ea3738abdb6b605d27cc8fa" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ad80989353ea3738abdb6b605d27cc8fa">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a9507085c5b0efd13c80f08a22b0f5529">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#a9507085c5b0efd13c80f08a22b0f5529"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a24d2b69146ab1b2216e437468a818cea">CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, Iterator first, Iterator last, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>.  <a href="#a24d2b69146ab1b2216e437468a818cea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a1a02b17cbccf348192f3e7f776b3b3fd">BHMZ05_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> of <code>*this</code> and <code>y</code>.  <a href="#a1a02b17cbccf348192f3e7f776b3b3fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#aeda87d46bc3b54b420a475934e0e1cb6">limited_BHMZ05_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#aeda87d46bc3b54b420a475934e0e1cb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#adf3cfc56df68bc8063e6e9eb3d0ad3f1">CC76_narrowing_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of restoring in <code>y</code> the constraints of <code>*this</code> that were lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications.  <a href="#adf3cfc56df68bc8063e6e9eb3d0ad3f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a2af430cd70ac416ca0907312b65812e6">limited_CC76_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#a2af430cd70ac416ca0907312b65812e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a5d71f71f50ba04fe5f810acf0cf1e294">H79_widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79-widening</a> between <code>*this</code> and <code>y</code>.  <a href="#a5d71f71f50ba04fe5f810acf0cf1e294"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00b832cc0784b7b30f4d4a2f738a3032"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::widening_assign" ref="a00b832cc0784b7b30f4d4a2f738a3032" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a00b832cc0784b7b30f4d4a2f738a3032">widening_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as H79_widening_assign(y, tp). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#accbd8986577794cea90edef63e859ab1">limited_H79_extrapolation_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;cs, unsigned *tp=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improves the result of the <a class="el" href="main.html#H79_widening">H79-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>.  <a href="#accbd8986577794cea90edef63e859ab1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Dimension of the Vector Space</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a9c0703b2311336754e28a7f739b7e685">add_space_dimensions_and_embed</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m</code> new dimensions and embeds the old BDS into the new space.  <a href="#a9c0703b2311336754e28a7f739b7e685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#afa8a10ff4b09f8a87e3c558a39f5888e">add_space_dimensions_and_project</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>m</code> new dimensions to the BDS and does not embed it in the new vector space.  <a href="#afa8a10ff4b09f8a87e3c558a39f5888e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ab0a670aeef72d808d620bbc33a5e8cd7">concatenate_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order.  <a href="#ab0a670aeef72d808d620bbc33a5e8cd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a63e8c0f76da4e9b3520aa338d152d253">remove_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the specified dimensions.  <a href="#a63e8c0f76da4e9b3520aa338d152d253"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ab054f67fb31ea4e860dd7c24c0b56676">remove_higher_space_dimensions</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> new_dimension)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>.  <a href="#ab054f67fb31ea4e860dd7c24c0b56676"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Partial_Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ac65231748a66ac5c074502cc8e652e10">map_space_dimensions</a> (const Partial_Function &amp;pfunc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>.  <a href="#ac65231748a66ac5c074502cc8e652e10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a0badc932380dcb7f72ea50ca922d9d4b">expand_space_dimension</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> var, <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>.  <a href="#a0badc932380dcb7f72ea50ca922d9d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a1f8426558552c358c30b6263c758fe51">fold_space_dimensions</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;vars, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the space dimensions in <code>vars</code> into <code>dest</code>.  <a href="#a1f8426558552c358c30b6263c758fe51"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae68d61763922cee018cbba3834b2085c"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::max_space_dimension" ref="ae68d61763922cee018cbba3834b2085c" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae68d61763922cee018cbba3834b2085c">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension that a BDS can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae748c3f5082b158453fbb3ccf57c8f70"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::can_recycle_constraint_systems" ref="ae748c3f5082b158453fbb3ccf57c8f70" args="()" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae748c3f5082b158453fbb3ccf57c8f70">can_recycle_constraint_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> indicating that this domain cannot recycle constraints. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c89ddcd2fc4311af0e358477630d7d9"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::can_recycle_congruence_systems" ref="a8c89ddcd2fc4311af0e358477630d7d9" args="()" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8c89ddcd2fc4311af0e358477630d7d9">can_recycle_congruence_systems</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> indicating that this domain cannot recycle congruences. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ac91aac77237c2405df039c4fcfa08ab0">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same BDS.  <a href="#ac91aac77237c2405df039c4fcfa08ab0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a5049b85730d6720536be440753b11ed8">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;bds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a5049b85730d6720536be440753b11ed8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#acdc537f0aa5117fe3749d3c50b7dc4fd">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> aren't the same BDS.  <a href="#acdc537f0aa5117fe3749d3c50b7dc4fd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#af4b0f891a6911d7784216f537fa3e473">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#af4b0f891a6911d7784216f537fa3e473"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a221657648a7e456dba61589e37765cd4">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#a221657648a7e456dba61589e37765cd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a47a21a1c8a88c306877d15d4dbc697b4">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#a47a21a1c8a88c306877d15d4dbc697b4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae5c66812ab981ee2d1ab96ce218a7782">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#ae5c66812ab981ee2d1ab96ce218a7782"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ad0a9267e420144cacfb867076d00a803">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#ad0a9267e420144cacfb867076d00a803"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#a8d6c186583503c4394603550b50edf59">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#a8d6c186583503c4394603550b50edf59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#af6351727d099ad178db8b8e742507f4c">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#af6351727d099ad178db8b8e742507f4c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br/>
 class Parma_Polyhedra_Library::BD_Shape&lt; T &gt;</h3>

<p>A bounded difference shape. </p>
<p>The class template BD_Shape&lt;T&gt; allows for the efficient representation of a restricted kind of <em>topologically closed</em> convex polyhedra called <em>bounded difference shapes</em> (BDSs, for short). The name comes from the fact that the closed affine half-spaces that characterize the polyhedron can be expressed by constraints of the form <img class="formulaInl" alt="$\pm x_i \leq k$" src="form_572.png"/> or <img class="formulaInl" alt="$x_i - x_j \leq k$" src="form_573.png"/>, where the inhomogeneous term <img class="formulaInl" alt="$k$" src="form_296.png"/> is a rational number.</p>
<p>Based on the class template type parameter <code>T</code>, a family of extended numbers is built and used to approximate the inhomogeneous term of bounded differences. These extended numbers provide a representation for the value <img class="formulaInl" alt="$+\infty$" src="form_574.png"/>, as well as <em>rounding-aware</em> implementations for several arithmetic functions. The value of the type parameter <code>T</code> may be one of the following:</p>
<ul>
<li>a bounded precision integer type (e.g., <code>int32_t</code> or <code>int64_t</code>);</li>
<li>a bounded precision floating point type (e.g., <code>float</code> or <code>double</code>);</li>
<li>an unbounded integer or rational type, as provided by GMP (i.e., <code>mpz_class</code> or <code>mpq_class</code>).</li>
</ul>
<p>The user interface for BDSs is meant to be as similar as possible to the one developed for the polyhedron class <a class="el" href="classParma__Polyhedra__Library_1_1C__Polyhedron.html" title="A closed convex polyhedron.">C_Polyhedron</a>.</p>
<p>The domain of BD shapes <em>optimally supports</em>:</p>
<ul>
<li>tautological and inconsistent constraints and congruences;</li>
<li>bounded difference constraints;</li>
<li>non-proper congruences (i.e., equalities) that are expressible as bounded-difference constraints.</li>
</ul>
<p>Depending on the method, using a constraint or congruence that is not optimally supported by the domain will either raise an exception or result in a (possibly non-optimal) upward approximation.</p>
<p>A constraint is a bounded difference if it has the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_i x_i - a_j x_j \relsym b \]" src="form_575.png"/>
</p>
<p> where <img class="formulaInl" alt="$\mathord{\relsym} \in \{ \leq, =, \geq \}$" src="form_576.png"/> and <img class="formulaInl" alt="$a_i$" src="form_234.png"/>, <img class="formulaInl" alt="$a_j$" src="form_577.png"/>, <img class="formulaInl" alt="$b$" src="form_235.png"/> are integer coefficients such that <img class="formulaInl" alt="$a_i = 0$" src="form_578.png"/>, or <img class="formulaInl" alt="$a_j = 0$" src="form_579.png"/>, or <img class="formulaInl" alt="$a_i = a_j$" src="form_580.png"/>. The user is warned that the above bounded difference <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object will be mapped into a <em>correct</em> and <em>optimal</em> approximation that, depending on the expressive power of the chosen template argument <code>T</code>, may loose some precision. Also note that strict constraints are not bounded differences.</p>
<p>For instance, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x - 3y \leq 1$" src="form_581.png"/> will be approximated by:</p>
<ul>
<li><img class="formulaInl" alt="$x - y \leq 1$" src="form_582.png"/>, if <code>T</code> is a (bounded or unbounded) integer type;</li>
<li><img class="formulaInl" alt="$x - y \leq \frac{1}{3}$" src="form_583.png"/>, if <code>T</code> is the unbounded rational type <code>mpq_class</code>;</li>
<li><img class="formulaInl" alt="$x - y \leq k$" src="form_584.png"/>, where <img class="formulaInl" alt="$k > \frac{1}{3}$" src="form_585.png"/>, if <code>T</code> is a floating point type (having no exact representation for <img class="formulaInl" alt="$\frac{1}{3}$" src="form_586.png"/>).</li>
</ul>
<p>On the other hand, depending from the context, a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> object encoding <img class="formulaInl" alt="$3x - y \leq 1$" src="form_587.png"/> will be either upward approximated (e.g., by safely ignoring it) or it will cause an exception.</p>
<p>In the following examples it is assumed that the type argument <code>T</code> is one of the possible instances listed above and that variables <code>x</code>, <code>y</code> and <code>z</code> are defined (where they are used) as follows: </p>
<div class="fragment"><pre class="fragment">    Variable x(0);
    Variable y(1);
    Variable z(2);
</pre></div><dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds a BDS corresponding to a cube in <img class="formulaInl" alt="$\Rset^3$" src="form_588.png"/>, given as a system of constraints: <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 1);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 1);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 1);
    BD_Shape&lt;T&gt; bd(cs);
</pre></div> Since only those constraints having the syntactic form of a <em>bounded difference</em> are optimally supported, the following code will throw an exception (caused by constraints 7, 8 and 9): <div class="fragment"><pre class="fragment">    Constraint_System cs;
    cs.insert(x &gt;= 0);
    cs.insert(x &lt;= 1);
    cs.insert(y &gt;= 0);
    cs.insert(y &lt;= 1);
    cs.insert(z &gt;= 0);
    cs.insert(z &lt;= 1);
    cs.insert(x + y &lt;= 0);      <span class="comment">// 7</span>
    cs.insert(x - z + x &gt;= 0);  <span class="comment">// 8</span>
    cs.insert(3*z - y &lt;= 1);    <span class="comment">// 9</span>
    BD_Shape&lt;T&gt; bd(cs);
</pre></div> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aab3964a5c29992e6476852c9d246fe6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="aab3964a5c29992e6476852c9d246fe6f" args="(dimension_type num_dimensions=0, Degenerate_Element kind=UNIVERSE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>num_dimensions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga616fcdc7600a3a11a8a9152e75730899">Degenerate_Element</a>&#160;</td>
          <td class="paramname"> <em>kind</em> = <code>UNIVERSE</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a universe or empty BDS of the specified space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_dimensions</em>&#160;</td><td>The number of dimensions of the vector space enclosing the BDS;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&#160;</td><td>Specifies whether the universe or the empty BDS has to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3825b4905d72422089bf28d3c95c2964"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="a3825b4905d72422089bf28d3c95c2964" args="(const BD_Shape &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordinary copy constructor. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="afad498a5802a7928442fd0d4b8c6183f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="afad498a5802a7928442fd0d4b8c6183f" args="(const BD_Shape&lt; U &gt; &amp;y, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a conservative, upward approximation of <code>y</code>. </p>
<p>The complexity argument is ignored. </p>

</div>
</div>
<a class="anchor" id="a128b2fafec11e096e41f78710ba2ff0a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="a128b2fafec11e096e41f78710ba2ff0a" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS from the system of constraints <code>cs</code>. </p>
<p>The BDS inherits the space dimension of <code>cs</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>A system of BD constraints.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15b3e8152862a6b98ecf1c4f4a142634"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="a15b3e8152862a6b98ecf1c4f4a142634" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS from a system of congruences. </p>
<p>The BDS inherits the space dimension of <code>cgs</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>A system of congruences.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>cgs</code> contains congruences which are not optimally supported by the BD shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbf2609849c95cfb7277df1edc69534f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="adbf2609849c95cfb7277df1edc69534f" args="(const Generator_System &amp;gs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator__System.html">Generator_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>gs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS from the system of generators <code>gs</code>. </p>
<p>Builds the smallest BDS containing the polyhedron defined by <code>gs</code>. The BDS inherits the space dimension of <code>gs</code>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the system of generators is not empty but has no points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaa5d6b3c1b3b83161b619c28c5f9936"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="afaa5d6b3c1b3b83161b619c28c5f9936" args="(const Polyhedron &amp;ph, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Polyhedron.html">Polyhedron</a> &amp;&#160;</td>
          <td class="paramname"> <em>ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS from the polyhedron <code>ph</code>. </p>
<p>Builds a BDS containing <code>ph</code> using algorithms whose complexity does not exceed the one specified by <code>complexity</code>. If <code>complexity</code> is <code>ANY_COMPLEXITY</code>, then the BDS built is the smallest one containing <code>ph</code>. </p>

</div>
</div>
<a class="anchor" id="aa07f93a685253eb04edab43b5ebd27b2"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="aa07f93a685253eb04edab43b5ebd27b2" args="(const Box&lt; Interval &gt; &amp;box, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Interval &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Box.html">Box</a>&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS out of a box. </p>
<p>The BDS inherits the space dimension of the box. The built BDS is the most precise BDS that includes the box.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&#160;</td><td>The box representing the BDS to be built.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>box</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25a2d683973c6c6901e47c4fe90cf2b1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="a25a2d683973c6c6901e47c4fe90cf2b1" args="(const Grid &amp;grid, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS out of a grid. </p>
<p>The BDS inherits the space dimension of the grid. The built BDS is the most precise BDS that includes the grid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grid</em>&#160;</td><td>The grid used to build the BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>grid</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf78023ac662762ffc808902b970597b"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BD_Shape" ref="adf78023ac662762ffc808902b970597b" args="(const Octagonal_Shape&lt; U &gt; &amp;os, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Octagonal__Shape.html">Octagonal_Shape</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a BDS from an octagonal shape. </p>
<p>The BDS inherits the space dimension of the octagonal shape. The built BDS is the most precise BDS that includes the octagonal shape.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&#160;</td><td>The octagonal shape used to build the BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>This argument is ignored as the algorithm used has polynomial complexity.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the space dimension of <code>os</code> exceeds the maximum allowed space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a79a586ca093d218e5603380ac0475717"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounds_from_above" ref="a79a586ca093d218e5603380ac0475717" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounds_from_above </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from above in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a641b55dd6c26bce06bd8041b38aec873"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounds_from_below" ref="a641b55dd6c26bce06bd8041b38aec873" args="(const Linear_Expression &amp;expr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounds_from_below </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>expr</code> is bounded from below in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7b3a5c12ea008b78eed88a621c1fab1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::maximize" ref="aa7b3a5c12ea008b78eed88a621c1fab1" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>maximum</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&#160;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&#160;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&#160;</td><td><code>true</code> if and only if the supremum is also the maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code> and <code>maximum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="ae61fdcc22d1e0fe43b94194f2eadaa1a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::maximize" ref="ae61fdcc22d1e0fe43b94194f2eadaa1a" args="(const Linear_Expression &amp;expr, Coefficient &amp;sup_n, Coefficient &amp;sup_d, bool &amp;maximum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>sup_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from above in <code>*this</code>, in which case the supremum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be maximized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_n</em>&#160;</td><td>The numerator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sup_d</em>&#160;</td><td>The denominator of the supremum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maximum</em>&#160;</td><td><code>true</code> if and only if the supremum is also the maximum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&#160;</td><td>When maximization succeeds, will be assigned the point or closure point where <code>expr</code> reaches its supremum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from above, <code>false</code> is returned and <code>sup_n</code>, <code>sup_d</code>, <code>maximum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a33daeddebffc6eb847edd92c3ba045dc"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimize" ref="a33daeddebffc6eb847edd92c3ba045dc" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>minimum</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value is computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&#160;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&#160;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&#160;</td><td><code>true</code> if and only if the infimum is also the minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code> and <code>minimum</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a1d00782cbab77286295552af7dba7ed8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::minimize" ref="a1d00782cbab77286295552af7dba7ed8" args="(const Linear_Expression &amp;expr, Coefficient &amp;inf_n, Coefficient &amp;inf_d, bool &amp;minimum, Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>inf_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is not empty and <code>expr</code> is bounded from below in <code>*this</code>, in which case the infimum value and a point where <code>expr</code> reaches it are computed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression to be minimized subject to <code>*this</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_n</em>&#160;</td><td>The numerator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inf_d</em>&#160;</td><td>The denominator of the infimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimum</em>&#160;</td><td><code>true</code> if and only if the infimum is also the minimum value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&#160;</td><td>When minimization succeeds, will be assigned a point or closure point where <code>expr</code> reaches its infimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> is empty or <code>expr</code> is not bounded from below, <code>false</code> is returned and <code>inf_n</code>, <code>inf_d</code>, <code>minimum</code> and <code>g</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="aca71bae643870b4a7aaaabbab838c330"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::frequency" ref="aca71bae643870b4a7aaaabbab838c330" args="(const Linear_Expression &amp;expr, Coefficient &amp;freq_n, Coefficient &amp;freq_d, Coefficient &amp;val_n, Coefficient &amp;val_d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>freq_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>freq_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>val_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899">Coefficient</a> &amp;&#160;</td>
          <td class="paramname"> <em>val_d</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if there exist a unique value <code>val</code> such that <code>*this</code> saturates the equality <code>expr = val</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The linear expression for which the frequency is needed;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_n</em>&#160;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$0$" src="form_400.png"/>; Present for interface compatibility with class <a class="el" href="classParma__Polyhedra__Library_1_1Grid.html" title="A grid.">Grid</a>, where the <a class="el" href="main.html#Grid_Frequency">frequency</a> can have a non-zero value;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freq_d</em>&#160;</td><td>If <code>true</code> is returned, the value is set to <img class="formulaInl" alt="$1$" src="form_488.png"/>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_n</em>&#160;</td><td>The numerator of <code>val</code>;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val_d</em>&#160;</td><td>The denominator of <code>val</code>;</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>expr</code> and <code>*this</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>false</code> is returned, then <code>freq_n</code>, <code>freq_d</code>, <code>val_n</code> and <code>val_d</code> are left untouched. </p>

</div>
</div>
<a class="anchor" id="a6a3dd351c33d66250d2b4ac639768f07"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::contains" ref="a6a3dd351c33d66250d2b4ac639768f07" args="(const BD_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a87935278cb7b1290301e96cb82fcb1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::strictly_contains" ref="a8a87935278cb7b1290301e96cb82fcb1" args="(const BD_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> strictly contains <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e972fbb672e9b2faec34b949c9a2918"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::is_disjoint_from" ref="a5e972fbb672e9b2faec34b949c9a2918" args="(const BD_Shape &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::is_disjoint_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are disjoint. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>x</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75188bcee0bfc88a4c8571acc04a1826"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::relation_with" ref="a75188bcee0bfc88a4c8571acc04a1826" args="(const Constraint &amp;c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aef1a4f6e9bed5d473e98320401e0e5"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::relation_with" ref="a4aef1a4f6e9bed5d473e98320401e0e5" args="(const Congruence &amp;cg) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Con__Relation.html">Poly_Con_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the congruence <code>cg</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16f61fdba7e14a67990a84e93be00efb"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::relation_with" ref="a16f61fdba7e14a67990a84e93be00efb" args="(const Generator &amp;g) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Poly__Gen__Relation.html">Poly_Gen_Relation</a> <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::relation_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the relations holding between <code>*this</code> and the generator <code>g</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and generator <code>g</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad369744c43a49ebac904bc3e17de0478"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::constrains" ref="ad369744c43a49ebac904bc3e17de0478" args="(Variable var) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::constrains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>var</code> is constrained in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20814dec69b3a6602b70a9ad50db9b2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_constraint" ref="a20814dec69b3a6602b70a9ad50db9b2a" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of constraint <code>c</code> to the system of bounded differences defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&#160;</td><td>The constraint to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible, or <code>c</code> is not optimally supported by the BD shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf4dc2de16f4a54ca03daa6ac1d31ce2"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_congruence" ref="acf4dc2de16f4a54ca03daa6ac1d31ce2" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of congruence <code>cg</code> to the system of congruences of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&#160;</td><td>The congruence to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible, or <code>cg</code> is not optimally supported by the BD shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28b268e37d25a0cfa2b5bf39e85c758d"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_constraints" ref="a28b268e37d25a0cfa2b5bf39e85c758d" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of bounded differences defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraints that will be added.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a535090b407c713681228d6ab2b835e36"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_recycled_constraints" ref="a535090b407c713681228d6ab2b835e36" args="(Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_recycled_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the constraints in <code>cs</code> to the system of constraints of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraint system to be added to <code>*this</code>. The constraints in <code>cs</code> may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible, or <code>cs</code> contains a constraint which is not optimally supported by the BD shape domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cc08ca5d72d5cf465eb7812ffbb156a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_congruences" ref="a0cc08ca5d72d5cf465eb7812ffbb156a" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>Contains the congruences that will be added to the system of constraints of <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the BD shape domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa85819690f928a46e3f437bfe629e976"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_recycled_congruences" ref="aa85819690f928a46e3f437bfe629e976" args="(Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_recycled_congruences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> constraints equivalent to the congruences in <code>cgs</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>Contains the congruences that will be added to the system of constraints of <code>*this</code>. Its elements may be recycled.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible, or <code>cgs</code> contains a congruence which is not optimally supported by the BD shape domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The only assumption that can be made on <code>cgs</code> upon successful or exceptional return is that it can be safely destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ede75fbd470fa30f11d4c02672883f5"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_constraint" ref="a8ede75fbd470fa30f11d4c02672883f5" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of constraint <code>c</code> to refine the system of bounded differences defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&#160;</td><td>The constraint. If it is not a bounded difference, it will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and constraint <code>c</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace010a880cb8574335f1be294907de89"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_congruence" ref="ace010a880cb8574335f1be294907de89" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of congruence <code>cg</code> to refine the system of bounded differences of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cg</em>&#160;</td><td>The congruence. If it is not a bounded difference equality, it will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and congruence <code>cg</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e13e7d3536de2745bc9e58a25b75b77"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_constraints" ref="a8e13e7d3536de2745bc9e58a25b75b77" args="(const Constraint_System &amp;cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the constraints in <code>cs</code> to refine the system of bounded differences defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The constraint system to be used. Constraints that are not bounded differences are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35f19d0e7190c5a18aebc9ced95d554e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::refine_with_congruences" ref="a35f19d0e7190c5a18aebc9ced95d554e" args="(const Congruence_System &amp;cgs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::refine_with_congruences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence__System.html">Congruence_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cgs</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses a copy of the congruences in <code>cgs</code> to refine the system of bounded differences defining <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cgs</em>&#160;</td><td>The congruence system to be used. Congruences that are not bounded difference equalities are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>cgs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a668cbd7cea86f47c4e2b303468083712"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::unconstrain" ref="a668cbd7cea86f47c4e2b303468083712" args="(Variable var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to space dimension <code>var</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2e535d5b20d25d36b4744da392edf02"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::unconstrain" ref="ad2e535d5b20d25d36b4744da392edf02" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::unconstrain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <a class="el" href="main.html#Cylindrification">cylindrification</a> of <code>*this</code> with respect to the set of space dimensions <code>vars</code>, assigning the result to <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of space dimension that will be unconstrained.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86dd59c40a3c9867c2979ff24ba342c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::intersection_assign" ref="a86dd59c40a3c9867c2979ff24ba342c2" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the intersection of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0442c5079b3de8dcac61c224ee7a2e6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::upper_bound_assign" ref="a0442c5079b3de8dcac61c224ee7a2e6f" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::upper_bound_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the smallest BDS containing the union of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b7615a8ec5120dc083f368ecfe2d1da"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::upper_bound_assign_if_exact" ref="a4b7615a8ec5120dc083f368ecfe2d1da" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned, otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ef0e7043830c5e6b9ffd67697d22c04"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::integer_upper_bound_assign_if_exact" ref="a6ef0e7043830c5e6b9ffd67697d22c04" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::integer_upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the <em>integer</em> upper bound of <code>*this</code> and <code>y</code> is exact, it is assigned to <code>*this</code> and <code>true</code> is returned; otherwise <code>false</code> is returned. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The integer upper bound of two rational BDS is the smallest rational BDS containing all the integral points of the two arguments. This method requires that the coefficient type parameter <code>T</code> is an integral type. </dd></dl>

</div>
</div>
<a class="anchor" id="a894e92407922be006a76577cf47b8589"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::difference_assign" ref="a894e92407922be006a76577cf47b8589" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::difference_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the smallest BD shape containing the set difference of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84a9c57aa31433a277d9be6b0077065a"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::simplify_using_context_assign" ref="a84a9c57aa31433a277d9be6b0077065a" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. If <code>false</code> is returned, then the intersection is empty. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are topology-incompatible or dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e04c3a6c835332c31dfbb928b31144e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::affine_image" ref="a4e04c3a6c835332c31dfbb928b31144e" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine image</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable to which the affine expression is assigned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07cc48290e435dfb739fb565ff1aa3fa"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::affine_preimage" ref="a07cc48290e435dfb739fb565ff1aa3fa" args="(Variable var, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Single_Update_Affine_Functions">affine preimage</a> of <code>*this</code> under the function mapping variable <code>var</code> into the affine expression specified by <code>expr</code> and <code>denominator</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable to which the affine expression is substituted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0ba85e8cab7e4e95ec001bde5bdd99d"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_image" ref="ae0ba85e8cab7e4e95ec001bde5bdd99d" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0acf1147e3f81830606dec4cc8faddd4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_image" ref="a0acf1147e3f81830606dec4cc8faddd4" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&#160;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&#160;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a988ff507806fa8126649f463ef6a1f31"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_preimage" ref="a988ff507806fa8126649f463ef6a1f31" args="(Variable var, Relation_Symbol relsym, const Linear_Expression &amp;expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{var}' \relsym \frac{\mathrm{expr}}{\mathrm{denominator}}$" src="form_703.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The left hand side variable of the generalized affine transfer function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&#160;</td><td>The numerator of the right hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The denominator of the right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>expr</code> and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a dimension of <code>*this</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79acafbe4f67eb7e2710287bcd60db96"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::generalized_affine_preimage" ref="a79acafbe4f67eb7e2710287bcd60db96" args="(const Linear_Expression &amp;lhs, Relation_Symbol relsym, const Linear_Expression &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::generalized_affine_preimage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>relsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>rhs</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Generalized_Affine_Relations">affine relation</a> <img class="formulaInl" alt="$\mathrm{lhs}' \relsym \mathrm{rhs}$" src="form_704.png"/>, where <img class="formulaInl" alt="$\mathord{\relsym}$" src="form_309.png"/> is the relation symbol encoded by <code>relsym</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&#160;</td><td>The left hand side affine expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relsym</em>&#160;</td><td>The relation symbol.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&#160;</td><td>The right hand side affine expression.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>lhs</code> or <code>rhs</code> or if <code>relsym</code> is a strict relation symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acda762f8c081fed2862260211618fce0"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounded_affine_image" ref="acda762f8c081fed2862260211618fce0" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounded_affine_image </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the image of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&#160;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&#160;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a178a6a88143f44b43939d36024af6162"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::bounded_affine_preimage" ref="a178a6a88143f44b43939d36024af6162" args="(Variable var, const Linear_Expression &amp;lb_expr, const Linear_Expression &amp;ub_expr, Coefficient_traits::const_reference denominator=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::bounded_affine_preimage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>lb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>ub_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>denominator</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the preimage of <code>*this</code> with respect to the <a class="el" href="main.html#Single_Update_Bounded_Affine_Relations">bounded affine relation</a> <img class="formulaInl" alt="$\frac{\mathrm{lb\_expr}}{\mathrm{denominator}} \leq \mathrm{var}' \leq \frac{\mathrm{ub\_expr}}{\mathrm{denominator}}$" src="form_705.png"/>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable updated by the affine relation;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb_expr</em>&#160;</td><td>The numerator of the lower bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ub_expr</em>&#160;</td><td>The numerator of the upper bounding affine expression;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>denominator</em>&#160;</td><td>The (common) denominator for the lower and upper bounding affine expressions (optional argument with default value 1).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>denominator</code> is zero or if <code>lb_expr</code> (resp., <code>ub_expr</code>) and <code>*this</code> are dimension-incompatible or if <code>var</code> is not a space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a66e6f883c7310ddbc312f78bb0970f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::time_elapse_assign" ref="a5a66e6f883c7310ddbc312f78bb0970f" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::time_elapse_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#Time_Elapse_Operator">time-elapse</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5616d386d85dc734e155a67f12e7752f"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::wrap_assign" ref="a5616d386d85dc734e155a67f12e7752f" args="(const Variables_Set &amp;vars, Bounded_Integer_Type_Width w, Bounded_Integer_Type_Representation r, Bounded_Integer_Type_Overflow o, const Constraint_System *pcs=0, unsigned complexity_threshold=16, bool wrap_individually=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::wrap_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga73813939ed838a85ae565152ba3cb6fd">Bounded_Integer_Type_Width</a>&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga61102bed0c7780ab782fcc8cd57a384a">Bounded_Integer_Type_Representation</a>&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga84cc2bd35e1437f8df3be984dd1f4638">Bounded_Integer_Type_Overflow</a>&#160;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> *&#160;</td>
          <td class="paramname"> <em>pcs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"> <em>complexity_threshold</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wrap_individually</em> = <code>true</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="main.html#Wrapping_Operator">Wraps</a> the specified dimensions of the vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&#160;</td><td>The width of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&#160;</td><td>The representation of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>o</em>&#160;</td><td>The overflow behavior of the bounded integer type corresponding to all the dimensions to be wrapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcs</em>&#160;</td><td>Possibly null pointer to a constraint system whose variables are contained in <code>vars</code>. If <code>*pcs</code> depends on variables not in <code>vars</code>, the behavior is undefined. When non-null, the pointed-to constraint system is assumed to represent the conditional or looping construct guard with respect to which wrapping is performed. Since wrapping requires the computation of upper bounds and due to non-distributivity of constraint refinement over upper bounds, passing a constraint system in this way can be more precise than refining the result of the wrapping operation with the constraints in <code>*pcs</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity_threshold</em>&#160;</td><td>A precision parameter of the <a class="el" href="main.html#Wrapping_Operator">wrapping operator</a>: higher values result in possibly improved precision.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrap_individually</em>&#160;</td><td><code>true</code> if the dimensions should be wrapped individually (something that results in much greater efficiency to the detriment of precision).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*pcs</code> is dimension-incompatible with <code>vars</code>, or if <code>*this</code> is dimension-incompatible <code>vars</code> or with <code>*pcs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e0339ccaf8da39b9fd21ff8777e99e4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::drop_some_non_integer_points" ref="a3e0339ccaf8da39b9fd21ff8777e99e4" args="(Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2204d6d24f9c68fdb6a72062afe9a209"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::drop_some_non_integer_points" ref="a2204d6d24f9c68fdb6a72062afe9a209" args="(const Variables_Set &amp;vars, Complexity_Class complexity=ANY_COMPLEXITY)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::drop_some_non_integer_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga113f1e845cba6b1c3c5705d0e14f1cc1">Complexity_Class</a>&#160;</td>
          <td class="paramname"> <em>complexity</em> = <code>ANY_COMPLEXITY</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possibly tightens <code>*this</code> by dropping some points with non-integer coordinates for the space dimensions corresponding to <code>vars</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>Points with non-integer coordinates for these variables/space-dimensions can be discarded.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complexity</em>&#160;</td><td>The maximal complexity of any algorithms used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently there is no optimality guarantee, not even if <code>complexity</code> is <code>ANY_COMPLEXITY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9507085c5b0efd13c80f08a22b0f5529"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::CC76_extrapolation_assign" ref="a9507085c5b0efd13c80f08a22b0f5529" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24d2b69146ab1b2216e437468a818cea"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::CC76_extrapolation_assign" ref="a24d2b69146ab1b2216e437468a818cea" args="(const BD_Shape &amp;y, Iterator first, Iterator last, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&#160;</td><td>An iterator referencing the first stop-point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&#160;</td><td>An iterator referencing one past the last stop-point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a02b17cbccf348192f3e7f776b3b3fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::BHMZ05_widening_assign" ref="a1a02b17cbccf348192f3e7f776b3b3fd" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::BHMZ05_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> of <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeda87d46bc3b54b420a475934e0e1cb6"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::limited_BHMZ05_extrapolation_assign" ref="aeda87d46bc3b54b420a475934e0e1cb6" args="(const BD_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::limited_BHMZ05_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#BHMZ05_widening">BHMZ05-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The system of constraints used to improve the widened BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf3cfc56df68bc8063e6e9eb3d0ad3f1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::CC76_narrowing_assign" ref="adf3cfc56df68bc8063e6e9eb3d0ad3f1" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::CC76_narrowing_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of restoring in <code>y</code> the constraints of <code>*this</code> that were lost by <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> applications. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> contain <code>*this</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>As was the case for widening operators, the argument <code>y</code> is meant to denote the value computed in the previous iteration step, whereas <code>*this</code> denotes the value computed in the current iteration step (in the <em>decreasing</em> iteration sequence). Hence, the call <code>x.CC76_narrowing_assign(y)</code> will assign to <code>x</code> the result of the computation <img class="formulaInl" alt="$\mathtt{y} \Delta \mathtt{x}$" src="form_726.png"/>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2af430cd70ac416ca0907312b65812e6"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::limited_CC76_extrapolation_assign" ref="a2af430cd70ac416ca0907312b65812e6" args="(const BD_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::limited_CC76_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#CC76_extrapolation">CC76-extrapolation</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The system of constraints used to improve the widened BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible or if <code>cs</code> contains a strict inequality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d71f71f50ba04fe5f810acf0cf1e294"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::H79_widening_assign" ref="a5d71f71f50ba04fe5f810acf0cf1e294" args="(const BD_Shape &amp;y, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::H79_widening_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of computing the <a class="el" href="main.html#H79_widening">H79-widening</a> between <code>*this</code> and <code>y</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accbd8986577794cea90edef63e859ab1"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::limited_H79_extrapolation_assign" ref="accbd8986577794cea90edef63e859ab1" args="(const BD_Shape &amp;y, const Constraint_System &amp;cs, unsigned *tp=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::limited_H79_extrapolation_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint__System.html">Constraint_System</a> &amp;&#160;</td>
          <td class="paramname"> <em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improves the result of the <a class="el" href="main.html#H79_widening">H79-widening</a> computation by also enforcing those constraints in <code>cs</code> that are satisfied by all the points of <code>*this</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&#160;</td><td>A BDS that <em>must</em> be contained in <code>*this</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cs</em>&#160;</td><td>The system of constraints used to improve the widened BDS.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&#160;</td><td>An optional pointer to an unsigned variable storing the number of available tokens (to be used when applying the <a class="el" href="main.html#Widening_with_Tokens">widening with tokens</a> delay technique).</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code>, <code>y</code> and <code>cs</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c0703b2311336754e28a7f739b7e685"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_space_dimensions_and_embed" ref="a9c0703b2311336754e28a7f739b7e685" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_space_dimensions_and_embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new dimensions and embeds the old BDS into the new space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The new dimensions will be those having the highest indexes in the new BDS, which is defined by a system of bounded differences in which the variables running through the new dimensions are unconstrained. For instance, when starting from the BDS <img class="formulaInl" alt="$\cB \sseq \Rset^2$" src="form_727.png"/> and adding a third dimension, the result will be the BDS </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, z)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cB \,\bigr\}. \]" src="form_728.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="afa8a10ff4b09f8a87e3c558a39f5888e"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::add_space_dimensions_and_project" ref="afa8a10ff4b09f8a87e3c558a39f5888e" args="(dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::add_space_dimensions_and_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>m</code> new dimensions to the BDS and does not embed it in the new vector space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of dimensions to add.</td></tr>
  </table>
  </dd>
</dl>
<p>The new dimensions will be those having the highest indexes in the new BDS, which is defined by a system of bounded differences in which the variables running through the new dimensions are all constrained to be equal to 0. For instance, when starting from the BDS <img class="formulaInl" alt="$\cB \sseq \Rset^2$" src="form_727.png"/> and adding a third dimension, the result will be the BDS </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bigl\{\, (x, y, 0)^\transpose \in \Rset^3 \bigm| (x, y)^\transpose \in \cB \,\bigr\}. \]" src="form_729.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="ab0a670aeef72d808d620bbc33a5e8cd7"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::concatenate_assign" ref="ab0a670aeef72d808d620bbc33a5e8cd7" args="(const BD_Shape &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::concatenate_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the <a class="el" href="main.html#Concatenating_Polyhedra">concatenation</a> of <code>*this</code> and <code>y</code>, taken in this order. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if the concatenation would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae68d61763922cee018cbba3834b2085c" title="Returns the maximum space dimension that a BDS can handle.">max_space_dimension()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63e8c0f76da4e9b3520aa338d152d253"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::remove_space_dimensions" ref="a63e8c0f76da4e9b3520aa338d152d253" args="(const Variables_Set &amp;vars)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::remove_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the specified dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the dimensions to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab054f67fb31ea4e860dd7c24c0b56676"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::remove_higher_space_dimensions" ref="ab054f67fb31ea4e860dd7c24c0b56676" args="(dimension_type new_dimension)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::remove_higher_space_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>new_dimension</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the higher dimensions so that the resulting space will have dimension <code>new_dimension</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>new_dimension</code> is greater than the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac65231748a66ac5c074502cc8e652e10"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::map_space_dimensions" ref="ac65231748a66ac5c074502cc8e652e10" args="(const Partial_Function &amp;pfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Partial_Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::map_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const Partial_Function &amp;&#160;</td>
          <td class="paramname"> <em>pfunc</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the dimensions of the vector space according to a <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">partial function</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfunc</em>&#160;</td><td>The partial function specifying the destiny of each dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>The template type parameter Partial_Function must provide the following methods. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> has_empty_codomain() const
</pre></div><p> returns <code>true</code> if and only if the represented partial function has an empty co-domain (i.e., it is always undefined). The <code>has_empty_codomain()</code> method will always be called before the methods below. However, if <code>has_empty_codomain()</code> returns <code>true</code>, none of the functions below will be called. </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> max_in_codomain() const
</pre></div><p> returns the maximum value that belongs to the co-domain of the partial function. </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> maps(<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i, <a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a>&amp; j) <span class="keyword">const</span>
</pre></div><p> Let <img class="formulaInl" alt="$f$" src="form_333.png"/> be the represented function and <img class="formulaInl" alt="$k$" src="form_296.png"/> be the value of <code>i</code>. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is defined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <img class="formulaInl" alt="$f(k)$" src="form_708.png"/> is assigned to <code>j</code> and <code>true</code> is returned. If <img class="formulaInl" alt="$f$" src="form_333.png"/> is undefined in <img class="formulaInl" alt="$k$" src="form_296.png"/>, then <code>false</code> is returned.</p>
<p>The result is undefined if <code>pfunc</code> does not encode a partial function with the properties described in the <a class="el" href="main.html#Mapping_the_Dimensions_of_the_Vector_Space">specification of the mapping operator</a>. </p>

</div>
</div>
<a class="anchor" id="a0badc932380dcb7f72ea50ca922d9d4b"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::expand_space_dimension" ref="a0badc932380dcb7f72ea50ca922d9d4b" args="(Variable var, dimension_type m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::expand_space_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td>
          <td class="paramname"> <em>m</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <code>m</code> copies of the space dimension corresponding to <code>var</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&#160;</td><td>The variable corresponding to the space dimension to be replicated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&#160;</td><td>The number of replicas to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>var</code> does not correspond to a dimension of the vector space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>std::length_error</em>&#160;</td><td>Thrown if adding <code>m</code> new space dimensions would cause the vector space to exceed dimension <code><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html#ae68d61763922cee018cbba3834b2085c" title="Returns the maximum space dimension that a BDS can handle.">max_space_dimension()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, and <code>var</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, then the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension is <a class="el" href="main.html#expand_space_dimension">expanded</a> to <code>m</code> new space dimensions <img class="formulaInl" alt="$n$" src="form_0.png"/>, <img class="formulaInl" alt="$n+1$" src="form_178.png"/>, <img class="formulaInl" alt="$\dots$" src="form_709.png"/>, <img class="formulaInl" alt="$n+m-1$" src="form_180.png"/>. </p>

</div>
</div>
<a class="anchor" id="a1f8426558552c358c30b6263c758fe51"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::fold_space_dimensions" ref="a1f8426558552c358c30b6263c758fe51" args="(const Variables_Set &amp;vars, Variable dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::fold_space_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Variables__Set.html">Variables_Set</a> &amp;&#160;</td>
          <td class="paramname"> <em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>dest</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Folds the space dimensions in <code>vars</code> into <code>dest</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vars</em>&#160;</td><td>The set of <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects corresponding to the space dimensions to be folded;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&#160;</td><td>The variable corresponding to the space dimension that is the destination of the folding operation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is dimension-incompatible with <code>dest</code> or with one of the <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html" title="A dimension of the vector space.">Variable</a> objects contained in <code>vars</code>. Also thrown if <code>dest</code> is contained in <code>vars</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*this</code> has space dimension <img class="formulaInl" alt="$n$" src="form_0.png"/>, with <img class="formulaInl" alt="$n > 0$" src="form_177.png"/>, <code>dest</code> has space dimension <img class="formulaInl" alt="$k \leq n$" src="form_144.png"/>, <code>vars</code> is a set of variables whose maximum space dimension is also less than or equal to <img class="formulaInl" alt="$n$" src="form_0.png"/>, and <code>dest</code> is not a member of <code>vars</code>, then the space dimensions corresponding to variables in <code>vars</code> are <a class="el" href="main.html#fold_space_dimensions">folded</a> into the <img class="formulaInl" alt="$k$" src="form_296.png"/>-th space dimension. </p>

</div>
</div>
<a class="anchor" id="ae0a1b4b4a344cad01c58e8e006a7ff16"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::hash_code" ref="ae0a1b4b4a344cad01c58e8e006a7ff16" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt;::hash_code </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a 32-bit hash code for <code>*this</code>. </p>
<p>If <code>x</code> and <code>y</code> are such that <code>x == y</code>, then <code>x.hash_code() == y.hash_code()</code>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac91aac77237c2405df039c4fcfa08ab0"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator==" ref="ac91aac77237c2405df039c4fcfa08ab0" args="(const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are the same BDS. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>false</code> is returned.</p>

</div>
</div>
<a class="anchor" id="a5049b85730d6720536be440753b11ed8"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator&lt;&lt;" ref="a5049b85730d6720536be440753b11ed8" args="(std::ostream &amp;s, const BD_Shape&lt; T &gt; &amp;bds)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>
<p>Writes a textual representation of <code>bds</code> on <code>s:</code> <code>false</code> is written if <code>bds</code> is an empty polyhedron; <code>true</code> is written if <code>bds</code> is the universe polyhedron; a system of constraints defining <code>bds</code> is written otherwise, all constraints separated by ", ".</p>

</div>
</div>
<a class="anchor" id="acdc537f0aa5117fe3749d3c50b7dc4fd"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::operator!=" ref="acdc537f0aa5117fe3749d3c50b7dc4fd" args="(const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> aren't the same BDS. </p>
<p>Note that <code>x</code> and <code>y</code> may be dimension-incompatible shapes: in this case, the value <code>true</code> is returned.</p>

</div>
</div>
<a class="anchor" id="af4b0f891a6911d7784216f537fa3e473"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::rectilinear_distance_assign" ref="af4b0f891a6911d7784216f537fa3e473" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a221657648a7e456dba61589e37765cd4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::rectilinear_distance_assign" ref="a221657648a7e456dba61589e37765cd4" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="a47a21a1c8a88c306877d15d4dbc697b4"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::euclidean_distance_assign" ref="a47a21a1c8a88c306877d15d4dbc697b4" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="ae5c66812ab981ee2d1ab96ce218a7782"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::euclidean_distance_assign" ref="ae5c66812ab981ee2d1ab96ce218a7782" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="ad0a9267e420144cacfb867076d00a803"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::l_infinity_distance_assign" ref="ad0a9267e420144cacfb867076d00a803" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>

</div>
</div>
<a class="anchor" id="a8d6c186583503c4394603550b50edf59"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::l_infinity_distance_assign" ref="a8d6c186583503c4394603550b50edf59" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const BD_Shape&lt; T &gt; &amp;x, const BD_Shape&lt; T &gt; &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>

</div>
</div>
<a class="anchor" id="af6351727d099ad178db8b8e742507f4c"></a><!-- doxytag: member="Parma_Polyhedra_Library::BD_Shape::swap" ref="af6351727d099ad178db8b8e742507f4c" args="(Parma_Polyhedra_Library::BD_Shape&lt; T &gt; &amp;x, Parma_Polyhedra_Library::BD_Shape&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1BD__Shape.html">Parma_Polyhedra_Library::BD_Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
