<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Generator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Generator Class Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Generator" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Linear_Row" -->
<p>A line, ray, point or closure point.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p>Inherits Parma_Polyhedra_Library::Linear_Row.</p>

<p>Inherited by <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html">Parma_Polyhedra_Library::Grid_Generator</a><code> [private]</code>.</p>

<p><a href="classParma__Polyhedra__Library_1_1Generator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5">Type</a> { <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5a4312979a12cae5ebb0791496e1ccce7a">LINE</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5a05abaa6ff4aa204c25c94719e8a2b6f4">RAY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5ab7fe867b1243e111ef4364e3ef5b5329">POINT</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5abed2d3fff60e7c0b8fc325bf46f9725f">CLOSURE_POINT</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The generator type. </p>
 <a href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f29f8b40d09b17eaa4cbaac069f72a0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::Generator" ref="a3f29f8b40d09b17eaa4cbaac069f72a0" args="(const Generator &amp;g)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0">Generator</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab339ccb929a7255295ad19a5b168d5d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::~Generator" ref="ab339ccb929a7255295ad19a5b168d5d0" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ab339ccb929a7255295ad19a5b168d5d0">~Generator</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb7d78e7b37d7f4b99babdc5cc84783"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator=" ref="a4fb7d78e7b37d7f4b99babdc5cc84783" args="(const Generator &amp;g)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a4fb7d78e7b37d7f4b99babdc5cc84783">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c884f5152f75040139ec3d9ec8ac293"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::space_dimension" ref="a1c884f5152f75040139ec3d9ec8ac293" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a1c884f5152f75040139ec3d9ec8ac293">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c502c8d46ed2f68679404fdfdf8e0bf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::type" ref="a7c502c8d46ed2f68679404fdfdf8e0bf" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a7c502c8d46ed2f68679404fdfdf8e0bf">type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generator type of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8cee05f88ad5aea288c1f6b8bf7cdc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_line" ref="ad8cee05f88ad5aea288c1f6b8bf7cdc7" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ad8cee05f88ad5aea288c1f6b8bf7cdc7">is_line</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5902ab7e2d3304037a56ecda7fc22a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_ray" ref="ae5902ab7e2d3304037a56ecda7fc22a4" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ae5902ab7e2d3304037a56ecda7fc22a4">is_ray</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a ray. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1827b1f7a42393a2526944530559c5a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_point" ref="af1827b1f7a42393a2526944530559c5a" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#af1827b1f7a42393a2526944530559c5a">is_point</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aba27eb7310045e1a35c7e68af01ab2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_closure_point" ref="a2aba27eb7310045e1a35c7e68af01ab2" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a2aba27eb7310045e1a35c7e68af01ab2">is_closure_point</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a closure point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#afceefab91d648d188e42e5a75a3a977e">coefficient</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficient of <code>v</code> in <code>*this</code>.  <a href="#afceefab91d648d188e42e5a75a3a977e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#aeff190ba56f86d3425859043689d499a">divisor</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>*this</code> is either a point or a closure point, returns its divisor.  <a href="#aeff190ba56f86d3425859043689d499a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade98f4e320d7d21e223afb83240b3800"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::total_memory_in_bytes" ref="ade98f4e320d7d21e223afb83240b3800" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ade98f4e320d7d21e223afb83240b3800">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77fc44f44b1bdda486e19e30310634e2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::external_memory_in_bytes" ref="a77fc44f44b1bdda486e19e30310634e2" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a77fc44f44b1bdda486e19e30310634e2">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a42867df59ec40173391b76074f9f0fb2">is_equivalent_to</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent generators.  <a href="#a42867df59ec40173391b76074f9f0fb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c726daa7d565ded0b177e24b6d1104"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ascii_dump" ref="a13c726daa7d565ded0b177e24b6d1104" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a13c726daa7d565ded0b177e24b6d1104">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa40eabb29ea4abe082c3a2e6dc820276"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ascii_dump" ref="aa40eabb29ea4abe082c3a2e6dc820276" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#aa40eabb29ea4abe082c3a2e6dc820276">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2531310fd7806c9e4f745cab145926"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::print" ref="ade2531310fd7806c9e4f745cab145926" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ade2531310fd7806c9e4f745cab145926">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc8ae851f2a0a6260d954b3bd8505249"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ascii_load" ref="abc8ae851f2a0a6260d954b3bd8505249" args="(std::istream &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#abc8ae851f2a0a6260d954b3bd8505249">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#aa40eabb29ea4abe082c3a2e6dc820276" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1bf8c762c6f36b30f2abcaffe591acb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::OK" ref="af1bf8c762c6f36b30f2abcaffe591acb" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#af1bf8c762c6f36b30f2abcaffe591acb">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a775a8cec41b0fcc88689a171f5be8546"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::swap" ref="a775a8cec41b0fcc88689a171f5be8546" args="(Generator &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a775a8cec41b0fcc88689a171f5be8546">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a584f3fd5a19536644a66818169b16ac6">line</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line of direction <code>e</code>.  <a href="#a584f3fd5a19536644a66818169b16ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ab36bf020da4fb4583e6e1a6b94197cb4">ray</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ray of direction <code>e</code>.  <a href="#ab36bf020da4fb4583e6e1a6b94197cb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7">point</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the point at <code>e</code> / <code>d</code>.  <a href="#a6b8dae6436867a53e27720ee211f1cc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a5c56451d80b8c02636854053de9e0440">closure_point</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closure point at <code>e</code> / <code>d</code>.  <a href="#a5c56451d80b8c02636854053de9e0440"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad593d3aa49a632911d8d49c83b3f4985"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::max_space_dimension" ref="ad593d3aa49a632911d8d49c83b3f4985" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ad593d3aa49a632911d8d49c83b3f4985">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bc88b2886b0b86865186d142e5ee414"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::initialize" ref="a3bc88b2886b0b86865186d142e5ee414" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a3bc88b2886b0b86865186d142e5ee414">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb212a14f52ed934059925c1f5f2010"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::finalize" ref="aebb212a14f52ed934059925c1f5f2010" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#aebb212a14f52ed934059925c1f5f2010">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a600c942b0a2e94b550ccd84ef9c30928"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::zero_dim_point" ref="a600c942b0a2e94b550ccd84ef9c30928" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a600c942b0a2e94b550ccd84ef9c30928">zero_dim_point</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the origin of the zero-dimensional space <img class="formulaInl" alt="$\Rset^0$" src="form_175.png"/>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6804f93015ae6e1dc0c2e42e726380c4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::zero_dim_closure_point" ref="a6804f93015ae6e1dc0c2e42e726380c4" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a6804f93015ae6e1dc0c2e42e726380c4">zero_dim_closure_point</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns, as a closure point, the origin of the zero-dimensional space <img class="formulaInl" alt="$\Rset^0$" src="form_175.png"/>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a303b4ed4262469c1834228e0f88dba74">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a303b4ed4262469c1834228e0f88dba74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a10cab5245f80aacd8000d0312730ec03">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a10cab5245f80aacd8000d0312730ec03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ad7552a414d66f92897d12767579fa3ca">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>.  <a href="#ad7552a414d66f92897d12767579fa3ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a0c26ae11a4146369ff86288347cc54db">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>.  <a href="#a0c26ae11a4146369ff86288347cc54db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ae6206985cd5536c4dac181de5fb21247">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#ae6206985cd5536c4dac181de5fb21247"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a5363ddeed325652ee6c064a8936cfe57">rectilinear_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>.  <a href="#a5363ddeed325652ee6c064a8936cfe57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#aa98511973ca14e8904e4e2c1f774bd3a">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#aa98511973ca14e8904e4e2c1f774bd3a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#af4abff14e1b88cbb929f0733432477ff">euclidean_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the euclidean distance between <code>x</code> and <code>y</code>.  <a href="#af4abff14e1b88cbb929f0733432477ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a0fb144e5f3fb6815e4c28c89883607be">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#a0fb144e5f3fb6815e4c28c89883607be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temp , typename To &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ae67eb83f2626818420b3201db09e3d58">l_infinity_distance_assign</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;r, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;y, <a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a> dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>.  <a href="#ae67eb83f2626818420b3201db09e3d58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a75190def344d4c1ba6c59a6f0fcf7420">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5">Generator::Type</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a75190def344d4c1ba6c59a6f0fcf7420"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A line, ray, point or closure point. </p>
<p>An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> is one of the following:</p>
<ul>
<li>a line <img class="formulaInl" alt="$\vect{l} = (a_0, \ldots, a_{n-1})^\transpose$" src="form_500.png"/>;</li>
</ul>
<ul>
<li>a ray <img class="formulaInl" alt="$\vect{r} = (a_0, \ldots, a_{n-1})^\transpose$" src="form_501.png"/>;</li>
</ul>
<ul>
<li>a point <img class="formulaInl" alt="$\vect{p} = (\frac{a_0}{d}, \ldots, \frac{a_{n-1}}{d})^\transpose$" src="form_502.png"/>;</li>
</ul>
<ul>
<li>a closure point <img class="formulaInl" alt="$\vect{c} = (\frac{a_0}{d}, \ldots, \frac{a_{n-1}}{d})^\transpose$" src="form_503.png"/>;</li>
</ul>
<p>where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the dimension of the space and, for points and closure points, <img class="formulaInl" alt="$d > 0$" src="form_504.png"/> is the divisor.</p>
<dl class="user"><dt><b>A note on terminology.</b></dt><dd>As observed in Section <a class="el" href="main.html#representation">Representations of Convex Polyhedra</a>, there are cases when, in order to represent a polyhedron <img class="formulaInl" alt="$\cP$" src="form_58.png"/> using the generator system <img class="formulaInl" alt="$\cG = (L, R, P, C)$" src="form_108.png"/>, we need to include in the finite set <img class="formulaInl" alt="$P$" src="form_86.png"/> even points of <img class="formulaInl" alt="$\cP$" src="form_58.png"/> that are <em>not</em> vertices of <img class="formulaInl" alt="$\cP$" src="form_58.png"/>. This situation is even more frequent when working with NNC polyhedra and it is the reason why we prefer to use the word `point' where other libraries use the word `vertex'.</dd></dl>
<dl class="user"><dt><b>How to build a generator.</b></dt><dd>Each type of generator is built by applying the corresponding function (<code>line</code>, <code>ray</code>, <code>point</code> or <code>closure_point</code>) to a linear expression, representing a direction in the space; the space dimension of the generator is defined as the space dimension of the corresponding linear expression. Linear expressions used to define a generator should be homogeneous (any constant term will be simply ignored). When defining points and closure points, an optional Coefficient argument can be used as a common <em>divisor</em> for all the coefficients occurring in the provided linear expression; the default value for this argument is 1.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In all the following examples it is assumed that variables <code>x</code>, <code>y</code> and <code>z</code> are defined as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable z(2);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds a line with direction <img class="formulaInl" alt="$x-y-z$" src="form_505.png"/> and having space dimension <img class="formulaInl" alt="$3$" src="form_487.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> l = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">line</a>(x - y - z);
</pre></div> As mentioned above, the constant term of the linear expression is not relevant. Thus, the following code has the same effect: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> l = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">line</a>(x - y - z + 15);
</pre></div> By definition, the origin of the space is not a line, so that the following code throws an exception: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> l = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">line</a>(0*x);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 2</b></dt><dd>The following code builds a ray with the same direction as the line in Example 1: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> r = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#ab36bf020da4fb4583e6e1a6b94197cb4" title="Returns the ray of direction e.">ray</a>(x - y - z);
</pre></div> As is the case for lines, when specifying a ray the constant term of the linear expression is not relevant; also, an exception is thrown when trying to build a ray from the origin of the space.</dd></dl>
<dl class="user"><dt><b>Example 3</b></dt><dd>The following code builds the point <img class="formulaInl" alt="$\vect{p} = (1, 0, 2)^\transpose \in \Rset^3$" src="form_506.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> p = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(1*x + 0*y + 2*z);
</pre></div> The same effect can be obtained by using the following code: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> p = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(x + 2*z);
</pre></div> Similarly, the origin <img class="formulaInl" alt="$\vect{0} \in \Rset^3$" src="form_507.png"/> can be defined using either one of the following lines of code: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> origin3 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(0*x + 0*y + 0*z);
  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> origin3_alt = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(0*z);
</pre></div> Note however that the following code would have defined a different point, namely <img class="formulaInl" alt="$\vect{0} \in \Rset^2$" src="form_508.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> origin2 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(0*y);
</pre></div> The following two lines of code both define the only point having space dimension zero, namely <img class="formulaInl" alt="$\vect{0} \in \Rset^0$" src="form_509.png"/>. In the second case we exploit the fact that the first argument of the function <code>point</code> is optional. <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> origin0 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a600c942b0a2e94b550ccd84ef9c30928" title="Returns the origin of the zero-dimensional space .">Generator::zero_dim_point</a>();
  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> origin0_alt = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>();
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 4</b></dt><dd>The point <img class="formulaInl" alt="$\vect{p}$" src="form_510.png"/> specified in Example 3 above can also be obtained with the following code, where we provide a non-default value for the second argument of the function <code>point</code> (the divisor): <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> p = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(2*x + 0*y + 4*z, 2);
</pre></div> Obviously, the divisor can be usefully exploited to specify points having some non-integer (but rational) coordinates. For instance, the point <img class="formulaInl" alt="$\vect{q} = (-1.5, 3.2, 2.1)^\transpose \in \Rset^3$" src="form_511.png"/> can be specified by the following code: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> q = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(-15*x + 32*y + 21*z, 10);
</pre></div> If a zero divisor is provided, an exception is thrown.</dd></dl>
<dl class="user"><dt><b>Example 5</b></dt><dd>Closure points are specified in the same way we defined points, but invoking their specific constructor function. For instance, the closure point <img class="formulaInl" alt="$\vect{c} = (1, 0, 2)^\transpose \in \Rset^3$" src="form_512.png"/> is defined by <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> c = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">closure_point</a>(1*x + 0*y + 2*z);
</pre></div> For the particular case of the (only) closure point having space dimension zero, we can use any of the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> closure_origin0 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6804f93015ae6e1dc0c2e42e726380c4" title="Returns, as a closure point, the origin of the zero-dimensional space .">Generator::zero_dim_closure_point</a>();
  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> closure_origin0_alt = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">closure_point</a>();
</pre></div></dd></dl>
<dl class="user"><dt><b>How to inspect a generator</b></dt><dd>Several methods are provided to examine a generator and extract all the encoded information: its space dimension, its type and the value of its integer coefficients.</dd></dl>
<dl class="user"><dt><b>Example 6</b></dt><dd>The following code shows how it is possible to access each single coefficient of a generator. If <code>g1</code> is a point having coordinates <img class="formulaInl" alt="$(a_0, \ldots, a_{n-1})^\transpose$" src="form_513.png"/>, we construct the closure point <code>g2</code> having coordinates <img class="formulaInl" alt="$(a_0, 2 a_1, \ldots, (i+1)a_i, \ldots, n a_{n-1})^\transpose$" src="form_514.png"/>. <div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (g1.is_point()) {
    cout &lt;&lt; <span class="stringliteral">&quot;Point g1: &quot;</span> &lt;&lt; g1 &lt;&lt; endl;
    Linear_Expression e;
    <span class="keywordflow">for</span> (<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i = g1.space_dimension(); i-- &gt; 0; )
      e += (i + 1) * g1.coefficient(Variable(i)) * Variable(i);
    <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> g2 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">closure_point</a>(e, g1.divisor());
    cout &lt;&lt; <span class="stringliteral">&quot;Closure point g2: &quot;</span> &lt;&lt; g2 &lt;&lt; endl;
  }
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">&quot;Generator g1 is not a point.&quot;</span> &lt;&lt; endl;
</pre></div> Therefore, for the point <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a3f29f8b40d09b17eaa4cbaac069f72a0" title="Ordinary copy constructor.">Generator</a> g1 = <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a>(2*x - y + 3*z, 2);
</pre></div> we would obtain the following output: <div class="fragment"><pre class="fragment">  Point g1: p((2*A - B + 3*C)/2)
  Closure <a class="code" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">point</a> g2: cp((2*A - 2*B + 9*C)/2)
</pre></div> When working with (closure) points, be careful not to confuse the notion of <em>coefficient</em> with the notion of <em>coordinate</em>: these are equivalent only when the divisor of the (closure) point is 1. </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a55b76ba0041601d8da38ab5ad619eed5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::Type" ref="a55b76ba0041601d8da38ab5ad619eed5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5">Parma_Polyhedra_Library::Generator::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The generator type. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a55b76ba0041601d8da38ab5ad619eed5a4312979a12cae5ebb0791496e1ccce7a"></a><!-- doxytag: member="LINE" ref="a55b76ba0041601d8da38ab5ad619eed5a4312979a12cae5ebb0791496e1ccce7a" args="" -->LINE</em>&nbsp;</td><td>
<p>The generator is a line. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a55b76ba0041601d8da38ab5ad619eed5a05abaa6ff4aa204c25c94719e8a2b6f4"></a><!-- doxytag: member="RAY" ref="a55b76ba0041601d8da38ab5ad619eed5a05abaa6ff4aa204c25c94719e8a2b6f4" args="" -->RAY</em>&nbsp;</td><td>
<p>The generator is a ray. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a55b76ba0041601d8da38ab5ad619eed5ab7fe867b1243e111ef4364e3ef5b5329"></a><!-- doxytag: member="POINT" ref="a55b76ba0041601d8da38ab5ad619eed5ab7fe867b1243e111ef4364e3ef5b5329" args="" -->POINT</em>&nbsp;</td><td>
<p>The generator is a point. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a55b76ba0041601d8da38ab5ad619eed5abed2d3fff60e7c0b8fc325bf46f9725f"></a><!-- doxytag: member="CLOSURE_POINT" ref="a55b76ba0041601d8da38ab5ad619eed5abed2d3fff60e7c0b8fc325bf46f9725f" args="" -->CLOSURE_POINT</em>&nbsp;</td><td>
<p>The generator is a closure point. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Reimplemented in <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html#a10e7c95784e356487a6a6263a89cec66">Parma_Polyhedra_Library::Grid_Generator</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a584f3fd5a19536644a66818169b16ac6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::line" ref="a584f3fd5a19536644a66818169b16ac6" args="(const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the line of direction <code>e</code>. </p>
<p>Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a584f3fd5a19536644a66818169b16ac6" title="Returns the line of direction e.">Generator::line(const Linear_Expression&amp; e)</a>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the homogeneous part of <code>e</code> represents the origin of the vector space.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab36bf020da4fb4583e6e1a6b94197cb4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::ray" ref="ab36bf020da4fb4583e6e1a6b94197cb4" args="(const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> ray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the ray of direction <code>e</code>. </p>
<p>Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#ab36bf020da4fb4583e6e1a6b94197cb4" title="Returns the ray of direction e.">Generator::ray(const Linear_Expression&amp; e)</a>.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the homogeneous part of <code>e</code> represents the origin of the vector space.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b8dae6436867a53e27720ee211f1cc7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::point" ref="a6b8dae6436867a53e27720ee211f1cc7" args="(const Linear_Expression &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em> = <code>Linear_Expression::zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>d</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the point at <code>e</code> / <code>d</code>. </p>
<p>Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a6b8dae6436867a53e27720ee211f1cc7" title="Returns the point at e / d.">Generator::point(const Linear_Expression&amp; e, Coefficient_traits::const_reference d)</a>.</p>
<p>Both <code>e</code> and <code>d</code> are optional arguments, with default values <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero()</a> and <a class="el" href="namespaceParma__Polyhedra__Library.html#a66438955854cf73ddaf27a40a69fec7b" title="Returns a const reference to a Coefficient with value 1.">Coefficient_one()</a>, respectively.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>d</code> is zero.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c56451d80b8c02636854053de9e0440"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::closure_point" ref="a5c56451d80b8c02636854053de9e0440" args="(const Linear_Expression &amp;e=Linear_Expression::zero(), Coefficient_traits::const_reference d=Coefficient_one())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> closure_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em> = <code>Linear_Expression::zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>d</em> = <code>Coefficient_one()</code></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the closure point at <code>e</code> / <code>d</code>. </p>
<p>Shorthand for <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html" title="A line, ray, point or closure point.">Generator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a5c56451d80b8c02636854053de9e0440" title="Returns the closure point at e / d.">Generator::closure_point(const Linear_Expression&amp; e, Coefficient_traits::const_reference d)</a>.</p>
<p>Both <code>e</code> and <code>d</code> are optional arguments, with default values <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero()</a> and <a class="el" href="namespaceParma__Polyhedra__Library.html#a66438955854cf73ddaf27a40a69fec7b" title="Returns a const reference to a Coefficient with value 1.">Coefficient_one()</a>, respectively.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>d</code> is zero.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afceefab91d648d188e42e5a75a3a977e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::coefficient" ref="afceefab91d648d188e42e5a75a3a977e" args="(Variable v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Generator::coefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the coefficient of <code>v</code> in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if the index of <code>v</code> is greater than or equal to the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html#af4e7705af87f5eb64d2ebdc60cd7a36e">Parma_Polyhedra_Library::Grid_Generator</a>.</p>

</div>
</div>
<a class="anchor" id="aeff190ba56f86d3425859043689d499a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::divisor" ref="aeff190ba56f86d3425859043689d499a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Generator::divisor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If <code>*this</code> is either a point or a closure point, returns its divisor. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> is neither a point nor a closure point. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classParma__Polyhedra__Library_1_1Grid__Generator.html#acdc0aeddab3d98e336719f42e6e5b06c">Parma_Polyhedra_Library::Grid_Generator</a>.</p>

</div>
</div>
<a class="anchor" id="a42867df59ec40173391b76074f9f0fb2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::is_equivalent_to" ref="a42867df59ec40173391b76074f9f0fb2" args="(const Generator &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Generator::is_equivalent_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent generators. </p>
<p>Generators having different space dimensions are not equivalent. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a303b4ed4262469c1834228e0f88dba74"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator&lt;&lt;" ref="a303b4ed4262469c1834228e0f88dba74" args="(std::ostream &amp;s, const Generator &amp;g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>g</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<a class="anchor" id="a10cab5245f80aacd8000d0312730ec03"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::swap" ref="a10cab5245f80aacd8000d0312730ec03" args="(Parma_Polyhedra_Library::Generator &amp;x, Parma_Polyhedra_Library::Generator &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Parma_Polyhedra_Library::Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<a class="anchor" id="ad7552a414d66f92897d12767579fa3ca"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator==" ref="ad7552a414d66f92897d12767579fa3ca" args="(const Generator &amp;x, const Generator &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="a0c26ae11a4146369ff86288347cc54db"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator!=" ref="a0c26ae11a4146369ff86288347cc54db" args="(const Generator &amp;x, const Generator &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="ae6206985cd5536c4dac181de5fb21247"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::rectilinear_distance_assign" ref="ae6206985cd5536c4dac181de5fb21247" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>Computes the euclidean distance between <code>x</code> and <code>y</code>.</p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a5363ddeed325652ee6c064a8936cfe57"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::rectilinear_distance_assign" ref="a5363ddeed325652ee6c064a8936cfe57" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rectilinear_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the rectilinear (or Manhattan) distance between <code>x</code> and <code>y</code>. </p>
<p>If the rectilinear distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="aa98511973ca14e8904e4e2c1f774bd3a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::euclidean_distance_assign" ref="aa98511973ca14e8904e4e2c1f774bd3a" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="af4abff14e1b88cbb929f0733432477ff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::euclidean_distance_assign" ref="af4abff14e1b88cbb929f0733432477ff" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool euclidean_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the euclidean distance between <code>x</code> and <code>y</code>. </p>
<p>If the euclidean distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a0fb144e5f3fb6815e4c28c89883607be"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::l_infinity_distance_assign" ref="a0fb144e5f3fb6815e4c28c89883607be" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;To, Extended_Number_Policy&gt;.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using variables of type Checked_Number&lt;Temp, Extended_Number_Policy&gt;.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="ae67eb83f2626818420b3201db09e3d58"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::l_infinity_distance_assign" ref="ae67eb83f2626818420b3201db09e3d58" args="(Checked_Number&lt; To, Extended_Number_Policy &gt; &amp;r, const Generator &amp;x, const Generator &amp;y, Rounding_Dir dir, Temp &amp;tmp0, Temp &amp;tmp1, Temp &amp;tmp2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Temp , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool l_infinity_distance_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Checked__Number.html">Checked_Number</a>&lt; To, Extended_Number_Policy &gt; &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html">Generator</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga25ea3a289eadef732f4c7fd823387fb2">Rounding_Dir</a>&#160;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp &amp;&#160;</td>
          <td class="paramname"> <em>tmp2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code>. </p>
<p>If the <img class="formulaInl" alt="$L_\infty$" src="form_665.png"/> distance between <code>x</code> and <code>y</code> is defined, stores an approximation of it into <code>r</code> and returns <code>true</code>; returns <code>false</code> otherwise.</p>
<p>The direction of the approximation is specified by <code>dir</code>.</p>
<p>All computations are performed using the temporary variables <code>tmp0</code>, <code>tmp1</code> and <code>tmp2</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Distances are <em>only</em> defined between generators that are points and/or closure points; for rays or lines, <code>false</code> is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a75190def344d4c1ba6c59a6f0fcf7420"></a><!-- doxytag: member="Parma_Polyhedra_Library::Generator::operator&lt;&lt;" ref="a75190def344d4c1ba6c59a6f0fcf7420" args="(std::ostream &amp;s, const Generator::Type &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Generator.html#a55b76ba0041601d8da38ab5ad619eed5">Generator::Type</a> &amp;&#160;</td>
          <td class="paramname"> <em>t</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
