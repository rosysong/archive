<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Interval&lt; Boundary, Info &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Interval&lt; Boundary, Info &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Interval" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Interval_Base" -->
<p>A generic, not necessarily closed, possibly restricted interval.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p>Inherits Parma_Polyhedra_Library::Interval_Base.</p>

<p><a href="classParma__Polyhedra__Library_1_1Interval-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5160fe536bd1bc8d42c12de33f40493"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::swap" ref="ab5160fe536bd1bc8d42c12de33f40493" args="(Interval &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#ab5160fe536bd1bc8d42c12de33f40493">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Interval</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb730d60db4b7e1ddd4c9994ec077cf6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::topological_closure_assign" ref="afb730d60db4b7e1ddd4c9994ec077cf6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#afb730d60db4b7e1ddd4c9994ec077cf6">topological_closure_assign</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> its topological closure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a348c6523b219aee93545bb401dc0b813"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::total_memory_in_bytes" ref="a348c6523b219aee93545bb401dc0b813" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a348c6523b219aee93545bb401dc0b813">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeb70a45d5ee0c7fac5f5d6c659fc69e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::external_memory_in_bytes" ref="aaeb70a45d5ee0c7fac5f5d6c659fc69e" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#aaeb70a45d5ee0c7fac5f5d6c659fc69e">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a479e61ba0938cd3303c57f1881d8f2ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::Interval" ref="a479e61ba0938cd3303c57f1881d8f2ab" args="(const char *s)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a479e61ba0938cd3303c57f1881d8f2ab">Interval</a> (const char *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the smallest interval containing the number whose textual representation is contained in <code>s</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae34390c17dbd12de9906817c4b6cf479"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::difference_assign" ref="ae34390c17dbd12de9906817c4b6cf479" args="(const From &amp;x)" -->
template&lt;typename From &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Singleton&lt; From &gt;<br class="typebreak"/>
::value||Is_Interval&lt; From &gt;<br class="typebreak"/>
::value, <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#ae34390c17dbd12de9906817c4b6cf479">difference_assign</a> (const From &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest interval containing the set-theoretic difference of <code>*this</code> and <code>x</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a241f107b045949a58b49469a6a09caf9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::difference_assign" ref="a241f107b045949a58b49469a6a09caf9" args="(const From1 &amp;x, const From2 &amp;y)" -->
template&lt;typename From1 , typename From2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt;((Is_Singleton<br class="typebreak"/>
&lt; From1 &gt;::value||Is_Interval<br class="typebreak"/>
&lt; From1 &gt;::value)&amp;&amp;(Is_Singleton<br class="typebreak"/>
&lt; From2 &gt;::value||Is_Interval<br class="typebreak"/>
&lt; From2 &gt;::value)), <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a241f107b045949a58b49469a6a09caf9">difference_assign</a> (const From1 &amp;x, const From2 &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the smallest interval containing the set-theoretic difference of <code>x</code> and <code>y</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5915be624de343f1598d246ee4f1bc42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::lower_approximation_difference_assign" ref="a5915be624de343f1598d246ee4f1bc42" args="(const From &amp;x)" -->
template&lt;typename From &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Singleton&lt; From &gt;<br class="typebreak"/>
::value||Is_Interval&lt; From &gt;<br class="typebreak"/>
::value, <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a5915be624de343f1598d246ee4f1bc42">lower_approximation_difference_assign</a> (const From &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the largest interval contained in the set-theoretic difference of <code>*this</code> and <code>x</code>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename From &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Interval&lt; From &gt;<br class="typebreak"/>
::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#aa71726a7725f9269553ed9e594b0d74a">simplify_using_context_assign</a> (const From &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>.  <a href="#aa71726a7725f9269553ed9e594b0d74a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename From &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Interval&lt; From &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#aca669c9659132e9fa6adc7a9afbef642">empty_intersection_assign</a> (const From &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> an interval having empty intersection with <code>y</code>. The assigned interval should be as large as possible.  <a href="#aca669c9659132e9fa6adc7a9afbef642"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename From &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Singleton&lt; From &gt;<br class="typebreak"/>
::value||Is_Interval&lt; From &gt;<br class="typebreak"/>
::value, <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a6a869e3c010e87dff868fb410d4f0a20">refine_existential</a> (<a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> rel, const From &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines <code>to</code> according to the existential relation <code>rel</code> with <code>x</code>.  <a href="#a6a869e3c010e87dff868fb410d4f0a20"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename From &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt; Is_Singleton&lt; From &gt;<br class="typebreak"/>
::value||Is_Interval&lt; From &gt;<br class="typebreak"/>
::value, <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#ac3abadf1d96bef1880657113014d46dd">refine_universal</a> (<a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a> rel, const From &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines <code>to</code> so that it satisfies the universal relation <code>rel</code> with <code>x</code>.  <a href="#ac3abadf1d96bef1880657113014d46dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename From1 , typename From2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt;((Is_Singleton<br class="typebreak"/>
&lt; From1 &gt;::value||Is_Interval<br class="typebreak"/>
&lt; From1 &gt;::value)&amp;&amp;(Is_Singleton<br class="typebreak"/>
&lt; From2 &gt;::value||Is_Interval<br class="typebreak"/>
&lt; From2 &gt;::value)), <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a1c76acbe653414cc28fac54c69622446">mul_assign</a> (const From1 &amp;x, const From2 &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename From1 , typename From2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Enable_If&lt;((Is_Singleton<br class="typebreak"/>
&lt; From1 &gt;::value||Is_Interval<br class="typebreak"/>
&lt; From1 &gt;::value)&amp;&amp;(Is_Singleton<br class="typebreak"/>
&lt; From2 &gt;::value||Is_Interval<br class="typebreak"/>
&lt; From2 &gt;::value)), <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#af3699ea93d8ec71859566480bede9332">div_assign</a> (const From1 &amp;x, const From2 &amp;y)</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Boundary , typename Info &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html#a79370159de3dc1738441b20eff866329">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; Boundary, Info &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; Boundary, Info &gt; &amp;y)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Boundary, typename Info&gt;<br/>
 class Parma_Polyhedra_Library::Interval&lt; Boundary, Info &gt;</h3>

<p>A generic, not necessarily closed, possibly restricted interval. </p>
<p>The class template type parameter <code>Boundary</code> represents the type of the interval boundaries, and can be chosen, among other possibilities, within one of the following number families:</p>
<ul>
<li>a bounded precision native integer type (that is, from <code>signed char</code> to <code>long long</code> and from <code>int8_t</code> to <code>int64_t</code>);</li>
<li>a bounded precision floating point type (<code>float</code>, <code>double</code> or <code>long double</code>);</li>
<li>an unbounded integer or rational type, as provided by the C++ interface of GMP (<code>mpz_class</code> or <code>mpq_class</code>).</li>
</ul>
<p>The class template type parameter <code>Info</code> allows to control a number of features of the class, among which:</p>
<ul>
<li>the ability to support open as well as closed boundaries;</li>
<li>the ability to represent empty intervals in addition to nonempty ones;</li>
<li>the ability to represent intervals of extended number families that contain positive and negative infinities;</li>
<li>the ability to support (independently from the type of the boundaries) plain intervals of real numbers and intervals subject to generic <em>restrictions</em> (e.g., intervals of integer numbers). </li>
</ul>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa71726a7725f9269553ed9e594b0d74a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::simplify_using_context_assign" ref="aa71726a7725f9269553ed9e594b0d74a" args="(const From &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Boundary , typename Info &gt; </div>
<div class="memtemplate">
template&lt;typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Interval&lt; From &gt;::value, bool &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; Boundary, Info &gt;::simplify_using_context_assign </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> a <a class="el" href="main.html#Meet_Preserving_Simplification">meet-preserving simplification</a> of <code>*this</code> with respect to <code>y</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>false</code> if and only if the meet of <code>*this</code> and <code>y</code> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aca669c9659132e9fa6adc7a9afbef642"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::empty_intersection_assign" ref="aca669c9659132e9fa6adc7a9afbef642" args="(const From &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Boundary , typename Info &gt; </div>
<div class="memtemplate">
template&lt;typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Interval&lt; From &gt;::value, void &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; Boundary, Info &gt;::empty_intersection_assign </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> an interval having empty intersection with <code>y</code>. The assigned interval should be as large as possible. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Depending on interval restrictions, there could be many maximal intervals all inconsistent with respect to <code>y</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a869e3c010e87dff868fb410d4f0a20"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::refine_existential" ref="a6a869e3c010e87dff868fb410d4f0a20" args="(Relation_Symbol rel, const From &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To_Boundary , typename To_Info &gt; </div>
<div class="memtemplate">
template&lt;typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Singleton&lt; From &gt;::value||Is_Interval&lt; From &gt;::value, <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; To_Boundary, To_Info &gt;::refine_existential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"> <em>x</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refines <code>to</code> according to the existential relation <code>rel</code> with <code>x</code>. </p>
<p>The <code>to</code> interval is restricted to become, upon successful exit, the smallest interval of its type that contains the set </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \{\, a \in \mathtt{to} \mid \exists b \in \mathtt{x} \st a \mathrel{\mathtt{rel}} b \,\}. \]" src="form_717.png"/>
</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>??? </dd></dl>

</div>
</div>
<a class="anchor" id="ac3abadf1d96bef1880657113014d46dd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::refine_universal" ref="ac3abadf1d96bef1880657113014d46dd" args="(Relation_Symbol rel, const From &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To_Boundary , typename To_Info &gt; </div>
<div class="memtemplate">
template&lt;typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt; Is_Singleton&lt; From &gt;::value||Is_Interval&lt; From &gt;::value, <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; To_Boundary, To_Info &gt;::refine_universal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PPL__CXX__interface.html#ga1c2a279a3ffa1d1e9947f2667be312ae">Relation_Symbol</a>&#160;</td>
          <td class="paramname"> <em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"> <em>x</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refines <code>to</code> so that it satisfies the universal relation <code>rel</code> with <code>x</code>. </p>
<p>The <code>to</code> interval is restricted to become, upon successful exit, the smallest interval of its type that contains the set </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \{\, a \in \mathtt{to} \mid \forall b \in \mathtt{x} \itc a \mathrel{\mathtt{rel}} b \,\}. \]" src="form_718.png"/>
</p>
 <dl class="return"><dt><b>Returns:</b></dt><dd>??? </dd></dl>

</div>
</div>
<a class="anchor" id="a1c76acbe653414cc28fac54c69622446"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::mul_assign" ref="a1c76acbe653414cc28fac54c69622446" args="(const From1 &amp;x, const From2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To_Boundary , typename To_Info &gt; </div>
<div class="memtemplate">
template&lt;typename From1 , typename From2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt;((Is_Singleton&lt; From1 &gt;::value||Is_Interval&lt; From1 &gt;::value)&amp;&amp;(Is_Singleton&lt; From2 &gt;::value||Is_Interval&lt; From2 &gt;::value)), <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; To_Boundary, To_Info &gt;::mul_assign </td>
          <td>(</td>
          <td class="paramtype">const From1 &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const From2 &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>+---------+-----------+-----------+-----------------+ | * | yl &gt; 0 | yu &lt; 0 | yl &lt; 0, yu &gt; 0 | +---------+-----------+-----------+-----------------+ | xl &gt; 0 |xl*yl,xu*yu|xu*yl,xl*yu| xu*yl,xu*yu | +---------+-----------+-----------+-----------------+ | xu &lt; 0 |xl*yu,xu*yl|xu*yu,xl*yl| xl*yu,xl*yl | +---------+-----------+-----------+-----------------+ |xl&lt;0 xu&gt;0|xl*yu,xu*yu|xu*yl,xl*yl|min(xl*yu,xu*yl),| | | | |max(xl*yl,xu*yu) | +---------+-----------+-----------+-----------------+ </p>

</div>
</div>
<a class="anchor" id="af3699ea93d8ec71859566480bede9332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::div_assign" ref="af3699ea93d8ec71859566480bede9332" args="(const From1 &amp;x, const From2 &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To_Boundary , typename To_Info &gt; </div>
<div class="memtemplate">
template&lt;typename From1 , typename From2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Enable_If&lt;((Is_Singleton&lt; From1 &gt;::value||Is_Interval&lt; From1 &gt;::value)&amp;&amp;(Is_Singleton&lt; From2 &gt;::value||Is_Interval&lt; From2 &gt;::value)), <a class="el" href="namespaceParma__Polyhedra__Library.html#a1c146f8a7a8bb517f38dad49696f2766">I_Result</a> &gt;::type <a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; To_Boundary, To_Info &gt;::div_assign </td>
          <td>(</td>
          <td class="paramtype">const From1 &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const From2 &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>+-----------+-----------+-----------+ | / | yu &lt; 0 | yl &gt; 0 | +-----------+-----------+-----------+ | xu&lt;=0 |xu/yl,xl/yu|xl/yl,xu/yu| +-----------+-----------+-----------+ |xl&lt;=0 xu&gt;=0|xu/yu,xl/yu|xl/yl,xu/yl| +-----------+-----------+-----------+ | xl&gt;=0 |xu/yu,xl/yl|xl/yu,xu/yl| +-----------+-----------+-----------+ </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a79370159de3dc1738441b20eff866329"></a><!-- doxytag: member="Parma_Polyhedra_Library::Interval::swap" ref="a79370159de3dc1738441b20eff866329" args="(Parma_Polyhedra_Library::Interval&lt; Boundary, Info &gt; &amp;x, Parma_Polyhedra_Library::Interval&lt; Boundary, Info &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Boundary , typename Info &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; Boundary, Info &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Interval.html">Parma_Polyhedra_Library::Interval</a>&lt; Boundary, Info &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
