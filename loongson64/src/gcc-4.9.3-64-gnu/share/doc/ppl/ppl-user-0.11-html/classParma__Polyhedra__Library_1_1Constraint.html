<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Constraint Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Constraint Class Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Constraint" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Linear_Row" -->
<p>A linear equality or inequality.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p>Inherits Parma_Polyhedra_Library::Linear_Row.</p>

<p><a href="classParma__Polyhedra__Library_1_1Constraint-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6ab">Type</a> { <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6abab5b32713c840499d9e29facf95a17f41">EQUALITY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6abac1539389d3643cf986ef5bb99697d1cc">NONSTRICT_INEQUALITY</a>, 
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6aba7491a8ba26958c3e27bed23b7eef1a7e">STRICT_INEQUALITY</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The constraint type. </p>
 <a href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6ab">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a0c8ccab7923610bd27f637af63e1d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::Constraint" ref="a36a0c8ccab7923610bd27f637af63e1d" args="(const Constraint &amp;c)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d">Constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a8fb8b2fe343e5afa80edc06bfa31460b">Constraint</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from equality congruence <code>cg</code>.  <a href="#a8fb8b2fe343e5afa80edc06bfa31460b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7bf9d127644aa14a09eab633e87f544"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::~Constraint" ref="ac7bf9d127644aa14a09eab633e87f544" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac7bf9d127644aa14a09eab633e87f544">~Constraint</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dc926136daee1f47975434ee45298ec"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator=" ref="a9dc926136daee1f47975434ee45298ec" args="(const Constraint &amp;c)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a9dc926136daee1f47975434ee45298ec">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c1dcd74ba0b2509f45aad45a5d922ce"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::space_dimension" ref="a3c1dcd74ba0b2509f45aad45a5d922ce" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a3c1dcd74ba0b2509f45aad45a5d922ce">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a239b0622fbcfe1638b4246deab2caa29"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::type" ref="a239b0622fbcfe1638b4246deab2caa29" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6ab">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a239b0622fbcfe1638b4246deab2caa29">type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint type of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a745ac1cdddf74c6f387cfbbbc566dc78"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_equality" ref="a745ac1cdddf74c6f387cfbbbc566dc78" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a745ac1cdddf74c6f387cfbbbc566dc78">is_equality</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an equality constraint. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6976f576e6e50941ee7a7b1a737c0eb"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_inequality" ref="ab6976f576e6e50941ee7a7b1a737c0eb" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ab6976f576e6e50941ee7a7b1a737c0eb">is_inequality</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is an inequality constraint (either strict or non-strict). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3186208850238a080373f035cd532cc"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_nonstrict_inequality" ref="ab3186208850238a080373f035cd532cc" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ab3186208850238a080373f035cd532cc">is_nonstrict_inequality</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a non-strict inequality constraint. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a442aecbe0ce384a7c1add146fb125ed6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_strict_inequality" ref="a442aecbe0ce384a7c1add146fb125ed6" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a442aecbe0ce384a7c1add146fb125ed6">is_strict_inequality</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a strict inequality constraint. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a2679da4dbd5b8c33ef607aee49690c2a">coefficient</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficient of <code>v</code> in <code>*this</code>.  <a href="#a2679da4dbd5b8c33ef607aee49690c2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9960963fb1f8fb56631e0402557065ae"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::inhomogeneous_term" ref="a9960963fb1f8fb56631e0402557065ae" args="() const " -->
Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a9960963fb1f8fb56631e0402557065ae">inhomogeneous_term</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inhomogeneous term of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c24741e21a4406ea8ad1588c768147"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::total_memory_in_bytes" ref="a78c24741e21a4406ea8ad1588c768147" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a78c24741e21a4406ea8ad1588c768147">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab383f3930179982937f7733a283a03"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::external_memory_in_bytes" ref="a0ab383f3930179982937f7733a283a03" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a0ab383f3930179982937f7733a283a03">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a29202eb817eb5c9d59433abeeb4f2eea">is_tautological</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true constraint).  <a href="#a29202eb817eb5c9d59433abeeb4f2eea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#aea0fedb82a525e6ada13cd7fd2d03225">is_inconsistent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false constraint).  <a href="#aea0fedb82a525e6ada13cd7fd2d03225"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#af8fcee7f8582b0afc9115eb1304c24f9">is_equivalent_to</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent constraints.  <a href="#af8fcee7f8582b0afc9115eb1304c24f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f18894c8f97fa0cd38736462f36132"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::ascii_dump" ref="ab0f18894c8f97fa0cd38736462f36132" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ab0f18894c8f97fa0cd38736462f36132">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bdaff085ea6859cdec9b27bffb6de4b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::ascii_dump" ref="a7bdaff085ea6859cdec9b27bffb6de4b" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a7bdaff085ea6859cdec9b27bffb6de4b">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93d5d6abf06ec551294c4c18abb4349d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::print" ref="a93d5d6abf06ec551294c4c18abb4349d" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a93d5d6abf06ec551294c4c18abb4349d">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d50a5df6b31c6de90fe366e18e750ff"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::ascii_load" ref="a0d50a5df6b31c6de90fe366e18e750ff" args="(std::istream &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a0d50a5df6b31c6de90fe366e18e750ff">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation (as produced by <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a7bdaff085ea6859cdec9b27bffb6de4b" title="Writes to s an ASCII representation of *this.">ascii_dump(std::ostream&amp;) const</a>) and sets <code>*this</code> accordingly. Returns <code>true</code> if successful, <code>false</code> otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6742bd7f3f2cb079b96900dda0147940"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::OK" ref="a6742bd7f3f2cb079b96900dda0147940" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a6742bd7f3f2cb079b96900dda0147940">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6ba487c08199e83a970fc49b53d3d0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::swap" ref="afa6ba487c08199e83a970fc49b53d3d0" args="(Constraint &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#afa6ba487c08199e83a970fc49b53d3d0">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09c8fc0753a389cc42f84c12f7920832"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::max_space_dimension" ref="a09c8fc0753a389cc42f84c12f7920832" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a09c8fc0753a389cc42f84c12f7920832">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab38d6ea061e7c2cb1595ba9cf2fd42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::initialize" ref="a0ab38d6ea061e7c2cb1595ba9cf2fd42" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a0ab38d6ea061e7c2cb1595ba9cf2fd42">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf207e746f4a3dc2722e254612dab3b3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::finalize" ref="aaf207e746f4a3dc2722e254612dab3b3" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#aaf207e746f4a3dc2722e254612dab3b3">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2935fff040a5b31930fff594a0b2596d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::zero_dim_false" ref="a2935fff040a5b31930fff594a0b2596d" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a2935fff040a5b31930fff594a0b2596d">zero_dim_false</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The unsatisfiable (zero-dimension space) constraint <img class="formulaInl" alt="$0 = 1$" src="form_343.png"/>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbde4b86cfca3e29a917650f4c9c62d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::zero_dim_positivity" ref="abbde4b86cfca3e29a917650f4c9c62d5" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#abbde4b86cfca3e29a917650f4c9c62d5">zero_dim_positivity</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The true (zero-dimension space) constraint <img class="formulaInl" alt="$0 \leq 1$" src="form_652.png"/>, also known as <em>positivity constraint</em>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#adba3d929f4317a38ad387c5b45a91199">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e1</code> = <code>e2</code>.  <a href="#adba3d929f4317a38ad387c5b45a91199"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a047a99eb91872d19730f4fd14a81f55c">operator==</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>v1</code> = <code>v2</code>.  <a href="#a047a99eb91872d19730f4fd14a81f55c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#af2eb5d22ef23937a261cfe3f6bc435e6">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e</code> = <code>n</code>.  <a href="#af2eb5d22ef23937a261cfe3f6bc435e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a448b4387171ec166085eb46aacedaad9">operator==</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>n</code> = <code>e</code>.  <a href="#a448b4387171ec166085eb46aacedaad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a61bc4f536e4c04b9594e1b6c7e13d76e">operator&gt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e1</code> &gt;= <code>e2</code>.  <a href="#a61bc4f536e4c04b9594e1b6c7e13d76e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a600a652347fb8718e0bc05f7230b8d8a">operator&gt;=</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>v1</code> &gt;= <code>v2</code>.  <a href="#a600a652347fb8718e0bc05f7230b8d8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ae3cacddb2450b8b685b8f39936a2b69d">operator&gt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e</code> &gt;= <code>n</code>.  <a href="#ae3cacddb2450b8b685b8f39936a2b69d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ae615df068adfbb40a0b0b7a993579d22">operator&gt;=</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>n</code> &gt;= <code>e</code>.  <a href="#ae615df068adfbb40a0b0b7a993579d22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#af06b2331eb3d080794682080b7f7eb1d">operator&lt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e1</code> &lt;= <code>e2</code>.  <a href="#af06b2331eb3d080794682080b7f7eb1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a423e3bb0d9886c630c3c227def9f2073">operator&lt;=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e</code> &lt;= <code>n</code>.  <a href="#a423e3bb0d9886c630c3c227def9f2073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#abdd61469bc5c6dfc6e97f306a751035c">operator&lt;=</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>n</code> &lt;= <code>e</code>.  <a href="#abdd61469bc5c6dfc6e97f306a751035c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#acc5c5125e7237c5913981b99a502f332">operator&gt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e1</code> &gt; <code>e2</code>.  <a href="#acc5c5125e7237c5913981b99a502f332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a61208276a246a505bd753ffbb568bfe7">operator&gt;</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>v1</code> &gt; <code>v2</code>.  <a href="#a61208276a246a505bd753ffbb568bfe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#af245f065572b31c8ca97e196e45f9cf9">operator&gt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e</code> &gt; <code>n</code>.  <a href="#af245f065572b31c8ca97e196e45f9cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a89943bdfa5424bf7acecc51a7b6949c8">operator&gt;</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>n</code> &gt; <code>e</code>.  <a href="#a89943bdfa5424bf7acecc51a7b6949c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a852f422dfdf14a1e8a97b4dad77f7e36">operator&lt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e1</code> &lt; <code>e2</code>.  <a href="#a852f422dfdf14a1e8a97b4dad77f7e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a3c920e734593812d8529bc12be6f503e">operator&lt;</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>e</code> &lt; <code>n</code>.  <a href="#a3c920e734593812d8529bc12be6f503e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a54742578f3ff98e32e7e15d6b554f13f">operator&lt;</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>n</code> &lt; <code>e</code>.  <a href="#a54742578f3ff98e32e7e15d6b554f13f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a340e8b886fb185bed798dcbc1391c126">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>.  <a href="#a340e8b886fb185bed798dcbc1391c126"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ae86d21a6490f299af6229d70cf20c3ba">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>.  <a href="#ae86d21a6490f299af6229d70cf20c3ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a2fb9117b8937e3d9a9b4d3ae397bb79a">operator&lt;=</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>v1</code> &lt;= <code>v2</code>.  <a href="#a2fb9117b8937e3d9a9b4d3ae397bb79a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a4b4c0277d3b6c85ab6633ae9f5e235c6">operator&lt;</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v1, <a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint <code>v1</code> &lt; <code>v2</code>.  <a href="#a4b4c0277d3b6c85ab6633ae9f5e235c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a66a2134e0f7fc74d62b14f46631dc2c7">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#a66a2134e0f7fc74d62b14f46631dc2c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#a182ea33f63c0eea708e02a32b0904f30">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a182ea33f63c0eea708e02a32b0904f30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#acedadd7f7742a18d941ded77da69ba9a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6ab">Constraint::Type</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#acedadd7f7742a18d941ded77da69ba9a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A linear equality or inequality. </p>
<p>An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html" title="A linear equality or inequality.">Constraint</a> is either:</p>
<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b = 0$" src="form_490.png"/>;</li>
<li>a non-strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b \geq 0$" src="form_491.png"/>; or</li>
<li>a strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b > 0$" src="form_492.png"/>;</li>
</ul>
<p>where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the dimension of the space, <img class="formulaInl" alt="$a_i$" src="form_234.png"/> is the integer coefficient of variable <img class="formulaInl" alt="$x_i$" src="form_485.png"/> and <img class="formulaInl" alt="$b$" src="form_235.png"/> is the integer inhomogeneous term.</p>
<dl class="user"><dt><b>How to build a constraint</b></dt><dd>Constraints are typically built by applying a relation symbol to a pair of linear expressions. Available relation symbols are equality (<code>==</code>), non-strict inequalities (<code>&gt;=</code> and <code>&lt;=</code>) and strict inequalities (<code>&lt;</code> and <code>&gt;</code>). The space dimension of a constraint is defined as the maximum space dimension of the arguments of its constructor.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following examples it is assumed that variables <code>x</code>, <code>y</code> and <code>z</code> are defined as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable z(2);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds the equality constraint <img class="formulaInl" alt="$3x + 5y - z = 0$" src="form_493.png"/>, having space dimension <img class="formulaInl" alt="$3$" src="form_487.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> eq_c(3*x + 5*y - z == 0);
</pre></div> The following code builds the (non-strict) inequality constraint <img class="formulaInl" alt="$4x \geq 2y - 13$" src="form_494.png"/>, having space dimension <img class="formulaInl" alt="$2$" src="form_489.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> ineq_c(4*x &gt;= 2*y - 13);
</pre></div> The corresponding strict inequality constraint <img class="formulaInl" alt="$4x > 2y - 13$" src="form_495.png"/> is obtained as follows: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> strict_ineq_c(4*x &gt; 2*y - 13);
</pre></div> An unsatisfiable constraint on the zero-dimension space <img class="formulaInl" alt="$\Rset^0$" src="form_175.png"/> can be specified as follows: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> false_c = <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a2935fff040a5b31930fff594a0b2596d" title="The unsatisfiable (zero-dimension space) constraint .">Constraint::zero_dim_false</a>();
</pre></div> Equivalent, but more involved ways are the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> false_c1(<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() == 1);
  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> false_c2(<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() &gt;= 1);
  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> false_c3(<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() &gt; 0);
</pre></div> In contrast, the following code defines an unsatisfiable constraint having space dimension <img class="formulaInl" alt="$3$" src="form_487.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> false_c(0*z == 1);
</pre></div></dd></dl>
<dl class="user"><dt><b>How to inspect a constraint</b></dt><dd>Several methods are provided to examine a constraint and extract all the encoded information: its space dimension, its type (equality, non-strict inequality, strict inequality) and the value of its integer coefficients.</dd></dl>
<dl class="user"><dt><b>Example 2</b></dt><dd>The following code shows how it is possible to access each single coefficient of a constraint. Given an inequality constraint (in this case <img class="formulaInl" alt="$x - 5y + 3z \leq 4$" src="form_496.png"/>), we construct a new constraint corresponding to its complement (thus, in this case we want to obtain the strict inequality constraint <img class="formulaInl" alt="$x - 5y + 3z > 4$" src="form_497.png"/>). <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> c1(x - 5*y + 3*z &lt;= 4);
  cout &lt;&lt; <span class="stringliteral">&quot;Constraint c1: &quot;</span> &lt;&lt; c1 &lt;&lt; endl;
  <span class="keywordflow">if</span> (c1.is_equality())
    cout &lt;&lt; <span class="stringliteral">&quot;Constraint c1 is not an inequality.&quot;</span> &lt;&lt; endl;
  <span class="keywordflow">else</span> {
    Linear_Expression e;
    <span class="keywordflow">for</span> (<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i = c1.space_dimension(); i-- &gt; 0; )
      e += c1.coefficient(Variable(i)) * Variable(i);
    e += c1.inhomogeneous_term();
    <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> c2 = c1.is_strict_inequality() ? (e &lt;= 0) : (e &lt; 0);
    cout &lt;&lt; <span class="stringliteral">&quot;Complement c2: &quot;</span> &lt;&lt; c2 &lt;&lt; endl;
  }
</pre></div> The actual output is the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Constraint.html#a36a0c8ccab7923610bd27f637af63e1d" title="Ordinary copy constructor.">Constraint</a> c1: -A + 5*B - 3*C &gt;= -4
  Complement c2: A - 5*B + 3*C &gt; 4
</pre></div> Note that, in general, the particular output obtained can be syntactically different from the (semantically equivalent) constraint considered. </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac9b8aa34a8ed8e2c3c38d0435adff6ab"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::Type" ref="ac9b8aa34a8ed8e2c3c38d0435adff6ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6ab">Parma_Polyhedra_Library::Constraint::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constraint type. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac9b8aa34a8ed8e2c3c38d0435adff6abab5b32713c840499d9e29facf95a17f41"></a><!-- doxytag: member="EQUALITY" ref="ac9b8aa34a8ed8e2c3c38d0435adff6abab5b32713c840499d9e29facf95a17f41" args="" -->EQUALITY</em>&nbsp;</td><td>
<p>The constraint is an equality. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac9b8aa34a8ed8e2c3c38d0435adff6abac1539389d3643cf986ef5bb99697d1cc"></a><!-- doxytag: member="NONSTRICT_INEQUALITY" ref="ac9b8aa34a8ed8e2c3c38d0435adff6abac1539389d3643cf986ef5bb99697d1cc" args="" -->NONSTRICT_INEQUALITY</em>&nbsp;</td><td>
<p>The constraint is a non-strict inequality. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac9b8aa34a8ed8e2c3c38d0435adff6aba7491a8ba26958c3e27bed23b7eef1a7e"></a><!-- doxytag: member="STRICT_INEQUALITY" ref="ac9b8aa34a8ed8e2c3c38d0435adff6aba7491a8ba26958c3e27bed23b7eef1a7e" args="" -->STRICT_INEQUALITY</em>&nbsp;</td><td>
<p>The constraint is a strict inequality. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8fb8b2fe343e5afa80edc06bfa31460b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::Constraint" ref="a8fb8b2fe343e5afa80edc06bfa31460b" args="(const Congruence &amp;cg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy-constructs from equality congruence <code>cg</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>cg</code> is a proper congruence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2679da4dbd5b8c33ef607aee49690c2a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::coefficient" ref="a2679da4dbd5b8c33ef607aee49690c2a" args="(Variable v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Constraint::coefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the coefficient of <code>v</code> in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>thrown if the index of <code>v</code> is greater than or equal to the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29202eb817eb5c9d59433abeeb4f2eea"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_tautological" ref="a29202eb817eb5c9d59433abeeb4f2eea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Constraint::is_tautological </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true constraint). </p>
<p>A tautology can have either one of the following forms:</p>
<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + 0 = 0$" src="form_653.png"/>; or</li>
<li>a non-strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \geq 0$" src="form_654.png"/>, where <img class="formulaInl" alt="$b \geq 0$" src="form_655.png"/>; or</li>
<li>a strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b > 0$" src="form_656.png"/>, where <img class="formulaInl" alt="$b > 0$" src="form_657.png"/>. </li>
</ul>

</div>
</div>
<a class="anchor" id="aea0fedb82a525e6ada13cd7fd2d03225"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_inconsistent" ref="aea0fedb82a525e6ada13cd7fd2d03225" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Constraint::is_inconsistent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false constraint). </p>
<p>An inconsistent constraint can have either one of the following forms:</p>
<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b = 0$" src="form_658.png"/>, where <img class="formulaInl" alt="$b \neq 0$" src="form_659.png"/>; or</li>
<li>a non-strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \geq 0$" src="form_654.png"/>, where <img class="formulaInl" alt="$b < 0$" src="form_660.png"/>; or</li>
<li>a strict inequality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b > 0$" src="form_656.png"/>, where <img class="formulaInl" alt="$b \leq 0$" src="form_661.png"/>. </li>
</ul>

</div>
</div>
<a class="anchor" id="af8fcee7f8582b0afc9115eb1304c24f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::is_equivalent_to" ref="af8fcee7f8582b0afc9115eb1304c24f9" args="(const Constraint &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Constraint::is_equivalent_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> and <code>y</code> are equivalent constraints. </p>
<p>Constraints having different space dimensions are not equivalent. Note that constraints having different types may nonetheless be equivalent, if they both are tautologies or inconsistent. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="adba3d929f4317a38ad387c5b45a91199"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="adba3d929f4317a38ad387c5b45a91199" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e1</code> = <code>e2</code>. </p>

</div>
</div>
<a class="anchor" id="a047a99eb91872d19730f4fd14a81f55c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="a047a99eb91872d19730f4fd14a81f55c" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>v1</code> = <code>v2</code>. </p>

</div>
</div>
<a class="anchor" id="af2eb5d22ef23937a261cfe3f6bc435e6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="af2eb5d22ef23937a261cfe3f6bc435e6" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e</code> = <code>n</code>. </p>

</div>
</div>
<a class="anchor" id="a448b4387171ec166085eb46aacedaad9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="a448b4387171ec166085eb46aacedaad9" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator== </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>n</code> = <code>e</code>. </p>

</div>
</div>
<a class="anchor" id="a61bc4f536e4c04b9594e1b6c7e13d76e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="a61bc4f536e4c04b9594e1b6c7e13d76e" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e1</code> &gt;= <code>e2</code>. </p>

</div>
</div>
<a class="anchor" id="a600a652347fb8718e0bc05f7230b8d8a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="a600a652347fb8718e0bc05f7230b8d8a" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>v1</code> &gt;= <code>v2</code>. </p>

</div>
</div>
<a class="anchor" id="ae3cacddb2450b8b685b8f39936a2b69d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="ae3cacddb2450b8b685b8f39936a2b69d" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e</code> &gt;= <code>n</code>. </p>

</div>
</div>
<a class="anchor" id="ae615df068adfbb40a0b0b7a993579d22"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;=" ref="ae615df068adfbb40a0b0b7a993579d22" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>n</code> &gt;= <code>e</code>. </p>

</div>
</div>
<a class="anchor" id="af06b2331eb3d080794682080b7f7eb1d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="af06b2331eb3d080794682080b7f7eb1d" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e1</code> &lt;= <code>e2</code>. </p>

</div>
</div>
<a class="anchor" id="a423e3bb0d9886c630c3c227def9f2073"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="a423e3bb0d9886c630c3c227def9f2073" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e</code> &lt;= <code>n</code>. </p>

</div>
</div>
<a class="anchor" id="abdd61469bc5c6dfc6e97f306a751035c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="abdd61469bc5c6dfc6e97f306a751035c" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>n</code> &lt;= <code>e</code>. </p>

</div>
</div>
<a class="anchor" id="acc5c5125e7237c5913981b99a502f332"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="acc5c5125e7237c5913981b99a502f332" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e1</code> &gt; <code>e2</code>. </p>

</div>
</div>
<a class="anchor" id="a61208276a246a505bd753ffbb568bfe7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="a61208276a246a505bd753ffbb568bfe7" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>v1</code> &gt; <code>v2</code>. </p>

</div>
</div>
<a class="anchor" id="af245f065572b31c8ca97e196e45f9cf9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="af245f065572b31c8ca97e196e45f9cf9" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e</code> &gt; <code>n</code>. </p>

</div>
</div>
<a class="anchor" id="a89943bdfa5424bf7acecc51a7b6949c8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&gt;" ref="a89943bdfa5424bf7acecc51a7b6949c8" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>n</code> &gt; <code>e</code>. </p>

</div>
</div>
<a class="anchor" id="a852f422dfdf14a1e8a97b4dad77f7e36"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="a852f422dfdf14a1e8a97b4dad77f7e36" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e1</code> &lt; <code>e2</code>. </p>

</div>
</div>
<a class="anchor" id="a3c920e734593812d8529bc12be6f503e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="a3c920e734593812d8529bc12be6f503e" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>e</code> &lt; <code>n</code>. </p>

</div>
</div>
<a class="anchor" id="a54742578f3ff98e32e7e15d6b554f13f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="a54742578f3ff98e32e7e15d6b554f13f" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>n</code> &lt; <code>e</code>. </p>

</div>
</div>
<a class="anchor" id="a340e8b886fb185bed798dcbc1391c126"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator==" ref="a340e8b886fb185bed798dcbc1391c126" args="(const Constraint &amp;x, const Constraint &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> is equivalent to <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="ae86d21a6490f299af6229d70cf20c3ba"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator!=" ref="ae86d21a6490f299af6229d70cf20c3ba" args="(const Constraint &amp;x, const Constraint &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> is not equivalent to <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="a2fb9117b8937e3d9a9b4d3ae397bb79a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;=" ref="a2fb9117b8937e3d9a9b4d3ae397bb79a" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>v1</code> &lt;= <code>v2</code>. </p>

</div>
</div>
<a class="anchor" id="a4b4c0277d3b6c85ab6633ae9f5e235c6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;" ref="a4b4c0277d3b6c85ab6633ae9f5e235c6" args="(Variable v1, Variable v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the constraint <code>v1</code> &lt; <code>v2</code>. </p>

</div>
</div>
<a class="anchor" id="a66a2134e0f7fc74d62b14f46631dc2c7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::swap" ref="a66a2134e0f7fc74d62b14f46631dc2c7" args="(Parma_Polyhedra_Library::Constraint &amp;x, Parma_Polyhedra_Library::Constraint &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Parma_Polyhedra_Library::Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<a class="anchor" id="a182ea33f63c0eea708e02a32b0904f30"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;&lt;" ref="a182ea33f63c0eea708e02a32b0904f30" args="(std::ostream &amp;s, const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<a class="anchor" id="acedadd7f7742a18d941ded77da69ba9a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Constraint::operator&lt;&lt;" ref="acedadd7f7742a18d941ded77da69ba9a" args="(std::ostream &amp;s, const Constraint::Type &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html#ac9b8aa34a8ed8e2c3c38d0435adff6ab">Constraint::Type</a> &amp;&#160;</td>
          <td class="paramname"> <em>t</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
