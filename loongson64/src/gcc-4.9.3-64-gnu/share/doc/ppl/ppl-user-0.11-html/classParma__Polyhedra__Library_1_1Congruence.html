<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Congruence Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Congruence Class Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Congruence" --><!-- doxytag: inherits="Parma_Polyhedra_Library::Row" -->
<p>A linear congruence.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p>Inherits Parma_Polyhedra_Library::Row.</p>

<p><a href="classParma__Polyhedra__Library_1_1Congruence-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba7dbedd485eab91821f129132a04723"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::Congruence" ref="aba7dbedd485eab91821f129132a04723" args="(const Congruence &amp;cg)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723">Congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinary copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a3a4c3af6146717b3302f467368eafe46">Congruence</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs (modulo 0) from equality constraint <code>c</code>.  <a href="#a3a4c3af6146717b3302f467368eafe46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab45e800217e1c61d8595e2ffc51a83ad"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::~Congruence" ref="ab45e800217e1c61d8595e2ffc51a83ad" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ab45e800217e1c61d8595e2ffc51a83ad">~Congruence</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c93e938cd478716c7c9e5e9988f7a98"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator=" ref="a2c93e938cd478716c7c9e5e9988f7a98" args="(const Congruence &amp;cg)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a2c93e938cd478716c7c9e5e9988f7a98">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a584cb5084fe5479b0c373e3d17fe5ffd"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::space_dimension" ref="a584cb5084fe5479b0c373e3d17fe5ffd" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a584cb5084fe5479b0c373e3d17fe5ffd">space_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space enclosing <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a79c648d88214174287e3763b804f4aaf">coefficient</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a> v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficient of <code>v</code> in <code>*this</code>.  <a href="#a79c648d88214174287e3763b804f4aaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c9879f0c9dcb81fe1bbf78828509ef6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::inhomogeneous_term" ref="a3c9879f0c9dcb81fe1bbf78828509ef6" args="() const " -->
Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a3c9879f0c9dcb81fe1bbf78828509ef6">inhomogeneous_term</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inhomogeneous term of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39b6f38fff55dd953ec509b3739dd17d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::modulus" ref="a39b6f38fff55dd953ec509b3739dd17d" args="() const " -->
Coefficient_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a39b6f38fff55dd953ec509b3739dd17d">modulus</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the modulus of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#aa03b119140132112557907b772102b33">operator/=</a> (Coefficient_traits::const_reference k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>k</code> into the modulus of <code>*this</code>.  <a href="#aa03b119140132112557907b772102b33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ae96eebded76c559c95910dc233c68f06">is_tautological</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true congruence).  <a href="#ae96eebded76c559c95910dc233c68f06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ac26379e5f82fd0223682b11b9e052ea5">is_inconsistent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false congruence).  <a href="#ac26379e5f82fd0223682b11b9e052ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a29c6deef0eb3911adbb08d36a8f0b3f2">is_proper_congruence</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the modulus is greater than zero.  <a href="#a29c6deef0eb3911adbb08d36a8f0b3f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a6609e54e84d50cd074c2dd65f38b47da">is_equality</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> is an equality.  <a href="#a6609e54e84d50cd074c2dd65f38b47da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad67d37524d1fb7f31766c0b02cb8591a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_equal_at_dimension" ref="ad67d37524d1fb7f31766c0b02cb8591a" args="(dimension_type dim, const Congruence &amp;cg) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ad67d37524d1fb7f31766c0b02cb8591a">is_equal_at_dimension</a> (<a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a> dim, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> is equal to <code>cg</code> in dimension <code>dim</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a484373d269a31c21efae44a83f8be6f0"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::total_memory_in_bytes" ref="a484373d269a31c21efae44a83f8be6f0" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a484373d269a31c21efae44a83f8be6f0">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ff04e47054c14b2edf29096ecc95ab7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::external_memory_in_bytes" ref="a0ff04e47054c14b2edf29096ecc95ab7" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a0ff04e47054c14b2edf29096ecc95ab7">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43983a6ee447e480f8700915bccb4811"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::ascii_dump" ref="a43983a6ee447e480f8700915bccb4811" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a43983a6ee447e480f8700915bccb4811">ascii_dump</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>std::cerr</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac53e4323b140cdd4ba1ac96e7204d93a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::ascii_dump" ref="ac53e4323b140cdd4ba1ac96e7204d93a" args="(std::ostream &amp;s) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ac53e4323b140cdd4ba1ac96e7204d93a">ascii_dump</a> (std::ostream &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to <code>s</code> an ASCII representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a146b211f83e22bd011d3de2e5975073b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::print" ref="a146b211f83e22bd011d3de2e5975073b" args="() const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a146b211f83e22bd011d3de2e5975073b">print</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>*this</code> to <code>std::cerr</code> using <code>operator&lt;&lt;</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94b3624c208219e401569cd289049b38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::ascii_load" ref="a94b3624c208219e401569cd289049b38" args="(std::istream &amp;s)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a94b3624c208219e401569cd289049b38">ascii_load</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads from <code>s</code> an ASCII representation of the internal representation of <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33e6005a1fe40cb202eb619912c25c3c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::OK" ref="a33e6005a1fe40cb202eb619912c25c3c" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a33e6005a1fe40cb202eb619912c25c3c">OK</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a207ecd92e9fd8f3b1937a5064746a9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::max_space_dimension" ref="a5a207ecd92e9fd8f3b1937a5064746a9" args="()" -->
static <a class="el" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de">dimension_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a5a207ecd92e9fd8f3b1937a5064746a9">max_space_dimension</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum space dimension a <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html" title="A linear congruence.">Congruence</a> can handle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab917a480b6afe7e2750aa2862c6783cf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::initialize" ref="ab917a480b6afe7e2750aa2862c6783cf" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ab917a480b6afe7e2750aa2862c6783cf">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ca2446f563956eb2b92ddd17e5c0b2c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::finalize" ref="a2ca2446f563956eb2b92ddd17e5c0b2c" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a2ca2446f563956eb2b92ddd17e5c0b2c">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad07dc0dabac5685f9db8d9dc11e513f1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::zero_dim_integrality" ref="ad07dc0dabac5685f9db8d9dc11e513f1" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ad07dc0dabac5685f9db8d9dc11e513f1">zero_dim_integrality</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the true (zero-dimension space) congruence <img class="formulaInl" alt="$0 = 1 \pmod{1}$" src="form_682.png"/>, also known as the <em>integrality congruence</em>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aab82f7118966662582f88725ce4735"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::zero_dim_false" ref="a8aab82f7118966662582f88725ce4735" args="()" -->
static const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a8aab82f7118966662582f88725ce4735">zero_dim_false</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the false (zero-dimension space) congruence <img class="formulaInl" alt="$0 = 1 \pmod{0}$" src="form_683.png"/>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7facb7a06ac72f1af2bc514c788f1a38"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::create" ref="a7facb7a06ac72f1af2bc514c788f1a38" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
static <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a7facb7a06ac72f1af2bc514c788f1a38">create</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e1 = e2 \pmod{1}$" src="form_673.png"/>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57362a4d56c397575a6d043cdbcec0f9"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::create" ref="a57362a4d56c397575a6d043cdbcec0f9" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
static <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a57362a4d56c397575a6d043cdbcec0f9">create</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e = n \pmod{1}$" src="form_674.png"/>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b3db7ba1765b3a04f8d320968f70447"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::create" ref="a5b3db7ba1765b3a04f8d320968f70447" args="(Coefficient_traits::const_reference n, const Linear_Expression &amp;e)" -->
static <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a5b3db7ba1765b3a04f8d320968f70447">create</a> (Coefficient_traits::const_reference n, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$n = e \pmod{1}$" src="form_684.png"/>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a6a24743a95176da13995bb6c17151c9b">sign_normalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the signs.  <a href="#a6a24743a95176da13995bb6c17151c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a29c63b939ed830a0395170835e60beaf">normalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes signs and the inhomogeneous term.  <a href="#a29c63b939ed830a0395170835e60beaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#afcf86304f17dc474e1e5bbe0486c1b59">strong_normalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls normalize, then divides out common factors.  <a href="#afcf86304f17dc474e1e5bbe0486c1b59"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#aa948df90fc7880e7e52ceef297ee9bbf">operator/</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;cg, Coefficient_traits::const_reference k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>cg</code>, multiplying <code>k</code> into the copy's modulus.  <a href="#aa948df90fc7880e7e52ceef297ee9bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a2cb39e7c88e9e724e7970d0e953f2c81">operator/</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;c, Coefficient_traits::const_reference m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a congruence from <code>c</code>, with <code>m</code> as the modulus.  <a href="#a2cb39e7c88e9e724e7970d0e953f2c81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#adeee840f3313b6050d439dbe5fe2fdd7">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent.  <a href="#adeee840f3313b6050d439dbe5fe2fdd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#aaf7dc46b2cfbd6650ac1d2035d331f15">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if and only if <code>x</code> and <code>y</code> are equivalent.  <a href="#aaf7dc46b2cfbd6650ac1d2035d331f15"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ae0c9395c1ac4d96e245be43fcd76424c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operators.  <a href="#ae0c9395c1ac4d96e245be43fcd76424c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a7415de7b412a5e297810ff35a97a2849">operator%=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e1, const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e1 = e2 \pmod{1}$" src="form_673.png"/>.  <a href="#a7415de7b412a5e297810ff35a97a2849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#a54cdd6074f90a5623c8ae7ddcfedc5c2">operator%=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;e, Coefficient_traits::const_reference n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the congruence <img class="formulaInl" alt="$e = n \pmod{1}$" src="form_674.png"/>.  <a href="#a54cdd6074f90a5623c8ae7ddcfedc5c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html#ac8652f34bdfa731c02c1900f62bd5e88">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#ac8652f34bdfa731c02c1900f62bd5e88"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A linear congruence. </p>
<p>An object of the class <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html" title="A linear congruence.">Congruence</a> is a congruence:</p>
<ul>
<li><img class="formulaInl" alt="$\cg = \sum_{i=0}^{n-1} a_i x_i + b = 0 \pmod m$" src="form_517.png"/></li>
</ul>
<p>where <img class="formulaInl" alt="$n$" src="form_0.png"/> is the dimension of the space, <img class="formulaInl" alt="$a_i$" src="form_234.png"/> is the integer coefficient of variable <img class="formulaInl" alt="$x_i$" src="form_485.png"/>, <img class="formulaInl" alt="$b$" src="form_235.png"/> is the integer inhomogeneous term and <img class="formulaInl" alt="$m$" src="form_168.png"/> is the integer modulus; if <img class="formulaInl" alt="$m = 0$" src="form_174.png"/>, then <img class="formulaInl" alt="$\cg$" src="form_406.png"/> represents the equality congruence <img class="formulaInl" alt="$\sum_{i=0}^{n-1} a_i x_i + b = 0$" src="form_490.png"/> and, if <img class="formulaInl" alt="$m \neq 0$" src="form_518.png"/>, then the congruence <img class="formulaInl" alt="$\cg$" src="form_406.png"/> is said to be a proper congruence.</p>
<dl class="user"><dt><b>How to build a congruence</b></dt><dd>Congruences <img class="formulaInl" alt="$\pmod{1}$" src="form_519.png"/> are typically built by applying the congruence symbol `<code>%=</code>' to a pair of linear expressions. Congruences with modulus <code>m</code> are typically constructed by building a congruence <img class="formulaInl" alt="$\pmod{1}$" src="form_519.png"/> using the given pair of linear expressions and then adding the modulus <code>m</code> using the modulus symbol is `<code>/</code>'.</dd></dl>
<p>The space dimension of a congruence is defined as the maximum space dimension of the arguments of its constructor.</p>
<dl class="user"><dt><b></b></dt><dd>In the following examples it is assumed that variables <code>x</code>, <code>y</code> and <code>z</code> are defined as follows: <div class="fragment"><pre class="fragment">  Variable x(0);
  Variable y(1);
  Variable z(2);
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 1</b></dt><dd>The following code builds the equality congruence <img class="formulaInl" alt="$3x + 5y - z = 0$" src="form_493.png"/>, having space dimension <img class="formulaInl" alt="$3$" src="form_487.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> eq_cg((3*x + 5*y - z %= 0) / 0);
</pre></div> The following code builds the congruence <img class="formulaInl" alt="$4x = 2y - 13 \pmod{1}$" src="form_520.png"/>, having space dimension <img class="formulaInl" alt="$2$" src="form_489.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> mod1_cg(4*x %= 2*y - 13);
</pre></div> The following code builds the congruence <img class="formulaInl" alt="$4x = 2y - 13 \pmod{2}$" src="form_521.png"/>, having space dimension <img class="formulaInl" alt="$2$" src="form_489.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> mod2_cg((4*x %= 2*y - 13) / 2);
</pre></div> An unsatisfiable congruence on the zero-dimension space <img class="formulaInl" alt="$\Rset^0$" src="form_175.png"/> can be specified as follows: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> false_cg = <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#a8aab82f7118966662582f88725ce4735" title="Returns a reference to the false (zero-dimension space) congruence .">Congruence::zero_dim_false</a>();
</pre></div> Equivalent, but more involved ways are the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> false_cg1((<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() %= 1) / 0);
  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> false_cg2((<a class="code" href="classParma__Polyhedra__Library_1_1Linear__Expression.html#a6f8cd8fbee64faaa5e47c8e41ba7662e" title="Returns the (zero-dimension space) constant 0.">Linear_Expression::zero</a>() %= 1) / 2);
</pre></div> In contrast, the following code defines an unsatisfiable congruence having space dimension <img class="formulaInl" alt="$3$" src="form_487.png"/>: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> false_cg3((0*z %= 1) / 0);
</pre></div></dd></dl>
<dl class="user"><dt><b>How to inspect a congruence</b></dt><dd>Several methods are provided to examine a congruence and extract all the encoded information: its space dimension, its modulus and the value of its integer coefficients.</dd></dl>
<dl class="user"><dt><b>Example 2</b></dt><dd>The following code shows how it is possible to access the modulus as well as each of the coefficients. Given a congruence with linear expression <code>e</code> and modulus <code>m</code> (in this case <img class="formulaInl" alt="$x - 5y + 3z = 4 \pmod{5}$" src="form_522.png"/>), we construct a new congruence with the same modulus <code>m</code> but where the linear expression is <img class="formulaInl" alt="$2 e$" src="form_523.png"/> ( <img class="formulaInl" alt="$2x - 10y + 6z = 8 \pmod{5}$" src="form_524.png"/>). <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> cg1((x - 5*y + 3*z %= 4) / 5);
  cout &lt;&lt; <span class="stringliteral">&quot;Congruence cg1: &quot;</span> &lt;&lt; cg1 &lt;&lt; endl;
  <span class="keyword">const</span> <a class="code" href="group__PPL__CXX__interface.html#ga2c7a4b4311ef3639f73f40b414376899" title="An alias for easily naming the type of PPL coefficients.">Coefficient</a>&amp; m = cg1.modulus();
  <span class="keywordflow">if</span> (m == 0)
    cout &lt;&lt; <span class="stringliteral">&quot;Congruence cg1 is an equality.&quot;</span> &lt;&lt; endl;
  <span class="keywordflow">else</span> {
    Linear_Expression e;
    <span class="keywordflow">for</span> (<a class="code" href="group__PPL__CXX__interface.html#ga853432469169b07e42c557e1d6d144de" title="An unsigned integral type for representing space dimensions.">dimension_type</a> i = cg1.space_dimension(); i-- &gt; 0; )
      e += 2 * cg1.coefficient(Variable(i)) * Variable(i);
      e += 2 * cg1.inhomogeneous_term();
    <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> cg2((e %= 0) / m);
    cout &lt;&lt; <span class="stringliteral">&quot;Congruence cg2: &quot;</span> &lt;&lt; cg2 &lt;&lt; endl;
  }
</pre></div> The actual output could be the following: <div class="fragment"><pre class="fragment">  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> cg1: A - 5*B + 3*C %= 4 / 5
  <a class="code" href="classParma__Polyhedra__Library_1_1Congruence.html#aba7dbedd485eab91821f129132a04723" title="Ordinary copy constructor.">Congruence</a> cg2: 2*A - 10*B + 6*C %= 8 / 5
</pre></div> Note that, in general, the particular output obtained can be syntactically different from the (semantically equivalent) congruence considered. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3a4c3af6146717b3302f467368eafe46"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::Congruence" ref="a3a4c3af6146717b3302f467368eafe46" args="(const Constraint &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parma_Polyhedra_Library::Congruence::Congruence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy-constructs (modulo 0) from equality constraint <code>c</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>c</code> is an inequality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a79c648d88214174287e3763b804f4aaf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::coefficient" ref="a79c648d88214174287e3763b804f4aaf" args="(Variable v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient_traits::const_reference Parma_Polyhedra_Library::Congruence::coefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the coefficient of <code>v</code> in <code>*this</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>thrown if the index of <code>v</code> is greater than or equal to the space dimension of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa03b119140132112557907b772102b33"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator/=" ref="aa03b119140132112557907b772102b33" args="(Coefficient_traits::const_reference k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp; Parma_Polyhedra_Library::Congruence::operator/= </td>
          <td>(</td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>k</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies <code>k</code> into the modulus of <code>*this</code>. </p>
<p>If called with <code>*this</code> representing the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{m}$" src="form_675.png"/>, then it returns with *this representing the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{mk}$" src="form_676.png"/>. </p>

</div>
</div>
<a class="anchor" id="ae96eebded76c559c95910dc233c68f06"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_tautological" ref="ae96eebded76c559c95910dc233c68f06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_tautological </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is a tautology (i.e., an always true congruence). </p>
<p>A tautological congruence has one the following two forms:</p>
<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + 0 == 0$" src="form_677.png"/>; or</li>
<li>a proper congruence: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \%= 0 / m$" src="form_678.png"/>, where <img class="formulaInl" alt="$b = 0 \pmod{m}$" src="form_679.png"/>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac26379e5f82fd0223682b11b9e052ea5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_inconsistent" ref="ac26379e5f82fd0223682b11b9e052ea5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_inconsistent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>*this</code> is inconsistent (i.e., an always false congruence). </p>
<p>An inconsistent congruence has one of the following two forms:</p>
<ul>
<li>an equality: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b == 0$" src="form_680.png"/> where <img class="formulaInl" alt="$b \neq 0$" src="form_659.png"/>; or</li>
<li>a proper congruence: <img class="formulaInl" alt="$\sum_{i=0}^{n-1} 0 x_i + b \%= 0 / m$" src="form_678.png"/>, where <img class="formulaInl" alt="$b \neq 0 \pmod{m}$" src="form_681.png"/>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a29c6deef0eb3911adbb08d36a8f0b3f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_proper_congruence" ref="a29c6deef0eb3911adbb08d36a8f0b3f2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_proper_congruence </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if the modulus is greater than zero. </p>
<p>A congruence with a modulus of 0 is a linear equality. </p>

</div>
</div>
<a class="anchor" id="a6609e54e84d50cd074c2dd65f38b47da"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::is_equality" ref="a6609e54e84d50cd074c2dd65f38b47da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parma_Polyhedra_Library::Congruence::is_equality </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if <code>*this</code> is an equality. </p>
<p>A modulus of zero denotes a linear equality. </p>

</div>
</div>
<a class="anchor" id="a6a24743a95176da13995bb6c17151c9b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::sign_normalize" ref="a6a24743a95176da13995bb6c17151c9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Congruence::sign_normalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes the signs. </p>
<p>The signs of the coefficients and the inhomogeneous term are normalized, leaving the first non-zero homogeneous coefficient positive. </p>

</div>
</div>
<a class="anchor" id="a29c63b939ed830a0395170835e60beaf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::normalize" ref="a29c63b939ed830a0395170835e60beaf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Congruence::normalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes signs and the inhomogeneous term. </p>
<p>Applies sign_normalize, then reduces the inhomogeneous term to the smallest possible positive number. </p>

</div>
</div>
<a class="anchor" id="afcf86304f17dc474e1e5bbe0486c1b59"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::strong_normalize" ref="afcf86304f17dc474e1e5bbe0486c1b59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_Polyhedra_Library::Congruence::strong_normalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls normalize, then divides out common factors. </p>
<p>Strongly normalized Congruences have equivalent semantics if and only if their syntaxes (as output by operator&lt;&lt;) are equal. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa948df90fc7880e7e52ceef297ee9bbf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator/" ref="aa948df90fc7880e7e52ceef297ee9bbf" args="(const Congruence &amp;cg, Coefficient_traits::const_reference k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>cg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>k</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of <code>cg</code>, multiplying <code>k</code> into the copy's modulus. </p>
<p>If <code>cg</code> represents the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{m}$" src="form_675.png"/>, then the result represents the congruence <img class="formulaInl" alt="$ e_1 = e_2 \pmod{mk}$" src="form_676.png"/>.</p>

</div>
</div>
<a class="anchor" id="a2cb39e7c88e9e724e7970d0e953f2c81"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator/" ref="a2cb39e7c88e9e724e7970d0e953f2c81" args="(const Constraint &amp;c, Coefficient_traits::const_reference m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>m</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a congruence from <code>c</code>, with <code>m</code> as the modulus. </p>

</div>
</div>
<a class="anchor" id="adeee840f3313b6050d439dbe5fe2fdd7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator==" ref="adeee840f3313b6050d439dbe5fe2fdd7" args="(const Congruence &amp;x, const Congruence &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent. </p>

</div>
</div>
<a class="anchor" id="aaf7dc46b2cfbd6650ac1d2035d331f15"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator!=" ref="aaf7dc46b2cfbd6650ac1d2035d331f15" args="(const Congruence &amp;x, const Congruence &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>false</code> if and only if <code>x</code> and <code>y</code> are equivalent. </p>

</div>
</div>
<a class="anchor" id="ae0c9395c1ac4d96e245be43fcd76424c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator&lt;&lt;" ref="ae0c9395c1ac4d96e245be43fcd76424c" args="(std::ostream &amp;s, const Congruence &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>c</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operators. </p>

</div>
</div>
<a class="anchor" id="a7415de7b412a5e297810ff35a97a2849"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator%=" ref="a7415de7b412a5e297810ff35a97a2849" args="(const Linear_Expression &amp;e1, const Linear_Expression &amp;e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e2</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the congruence <img class="formulaInl" alt="$e1 = e2 \pmod{1}$" src="form_673.png"/>. </p>

</div>
</div>
<a class="anchor" id="a54cdd6074f90a5623c8ae7ddcfedc5c2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::operator%=" ref="a54cdd6074f90a5623c8ae7ddcfedc5c2" args="(const Linear_Expression &amp;e, Coefficient_traits::const_reference n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Congruence</a> operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Linear__Expression.html">Linear_Expression</a> &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient_traits::const_reference&#160;</td>
          <td class="paramname"> <em>n</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the congruence <img class="formulaInl" alt="$e = n \pmod{1}$" src="form_674.png"/>. </p>

</div>
</div>
<a class="anchor" id="ac8652f34bdfa731c02c1900f62bd5e88"></a><!-- doxytag: member="Parma_Polyhedra_Library::Congruence::swap" ref="ac8652f34bdfa731c02c1900f62bd5e88" args="(Parma_Polyhedra_Library::Congruence &amp;x, Parma_Polyhedra_Library::Congruence &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Congruence.html">Parma_Polyhedra_Library::Congruence</a> &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
