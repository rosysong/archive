<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PPL: Parma_Polyhedra_Library::Powerset&lt; D &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1-20100728 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceParma__Polyhedra__Library.html">Parma_Polyhedra_Library</a>      </li>
      <li><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Parma_Polyhedra_Library::Powerset&lt; D &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__PPL__CXX__interface.html">C++ Language Interface</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Parma_Polyhedra_Library::Powerset" -->
<p>The powerset construction on a base-level domain.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ppl.hh&gt;</code></p>

<p><a href="classParma__Polyhedra__Library_1_1Powerset-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef iterator_to_const<br class="typebreak"/>
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad25e2d27e5d731e6b63fb84a65700faf">Sequence</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a <em>read-only</em> bidirectional iterator on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a> element.  <a href="#aab7519865a52fbbc8dc2031135a9fb41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adab8b3f43dd9a5e707b95e15a9c282f8"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::const_iterator" ref="adab8b3f43dd9a5e707b95e15a9c282f8" args="" -->
typedef <br class="typebreak"/>
const_iterator_to_const<br class="typebreak"/>
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad25e2d27e5d731e6b63fb84a65700faf">Sequence</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional const_iterator on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a> element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36becc8c3ace976043199807351d5b04"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::reverse_iterator" ref="a36becc8c3ace976043199807351d5b04" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a36becc8c3ace976043199807351d5b04">reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse iterator type built from <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41" title="Alias for a read-only bidirectional iterator on the disjuncts of a Powerset element.">Powerset::iterator</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f4469416e02c586de17284317f8a92e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::const_reverse_iterator" ref="a6f4469416e02c586de17284317f8a92e" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a6f4469416e02c586de17284317f8a92e">const_reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse iterator type built from <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adab8b3f43dd9a5e707b95e15a9c282f8" title="A bidirectional const_iterator on the disjuncts of a Powerset element.">Powerset::const_iterator</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructor</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a900663a0e97525c064ccf31152fa8ae7"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Powerset" ref="a900663a0e97525c064ccf31152fa8ae7" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a900663a0e97525c064ccf31152fa8ae7">Powerset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: builds the bottom of the powerset constraint system (i.e., the empty powerset). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c71c9b7d1de1b77eeb054e1c0ac935e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Powerset" ref="a1c71c9b7d1de1b77eeb054e1c0ac935e" args="(const Powerset &amp;y)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a1c71c9b7d1de1b77eeb054e1c0ac935e">Powerset</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af60bb41867a12ce28144596e3cc1406a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Powerset" ref="af60bb41867a12ce28144596e3cc1406a" args="(const D &amp;d)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#af60bb41867a12ce28144596e3cc1406a">Powerset</a> (const D &amp;d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>d</code> is not bottom, builds a powerset containing only <code>d</code>. Builds the empty powerset otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3283cf8fd0dd8ff2a319cba1dead1f2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::~Powerset" ref="ac3283cf8fd0dd8ff2a319cba1dead1f2" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ac3283cf8fd0dd8ff2a319cba1dead1f2">~Powerset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that Do Not Modify the Powerset Object</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a411d42e5b59a492742793834efeeabc1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::definitely_entails" ref="a411d42e5b59a492742793834efeeabc1" args="(const Powerset &amp;y) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a411d42e5b59a492742793834efeeabc1">definitely_entails</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>*this</code> definitely entails <code>y</code>. Returns <code>false</code> if <code>*this</code> may not entail <code>y</code> (i.e., if <code>*this</code> does not entail <code>y</code> or if entailment could not be decided). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66e3e2f2433738665eb748d2f6c5878f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::is_top" ref="a66e3e2f2433738665eb748d2f6c5878f" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a66e3e2f2433738665eb748d2f6c5878f">is_top</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is the top element of the powerset constraint system (i.e., it represents the universe). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae006881831b298f0af5031e99df2bc6f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::is_bottom" ref="ae006881831b298f0af5031e99df2bc6f" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ae006881831b298f0af5031e99df2bc6f">is_bottom</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> is the bottom element of the powerset constraint system (i.e., it represents the empty set). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a36a32ab46d46f574f3091e931e2bd2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::total_memory_in_bytes" ref="a5a36a32ab46d46f574f3091e931e2bd2" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a5a36a32ab46d46f574f3091e931e2bd2">total_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the total size in bytes of the memory occupied by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdc1e9b5ac338be9d0584d50d275226e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::external_memory_in_bytes" ref="acdc1e9b5ac338be9d0584d50d275226e" args="() const " -->
<a class="el" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783">memory_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#acdc1e9b5ac338be9d0584d50d275226e">external_memory_in_bytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lower bound to the size in bytes of the memory managed by <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c82df1de8703aefeab268dc9ffc557f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::OK" ref="a8c82df1de8703aefeab268dc9ffc557f" args="(bool disallow_bottom=false) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a8c82df1de8703aefeab268dc9ffc557f">OK</a> (bool disallow_bottom=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the invariants are satisfied. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions for the Direct Manipulation of Disjuncts</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a7607ef1c8ef6b668dd2be62c39330406">omega_reduce</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops from the sequence of disjuncts in <code>*this</code> all the non-maximal elements so that <code>*this</code> is non-redundant.  <a href="#a7607ef1c8ef6b668dd2be62c39330406"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a277ba920e188477bb301196b19d63770"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::size" ref="a277ba920e188477bb301196b19d63770" args="() const " -->
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a277ba920e188477bb301196b19d63770">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of disjuncts. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a754f66ed06474d4b68a93131af02a86f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::empty" ref="a754f66ed06474d4b68a93131af02a86f" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a754f66ed06474d4b68a93131af02a86f">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if there are no disjuncts in <code>*this</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adab2c45cbec19ad11bf34db42b794508"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::begin" ref="adab2c45cbec19ad11bf34db42b794508" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adab2c45cbec19ad11bf34db42b794508">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first disjunct, if <code>*this</code> is not empty; otherwise, returns the past-the-end iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa215867508a89858bcc7ab025f8d20f1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::end" ref="aa215867508a89858bcc7ab025f8d20f1" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aa215867508a89858bcc7ab025f8d20f1">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the past-the-end iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a272424f5d0df282c6d1ee63a5c84e3e6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::begin" ref="a272424f5d0df282c6d1ee63a5c84e3e6" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a272424f5d0df282c6d1ee63a5c84e3e6">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator pointing to the first disjunct, if <code>*this</code> is not empty; otherwise, returns the past-the-end const_iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04aed5c92cf15c71ce85b8cc173a893b"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::end" ref="a04aed5c92cf15c71ce85b8cc173a893b" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adab8b3f43dd9a5e707b95e15a9c282f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a04aed5c92cf15c71ce85b8cc173a893b">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the past-the-end const_iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab66151b86ac8c495eba1a3209501928a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rbegin" ref="ab66151b86ac8c495eba1a3209501928a" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a36becc8c3ace976043199807351d5b04">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab66151b86ac8c495eba1a3209501928a">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse_iterator pointing to the last disjunct, if <code>*this</code> is not empty; otherwise, returns the before-the-start reverse_iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a241c65ff3d32769cbb9badd2c8e00ca5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rend" ref="a241c65ff3d32769cbb9badd2c8e00ca5" args="()" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a36becc8c3ace976043199807351d5b04">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a241c65ff3d32769cbb9badd2c8e00ca5">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the before-the-start reverse_iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fb86f09111d4ac21fdc7c7baa86e622"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rbegin" ref="a9fb86f09111d4ac21fdc7c7baa86e622" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a6f4469416e02c586de17284317f8a92e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a9fb86f09111d4ac21fdc7c7baa86e622">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator pointing to the last disjunct, if <code>*this</code> is not empty; otherwise, returns the before-the-start const_reverse_iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb3117d3d7d0566a99f9f5807276864"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::rend" ref="a5eb3117d3d7d0566a99f9f5807276864" args="() const " -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a6f4469416e02c586de17284317f8a92e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a5eb3117d3d7d0566a99f9f5807276864">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the before-the-start const_reverse_iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44b0a622563e60fe28b91b7e9ff76364"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::add_disjunct" ref="a44b0a622563e60fe28b91b7e9ff76364" args="(const D &amp;d)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a44b0a622563e60fe28b91b7e9ff76364">add_disjunct</a> (const D &amp;d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>d</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a386fa9c84bc37468f1a3a2b860a0bc3d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::drop_disjunct" ref="a386fa9c84bc37468f1a3a2b860a0bc3d" args="(iterator position)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a386fa9c84bc37468f1a3a2b860a0bc3d">drop_disjunct</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the disjunct in <code>*this</code> pointed to by <code>position</code>, returning an iterator to the disjunct following <code>position</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37703f96495cf4bcb8ced3ff20e4c396"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::drop_disjuncts" ref="a37703f96495cf4bcb8ced3ff20e4c396" args="(iterator first, iterator last)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a37703f96495cf4bcb8ced3ff20e4c396">drop_disjuncts</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> first, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops all the disjuncts from <code>first</code> to <code>last</code> (excluded). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2edf5fe7007a3e91a404546ca2f2d98c"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::clear" ref="a2edf5fe7007a3e91a404546ca2f2d98c" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a2edf5fe7007a3e91a404546ca2f2d98c">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops all the disjuncts, making <code>*this</code> an empty powerset. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member Functions that May Modify the Powerset Object</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab955487a974e74224f3d72d743ee78a4"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator=" ref="ab955487a974e74224f3d72d743ee78a4" args="(const Powerset &amp;y)" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ab955487a974e74224f3d72d743ee78a4">operator=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe22acf3f8e5b6c20880acd443350482"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::swap" ref="afe22acf3f8e5b6c20880acd443350482" args="(Powerset &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#afe22acf3f8e5b6c20880acd443350482">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>*this</code> with <code>y</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a113964ab3d7ea36326ce962629a322ce"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::least_upper_bound_assign" ref="a113964ab3d7ea36326ce962629a322ce" args="(const Powerset &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a113964ab3d7ea36326ce962629a322ce">least_upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#adef4c62b5cdf5186801c592cc62dccea">upper_bound_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code>.  <a href="#adef4c62b5cdf5186801c592cc62dccea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a01b873b0e820222e07789c3ba5fa48ae">upper_bound_assign_if_exact</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code> and returns <code>true</code>.  <a href="#a01b873b0e820222e07789c3ba5fa48ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3bda090e4ac93d937ac4dd775c20919"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::meet_assign" ref="ad3bda090e4ac93d937ac4dd775c20919" args="(const Powerset &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad3bda090e4ac93d937ac4dd775c20919">meet_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the meet of <code>*this</code> and <code>y</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ee74f5687635ddbb9729be31a37e2d3"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::collapse" ref="a1ee74f5687635ddbb9729be31a37e2d3" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a1ee74f5687635ddbb9729be31a37e2d3">collapse</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>*this</code> is not empty (i.e., it is not the bottom element), it is reduced to a singleton obtained by computing an upper-bound of all the disjuncts. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad25e2d27e5d731e6b63fb84a65700faf">Sequence</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A powerset is implemented as a sequence of elements.  <a href="#ad25e2d27e5d731e6b63fb84a65700faf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5534b8f8fbd973bfb7051cf5fb31f19d"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Sequence_iterator" ref="a5534b8f8fbd973bfb7051cf5fb31f19d" args="" -->
typedef Sequence::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a5534b8f8fbd973bfb7051cf5fb31f19d">Sequence_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the low-level iterator on the disjuncts. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3bee913efb87e4661df746e184e1e1"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Sequence_const_iterator" ref="a5c3bee913efb87e4661df746e184e1e1" args="" -->
typedef Sequence::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a5c3bee913efb87e4661df746e184e1e1">Sequence_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the low-level const_iterator on the disjuncts. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e0b0c2c668e73566cb1720d72cdac2"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::is_omega_reduced" ref="a30e0b0c2c668e73566cb1720d72cdac2" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a30e0b0c2c668e73566cb1720d72cdac2">is_omega_reduced</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>*this</code> does not contain non-maximal elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee126cc2eef44ab1d2055d0d15bc3169"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::collapse" ref="aee126cc2eef44ab1d2055d0d15bc3169" args="(unsigned max_disjuncts)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aee126cc2eef44ab1d2055d0d15bc3169">collapse</a> (unsigned max_disjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Upon return, <code>*this</code> will contain at most <code>max_disjuncts</code> elements; the set of disjuncts in positions greater than or equal to <code>max_disjuncts</code>, will be replaced at that position by their upper-bound. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a0a660ed1cfae2599d7f9236f2084d499">add_non_bottom_disjunct_preserve_reduction</a> (const D &amp;d, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> first, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and ensuring partial Omega-reduction.  <a href="#a0a660ed1cfae2599d7f9236f2084d499"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a86f44d9d38638be46ef23422783f847e">add_non_bottom_disjunct_preserve_reduction</a> (const D &amp;d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and preserving Omega-reduction.  <a href="#a86f44d9d38638be46ef23422783f847e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Binary_Operator_Assign &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aba65a2c1a6d563f5058479bc07181b9a">pairwise_apply_assign</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a> &amp;y, Binary_Operator_Assign op_assign)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns to <code>*this</code> the result of applying <code>op_assign</code> pairwise to the elements in <code>*this</code> and <code>y</code>.  <a href="#aba65a2c1a6d563f5058479bc07181b9a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d2c2fc2c077e77db657af49d332c9b5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::sequence" ref="a5d2c2fc2c077e77db657af49d332c9b5" args="" -->
<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad25e2d27e5d731e6b63fb84a65700faf">Sequence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a5d2c2fc2c077e77db657af49d332c9b5">sequence</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequence container holding powerset's elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad34bafd07f582c558936f9ea8892abd6"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::reduced" ref="ad34bafd07f582c558936f9ea8892abd6" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad34bafd07f582c558936f9ea8892abd6">reduced</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, <code>*this</code> is Omega-reduced. <br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a057c4f38d0e8b8a146af731dbd91864f">operator==</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent.  <a href="#a057c4f38d0e8b8a146af731dbd91864f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a2a7c225e4f50e2287216dcd77eaf27d5">operator!=</a> (const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;x, const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are not equivalent.  <a href="#a2a7c225e4f50e2287216dcd77eaf27d5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a8691a3facce4d6f973b48743fa42ec42">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="#a8691a3facce4d6f973b48743fa42ec42"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aa55b32c299b7d7bec303f636b66ef624">swap</a> (<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;x, <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <code>std::swap</code>.  <a href="#aa55b32c299b7d7bec303f636b66ef624"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename D&gt;<br/>
 class Parma_Polyhedra_Library::Powerset&lt; D &gt;</h3>

<p>The powerset construction on a base-level domain. </p>
<p>This class offers a generic implementation of a <em>powerset</em> domain as defined in Section <a class="el" href="main.html#powerset">The Powerset Construction</a>.</p>
<p>Besides invoking the available methods on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a>, this class also provides bidirectional iterators that allow for a direct inspection of these disjuncts. For a consistent handling of Omega-reduction, all the iterators are <em>read-only</em>, meaning that the disjuncts cannot be overwritten. Rather, by using the class <code>iterator</code>, it is possible to drop one or more disjuncts (possibly so as to later add back modified versions). As an example of iterator usage, the following template function drops from powerset <code>ps</code> all the disjuncts that would have become redundant by the addition of an external element <code>d</code>.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
<span class="keywordtype">void</span>
drop_subsumed(Powerset&lt;D&gt;&amp; ps, <span class="keyword">const</span> D&amp; d) {
  <span class="keywordflow">for</span> (<span class="keyword">typename</span> Powerset&lt;D&gt;::iterator i = ps.begin(),
         ps_end = ps.end(), i != ps_end; )
    <span class="keywordflow">if</span> (i-&gt;definitely_entails(d))
      i = ps.drop_disjunct(i);
    <span class="keywordflow">else</span>
      ++i;
}
</pre></div><p>The template class D must provide the following methods. </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__PPL__CXX__interface.html#ga760aa1f95d13e389ec6eb33fdbf88783" title="An unsigned integral type for representing memory size in bytes.">memory_size_type</a> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a5a36a32ab46d46f574f3091e931e2bd2" title="Returns a lower bound to the total size in bytes of the memory occupied by *this.">total_memory_in_bytes</a>() const
</pre></div><p> Returns a lower bound on the total size in bytes of the memory occupied by the instance of D. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a66e3e2f2433738665eb748d2f6c5878f" title="Returns true if and only if *this is the top element of the powerset constraint system (i...">is_top</a>() const
</pre></div><p> Returns <code>true</code> if and only if the instance of D is the top element of the domain. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#ae006881831b298f0af5031e99df2bc6f" title="Returns true if and only if *this is the bottom element of the powerset constraint system (i...">is_bottom</a>() const
</pre></div><p> Returns <code>true</code> if and only if the instance of D is the bottom element of the domain. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a411d42e5b59a492742793834efeeabc1" title="Returns true if *this definitely entails y. Returns false if *this may not entail y (i...">definitely_entails</a>(<span class="keyword">const</span> D&amp; y) <span class="keyword">const</span>
</pre></div><p> Returns <code>true</code> if the instance of D definitely entails <code>y</code>. Returns <code>false</code> if the instance may not entail <code>y</code> (i.e., if the instance does not entail <code>y</code> or if entailment could not be decided). </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#adef4c62b5cdf5186801c592cc62dccea" title="Assigns to *this an upper bound of *this and y.">upper_bound_assign</a>(<span class="keyword">const</span> D&amp; y)
</pre></div><p> Assigns to the instance of D an upper bound of the instance and <code>y</code>. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#ad3bda090e4ac93d937ac4dd775c20919" title="Assigns to *this the meet of *this and y.">meet_assign</a>(<span class="keyword">const</span> D&amp; y)
</pre></div><p> Assigns to the instance of D the meet of the instance and <code>y</code>. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a8c82df1de8703aefeab268dc9ffc557f" title="Checks if all the invariants are satisfied.">OK</a>() const
</pre></div><p> Returns <code>true</code> if the instance of D is in a consistent state, else returns <code>false</code>.</p>
<p>The following operators on the template class D must be defined. </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a8691a3facce4d6f973b48743fa42ec42" title="Output operator.">operator&lt;&lt;</a>(std::ostream&amp; s, <span class="keyword">const</span> D&amp; x)
</pre></div><p> Writes a textual representation of the instance of D on <code>s</code>. </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a057c4f38d0e8b8a146af731dbd91864f" title="Returns true if and only if x and y are equivalent.">operator==</a>(<span class="keyword">const</span> D&amp; x, <span class="keyword">const</span> D&amp; y)
</pre></div><p> Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent D's. </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classParma__Polyhedra__Library_1_1Powerset.html#a2a7c225e4f50e2287216dcd77eaf27d5" title="Returns true if and only if x and y are not equivalent.">operator!=</a>(<span class="keyword">const</span> D&amp; x, <span class="keyword">const</span> D&amp; y)
</pre></div><p> Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are different D's. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ad25e2d27e5d731e6b63fb84a65700faf"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::Sequence" ref="ad25e2d27e5d731e6b63fb84a65700faf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;D&gt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad25e2d27e5d731e6b63fb84a65700faf">Sequence</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A powerset is implemented as a sequence of elements. </p>
<p>The particular sequence employed must support efficient deletion in any position and efficient back insertion. </p>

</div>
</div>
<a class="anchor" id="aab7519865a52fbbc8dc2031135a9fb41"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::iterator" ref="aab7519865a52fbbc8dc2031135a9fb41" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_to_const&lt;<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#ad25e2d27e5d731e6b63fb84a65700faf">Sequence</a>&gt; <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alias for a <em>read-only</em> bidirectional iterator on the disjuncts of a <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html" title="The powerset construction on a base-level domain.">Powerset</a> element. </p>
<p>By using this iterator type, the disjuncts cannot be overwritten, but they can be removed using methods <code><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a386fa9c84bc37468f1a3a2b860a0bc3d" title="Drops the disjunct in *this pointed to by position, returning an iterator to the disjunct following p...">drop_disjunct(iterator position)</a></code> and <code><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#a37703f96495cf4bcb8ced3ff20e4c396" title="Drops all the disjuncts from first to last (excluded).">drop_disjuncts(iterator first, iterator last)</a></code>, while still ensuring a correct handling of Omega-reduction. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7607ef1c8ef6b668dd2be62c39330406"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::omega_reduce" ref="a7607ef1c8ef6b668dd2be62c39330406" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::omega_reduce </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops from the sequence of disjuncts in <code>*this</code> all the non-maximal elements so that <code>*this</code> is non-redundant. </p>
<p>This method is declared <code>const</code> because, even though Omega-reduction may change the syntactic representation of <code>*this</code>, its semantics will be unchanged. </p>

</div>
</div>
<a class="anchor" id="adef4c62b5cdf5186801c592cc62dccea"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::upper_bound_assign" ref="adef4c62b5cdf5186801c592cc62dccea" args="(const Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::upper_bound_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> an upper bound of <code>*this</code> and <code>y</code>. </p>
<p>The result will be the least upper bound of <code>*this</code> and <code>y</code>. </p>

</div>
</div>
<a class="anchor" id="a01b873b0e820222e07789c3ba5fa48ae"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::upper_bound_assign_if_exact" ref="a01b873b0e820222e07789c3ba5fa48ae" args="(const Powerset &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::upper_bound_assign_if_exact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the least upper bound of <code>*this</code> and <code>y</code> and returns <code>true</code>. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&#160;</td><td>Thrown if <code>*this</code> and <code>y</code> are dimension-incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a660ed1cfae2599d7f9236f2084d499"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::add_non_bottom_disjunct_preserve_reduction" ref="a0a660ed1cfae2599d7f9236f2084d499" args="(const D &amp;d, iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt;::<a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a> <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::add_non_bottom_disjunct_preserve_reduction </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&#160;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a>&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html#aab7519865a52fbbc8dc2031135a9fb41">iterator</a>&#160;</td>
          <td class="paramname"> <em>last</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and ensuring partial Omega-reduction. </p>
<p>If <code>d</code> is not the bottom element and is not Omega-redundant with respect to elements in positions between <code>first</code> and <code>last</code>, all elements in these positions that would be made Omega-redundant by the addition of <code>d</code> are dropped and <code>d</code> is added to the reduced sequence. If <code>*this</code> is reduced before an invocation of this method, it will be reduced upon successful return from the method. </p>

</div>
</div>
<a class="anchor" id="a86f44d9d38638be46ef23422783f847e"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::add_non_bottom_disjunct_preserve_reduction" ref="a86f44d9d38638be46ef23422783f847e" args="(const D &amp;d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::add_non_bottom_disjunct_preserve_reduction </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&#160;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds to <code>*this</code> the disjunct <code>d</code>, assuming <code>d</code> is not the bottom element and preserving Omega-reduction. </p>
<p>If <code>*this</code> is reduced before an invocation of this method, it will be reduced upon successful return from the method. </p>

</div>
</div>
<a class="anchor" id="aba65a2c1a6d563f5058479bc07181b9a"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::pairwise_apply_assign" ref="aba65a2c1a6d563f5058479bc07181b9a" args="(const Powerset &amp;y, Binary_Operator_Assign op_assign)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
<div class="memtemplate">
template&lt;typename Binary_Operator_Assign &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt;::pairwise_apply_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Binary_Operator_Assign&#160;</td>
          <td class="paramname"> <em>op_assign</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns to <code>*this</code> the result of applying <code>op_assign</code> pairwise to the elements in <code>*this</code> and <code>y</code>. </p>
<p>The elements of the powerset result are obtained by applying <code>op_assign</code> to each pair of elements whose components are drawn from <code>*this</code> and <code>y</code>, respectively. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a057c4f38d0e8b8a146af731dbd91864f"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator==" ref="a057c4f38d0e8b8a146af731dbd91864f" args="(const Powerset&lt; D &gt; &amp;x, const Powerset&lt; D &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are equivalent. </p>

</div>
</div>
<a class="anchor" id="a2a7c225e4f50e2287216dcd77eaf27d5"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator!=" ref="a2a7c225e4f50e2287216dcd77eaf27d5" args="(const Powerset&lt; D &gt; &amp;x, const Powerset&lt; D &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if and only if <code>x</code> and <code>y</code> are not equivalent. </p>

</div>
</div>
<a class="anchor" id="a8691a3facce4d6f973b48743fa42ec42"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::operator&lt;&lt;" ref="a8691a3facce4d6f973b48743fa42ec42" args="(std::ostream &amp;s, const Powerset&lt; D &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator. </p>

</div>
</div>
<a class="anchor" id="aa55b32c299b7d7bec303f636b66ef624"></a><!-- doxytag: member="Parma_Polyhedra_Library::Powerset::swap" ref="aa55b32c299b7d7bec303f636b66ef624" args="(Parma_Polyhedra_Library::Powerset&lt; D &gt; &amp;x, Parma_Polyhedra_Library::Powerset&lt; D &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParma__Polyhedra__Library_1_1Powerset.html">Parma_Polyhedra_Library::Powerset</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"> <em>y</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specializes <code>std::swap</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppl.hh</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 2 2010 22:22:43 for PPL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1-20100728 </small></address>
</body>
</html>
